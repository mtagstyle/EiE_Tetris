###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       26/Jun/2018  22:49:21
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\drivers\sdcard.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\drivers\sdcard.c" -D EIE1
#        --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List" -o
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\sdcard.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\sdcard.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\drivers\sdcard.c
      1          /**********************************************************************************************************************
      2          File: sdcard.c                                                                
      3          
      4          Description:
      5          SD card interface application.  This task looks for an SD card and initializes it so it is ready
      6          to receive data read / write commands.  
      7          
      8          API
      9          Client applications may use the following functions to access this driver:
     10          
     11          SdGetStatus() - returns a variable of type SdCardStateType which may have the following value:
     12            SD_NO_CARD: no card is inserted.
     13            SD_CARD_ERROR: an inserted card has an error.
     14            SD_IDLE: card is ready and waiting for a read or a write to be requested.
     15            SD_READING: the card is being read and is not available for anything else 
     16            SD_DATA_READY: a sector of data has been requested from the SD card is ready for the client.
     17            SD_WRITING: the card is being written and is not available for anything else
     18          
     19          bool SdReadBlock(u32 u32SectorAddress_) - initiates read of one 512 byte block of memory from the SD card.
     20          Returns TRUE if the card is available and can start reading. 
     21          User must use SdGetStatus() and wait until the card status is SD_DATA_READY which means the read is done.
     22          
     23          bool SdWriteBlock(u32 u32BlockAddress_) - not yet implemented
     24          
     25          bool SdGetReadData(u8* pu8Destination_) - transfers the read data to the client.  The card state will return to SD_IDLE.
     26          
     27          
     28          **********************************************************************************************************************/
     29          
     30          #include "configuration.h"
     31          
     32          /***********************************************************************************************************************
     33          Global variable definitions with scope across entire project.
     34          All Global variable names shall start with "G_"
     35          ***********************************************************************************************************************/
     36          /* New variables */

   \                                 In section .bss, align 4
     37          volatile u32 G_u32SdCardFlags;                         /* Global state flags */
   \                     G_u32SdCardFlags:
   \   00000000                      DS8 4
     38          
     39          
     40          /*--------------------------------------------------------------------------------------------------------------------*/
     41          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     42          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     43          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     44          
     45          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     46          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     47          
     48          
     49          /***********************************************************************************************************************
     50          Global variable definitions with scope limited to this local application.
     51          Variable names shall start with "SD_" and be declared as static.
     52          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     53          static fnCode_type SD_pfStateMachine;              /* The Debug state machine function pointer */
   \                     SD_pfStateMachine:
   \   00000000                      DS8 4
     54          

   \                                 In section .bss, align 4
     55          static u32 SD_u32Flags;                            /* Application flags for SD card */
   \                     SD_u32Flags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     56          static SdCardStateType SD_CardState;               /* Card state variable */
   \                     SD_CardState:
   \   00000000                      DS8 1
     57          

   \                                 In section .bss, align 1
     58          static u8  SD_u8ErrorCode;                         /* Error code */
   \                     SD_u8ErrorCode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     59          static fnCode_type SD_pfWaitReturnState;           /* The saved state to return after a wait period */
   \                     SD_pfWaitReturnState:
   \   00000000                      DS8 4
     60          //static u8* SD_NextCommand;                         /* Saved command to be executed next */
     61          

   \                                 In section .bss, align 4
     62          static SspConfigurationType SD_sSspConfig;         /* Configuration information for SSP peripheral */
   \                     SD_sSspConfig:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     63          static SspPeripheralType* SD_Ssp;                  /* Pointer to SSP peripheral object */
   \                     SD_Ssp:
   \   00000000                      DS8 4
     64          

   \                                 In section .bss, align 4
     65          static u8 SD_au8RxBuffer[SDCARD_RX_BUFFER_SIZE];   /* Space for incoming bytes from the SD card */
   \                     SD_au8RxBuffer:
   \   00000000                      DS8 548
     66          static u8 *SD_pu8RxBufferNextByte;                 /* Pointer to next spot in RxBuffer to write a byte */
                            ^
Warning[Pe177]: variable "SD_pu8RxBufferNextByte" was declared but never
          referenced
     67          //static u8 *SD_pu8RxBufferParser;                   /* Pointer to loop through the Rx buffer to read bytes */
     68          

   \                                 In section .bss, align 4
     69          static u32 SD_u32Timeout;                          /* Timeout counter used across states */
   \                     SD_u32Timeout:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     70          static u32 SD_u32CurrentMsgToken;                  /* Token of message currently being sent */
   \                     SD_u32CurrentMsgToken:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     71          static u32 SD_u32Address;                          /* Current read/write sector address */
   \                     SD_u32Address:
   \   00000000                      DS8 4
     72          
     73          static u8 SD_au8CardInMessage[]    = "SD card inserted\n\r";
                           ^
Warning[Pe177]: variable "SD_au8CardInMessage" was declared but never
          referenced

   \                                 In section .data, align 4
     74          static u8 SD_au8SspRequestFailed[] = "SdCard denied SSP\n\r";
   \                     SD_au8SspRequestFailed:
   \   00000000   0x53 0x64          DC8 "SdCard denied SSP\012\015"
   \              0x43 0x61    
   \              0x72 0x64    
   \              0x20 0x64    
   \              0x65 0x6E    
   \              0x69 0x65    
   \              0x64 0x20    
   \              0x53 0x53    
   \              0x50 0x0A    
   \              0x0D 0x00    

   \                                 In section .data, align 4
     75          static u8 SD_au8CardReady[]        = "SD ready\n\r";
   \                     SD_au8CardReady:
   \   00000000   0x53 0x44          DC8 "SD ready\012\015"
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .data, align 4
     76          static u8 SD_au8CardError[]        = "SD error: ";
   \                     SD_au8CardError:
   \   00000000   0x53 0x44          DC8 "SD error: "
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .data, align 4
     77          static u8 SD_au8CardError0[]       = "UNKNOWN\n\r";
   \                     SD_au8CardError0:
   \   00000000   0x55 0x4E          DC8 "UNKNOWN\012\015"
   \              0x4B 0x4E    
   \              0x4F 0x57    
   \              0x4E 0x0A    
   \              0x0D 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     78          static u8 SD_au8CardError1[]       = "TIMEOUT\n\r";
   \                     SD_au8CardError1:
   \   00000000   0x54 0x49          DC8 "TIMEOUT\012\015"
   \              0x4D 0x45    
   \              0x4F 0x55    
   \              0x54 0x0A    
   \              0x0D 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     79          static u8 SD_au8CardError2[]       = "CARD_VOLTAGE\n\r ";
   \                     SD_au8CardError2:
   \   00000000   0x43 0x41          DC8 "CARD_VOLTAGE\012\015 "
   \              0x52 0x44    
   \              0x5F 0x56    
   \              0x4F 0x4C    
   \              0x54 0x41    
   \              0x47 0x45    
   \              0x0A 0x0D    
   \              0x20 0x00    

   \                                 In section .data, align 4
     80          static u8 SD_au8CardError3[]       = "BAD_RESPONSE\n\r ";
   \                     SD_au8CardError3:
   \   00000000   0x42 0x41          DC8 "BAD_RESPONSE\012\015 "
   \              0x44 0x5F    
   \              0x52 0x45    
   \              0x53 0x50    
   \              0x4F 0x4E    
   \              0x53 0x45    
   \              0x0A 0x0D    
   \              0x20 0x00    

   \                                 In section .data, align 4
     81          static u8 SD_au8CardError4[]       = "NO_TOKEN\n\r";
   \                     SD_au8CardError4:
   \   00000000   0x4E 0x4F          DC8 "NO_TOKEN\012\015"
   \              0x5F 0x54    
   \              0x4F 0x4B    
   \              0x45 0x4E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .data, align 4
     82          static u8 SD_au8CardError5[]       = "NO_SD_TOKEN\n\r";
   \                     SD_au8CardError5:
   \   00000000   0x4E 0x4F          DC8 "NO_SD_TOKEN\012\015"
   \              0x5F 0x53    
   \              0x44 0x5F    
   \              0x54 0x4F    
   \              0x4B 0x45    
   \              0x4E 0x0A    
   \              0x0D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0
     83          
     84          

   \                                 In section .data, align 4
     85          static u8 SD_au8CMD0[]   = {SD_HOST_CMD | SD_CMD0,  0, 0, 0, 0, SD_CMD0_CRC};
   \                     SD_au8CMD0:
   \   00000000   0x40 0x00          DC8 64, 0, 0, 0, 0, 149, 0, 0
   \              0x00 0x00    
   \              0x00 0x95    
   \              0x00 0x00    

   \                                 In section .data, align 4
     86          static u8 SD_au8CMD8[]   = {SD_HOST_CMD | SD_CMD8,  0, 0, SD_VHS_VALUE, SD_CHECK_PATTERN, SD_CMD8_CRC};
   \                     SD_au8CMD8:
   \   00000000   0x48 0x00          DC8 72, 0, 0, 1, 170, 135, 0, 0
   \              0x00 0x01    
   \              0xAA 0x87    
   \              0x00 0x00    

   \                                 In section .data, align 4
     87          static u8 SD_au8CMD16[]  = {SD_HOST_CMD | SD_CMD16, 0, 0, 0x02, 0x00, SD_NO_CRC};
   \                     SD_au8CMD16:
   \   00000000   0x50 0x00          DC8 80, 0, 0, 2, 0, 1, 0, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x00    

   \                                 In section .data, align 4
     88          static u8 SD_au8CMD17[]  = {SD_HOST_CMD | SD_CMD17, 0, 0, 0, 0, SD_NO_CRC};
   \                     SD_au8CMD17:
   \   00000000   0x51 0x00          DC8 81, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    

   \                                 In section .data, align 4
     89          static u8 SD_au8CMD55[]  = {SD_HOST_CMD | SD_CMD55, 0, 0, 0 ,0, SD_NO_CRC};
   \                     SD_au8CMD55:
   \   00000000   0x77 0x00          DC8 119, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    

   \                                 In section .data, align 4
     90          static u8 SD_au8CMD58[]  = {SD_HOST_CMD | SD_CMD58, 0, 0, 0 ,0, SD_NO_CRC};
   \                     SD_au8CMD58:
   \   00000000   0x7A 0x00          DC8 122, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    
     91          

   \                                 In section .data, align 4
     92          static u8 SD_au8ACMD41[] = {SD_HOST_CMD | SD_ACMD41,0, 0, 0, 0, SD_NO_CRC};
   \                     SD_au8ACMD41:
   \   00000000   0x69 0x00          DC8 105, 0, 0, 0, 0, 1, 0, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0x00 0x00    
     93          
     94          
     95          /**********************************************************************************************************************
     96          Function Definitions
     97          **********************************************************************************************************************/
     98          
     99          /*--------------------------------------------------------------------------------------------------------------------*/
    100          /* Public Functions */
    101          /*--------------------------------------------------------------------------------------------------------------------*/
    102          
    103          /*----------------------------------------------------------------------------------------------------------------------
    104          Function: SdIsCardInserted
    105          
    106          Description:
    107          Updates and indicates whether or not an SD card is currently inserted.
    108          
    109          Requires:
    110            - 
    111          
    112          Promises:
    113            - Returns TRUE if card is inserted; otherwise returns FALSE 
    114            - _SD_CARD_INSERTED is updated (SET if card is in)
    115          */

   \                                 In section .text, align 2, keep-with-next
    116          bool SdIsCardInserted(void)
    117          {
    118            if( SD_CARD_INSERTED() )
   \                     SdIsCardInserted: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x400e0c3c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0740             LSLS     R0,R0,#+29
   \   00000008   0xD409             BMI.N    ??SdIsCardInserted_0
    119            {
    120              SD_u32Flags |= _SD_CARD_INSERTED;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000018   0x6008             STR      R0,[R1, #+0]
    121              return TRUE;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE00C             B.N      ??SdIsCardInserted_1
    122            }
    123            else
    124            {
    125              SD_u32Flags &= ~_SD_CARD_INSERTED;
   \                     ??SdIsCardInserted_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0840             LSRS     R0,R0,#+1
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    126              SD_CardState = SD_NO_CARD;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    127              return FALSE;
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??SdIsCardInserted_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    128            }
    129            
    130          } /* end SdIsCardInserted() */
    131          
    132          
    133          /*----------------------------------------------------------------------------------------------------------------------
    134          Function: SdGetStatus
    135          
    136          Description:
    137          Reports the current status of the SD card.
    138          
    139          SD_NO_CARD: no card is inserted.
    140          SD_CARD_ERROR: an inserted card has an error.
    141          SD_IDLE: card is ready and waiting for a read or a write to be requested.
    142          SD_READING: the card is being read and is not available for anything else 
    143          SD_DATA_READY: a sector of data has been requested from the SD card is ready for the client.
    144          SD_WRITING: the card is being written and is not available for anything else
    145          
    146          Requires:
    147            - SD_CardState up to date.
    148          
    149          Promises:
    150            - Returns SD_CardState
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          SdCardStateType SdGetStatus(void)
    153          {
    154            return SD_CardState;
   \                     SdGetStatus: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    155            
    156          } /* end SdGetStatus() */
    157          
    158          
    159          /*----------------------------------------------------------------------------------------------------------------------
    160          Function: SdReadBlock
    161          
    162          Description:
    163          Reads a block at the sector address provided.
    164          Byte-addressable cards are automatically converted appropriately so user does not have to distinguish
    165          and can always read by 512 byte block.
    166          
    167          Requires:
    168            - _SD_TYPE_SD1, _SD_TYPE_SD2, _SD_CARD_HC are correctly set/clear to indicate card type.
    169            - u32SectorAddress_ is a valid SD card address
    170          
    171          Promises:
    172            - If the card is currently SD_IDLE, initiates the read, changes card state to "SD_READING" and returns TRUE.
    173          */

   \                                 In section .text, align 2, keep-with-next
    174          bool SdReadBlock(u32 u32SectorAddress_)
    175          {
   \                     SdReadBlock: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    176            if(SD_CardState == SD_IDLE)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD116             BNE.N    ??SdReadBlock_0
    177            {
    178              /* Capture the card address of interest with adjustment for byte-accessed cards as required */
    179              SD_u32Address = u32SectorAddress_;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    180              if( !(SD_u32Flags & _SD_CARD_HC) )
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x0740             LSLS     R0,R0,#+29
   \   0000001A   0xD408             BMI.N    ??SdReadBlock_1
    181              {
    182                SD_u32Address *= 512;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF44F 0x7200      MOV      R2,#+512
   \   00000026   0x4350             MULS     R0,R2,R0
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable26_1
   \   0000002C   0x6010             STR      R0,[R2, #+0]
    183              }
    184              
    185              /* Update the card state which will trigger the start of the read sequence */
    186              SD_CardState = SD_READING;
   \                     ??SdReadBlock_1: (+1)
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable26
   \   00000034   0x7010             STRB     R0,[R2, #+0]
    187              return TRUE;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE000             B.N      ??SdReadBlock_2
    188            }
    189            
    190            return FALSE;
   \                     ??SdReadBlock_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??SdReadBlock_2: (+1)
   \   0000003C   0x4770             BX       LR               ;; return
    191            
    192          } /* end SdReadBlock() */
    193          
    194          
    195          /*----------------------------------------------------------------------------------------------------------------------
    196          Function: SdWriteBlock
    197          
    198          Description:
    199          Writes a block at the address provided.
    200          
    201          Requires:
    202            - 
    203          
    204          Promises:
    205            - 
    206          */

   \                                 In section .text, align 2, keep-with-next
    207          bool SdWriteBlock(u32 u32BlockAddress_)
    208          {
   \                     SdWriteBlock: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    209            return FALSE;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    210              
    211          } /* end SdWriteBlock() */
    212          
    213          
    214          /*----------------------------------------------------------------------------------------------------------------------
    215          Function: SdGetReadData
    216          
    217          Description:
    218          Transfers the data that was just read from the card.
    219          
    220          Requires:
    221            - pu8Destination points to the start of a 512 byte buffer where the data will be read.
    222            - The 512 bytes of data that was just read is at SD_au8RxBuffer[0] thru SD_au8RxBuffer[511] -
    223              this will set SD_CardState to SD_DATA_READY.
    224          
    225          Promises:
    226            - if SD_CardState = SD_DATA_READY, loads 512 bytes to pu8Destination_ and returns TRUE
    227            - else returns FALSE
    228          */

   \                                 In section .text, align 2, keep-with-next
    229          bool SdGetReadData(u8* pu8Destination_)
    230          {
   \                     SdGetReadData: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    231            /* To ensure data integrity, card state must be SD_DATA_READY */
    232            if(SD_CardState == SD_DATA_READY)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD112             BNE.N    ??SdGetReadData_0
    233            {
    234              SD_CardState = SD_IDLE;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable26
   \   00000012   0x7010             STRB     R0,[R2, #+0]
    235          
    236              for(u16 i = 0; i < 512; i++)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??SdGetReadData_1: (+1)
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000001C   0xDA07             BGE.N    ??SdGetReadData_2
    237              {
    238                *pu8Destination_ = SD_au8RxBuffer[i];
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable26_2
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x5C12             LDRB     R2,[R2, R0]
   \   00000026   0x700A             STRB     R2,[R1, #+0]
    239                pu8Destination_++;
   \   00000028   0x1C49             ADDS     R1,R1,#+1
    240              }
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0xE7F3             B.N      ??SdGetReadData_1
    241              
    242              return TRUE;
   \                     ??SdGetReadData_2: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE000             B.N      ??SdGetReadData_3
    243            }
    244            /* Otherwise return FALSE */
    245            else
    246            {
    247              return FALSE;
   \                     ??SdGetReadData_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??SdGetReadData_3: (+1)
   \   00000034   0x4770             BX       LR               ;; return
    248            }
    249              
    250          } /* end SdGetReadData() */
    251          
    252          
    253          /*--------------------------------------------------------------------------------------------------------------------*/
    254          /* Protected Functions */
    255          /*--------------------------------------------------------------------------------------------------------------------*/
    256          
    257          /*--------------------------------------------------------------------------------------------------------------------
    258          Function: SdCardInitialize
    259          
    260          Description:
    261          Initializes the State Machine and its variables.
    262          
    263          Requires:
    264            -
    265          
    266          Promises:
    267            - 
    268          */

   \                                 In section .text, align 2, keep-with-next
    269          void SdCardInitialize(void)
    270          {
   \                     SdCardInitialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    271          #ifdef ENABLE_SD
    272            u8 au8SdCardStartedMsg[] = "SdCard task ready\n\r";
    273          
    274            /* Reset the receive buffer to dummies for a known starting state */
    275            memset(SD_au8RxBuffer, SSP_DUMMY_BYTE, SDCARD_RX_BUFFER_SIZE);
    276          
    277            /* Initailze startup values and the command array */
    278            SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
    279          
    280            /* Configure the SSP resource to be used for the SD Card application */
    281            SD_sSspConfig.SspPeripheral      = SD_SSP;
    282            SD_sSspConfig.pCsGpioAddress     = SD_BASE_PORT;
    283            SD_sSspConfig.u32CsPin           = SD_CS_PIN;
    284            SD_sSspConfig.pu8RxBufferAddress = SD_au8RxBuffer;
    285            SD_sSspConfig.ppu8RxNextByte     = &SD_pu8RxBufferNextByte;
    286            SD_sSspConfig.u16RxBufferSize    = SDCARD_RX_BUFFER_SIZE;
    287            SD_sSspConfig.eBitOrder          = MSB_FIRST;
    288            SD_sSspConfig.eSspMode           = SPI_MASTER_MANUAL_CS;
    289            
    290            /* Always start in SdCardSM_IdleNoCard but display different message if card is already in */
    291            SD_pfStateMachine = SdCardSM_IdleNoCard;
    292            DebugPrintf(au8SdCardStartedMsg);
    293          
    294            if( SdIsCardInserted() )
    295            {
    296              DebugPrintf(SD_au8CardInMessage);
    297            }
    298          
    299            G_u32ApplicationFlags |= _APPLICATION_FLAGS_SDCARD;
    300          #else /* ENABLE_SD */
    301            u8 au8SdCardStartedMsg[] = "SdCard task disabled\n\r";
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable26_3
   \   0000000A   0x2217             MOVS     R2,#+23
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    302          
    303            G_u32ApplicationFlags |= _APPLICATION_FLAGS_SDCARD;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    304            SD_pfStateMachine = SdCardSM_Disabled;
   \   00000020   0x.... 0x....      ADR.W    R0,SdCardSM_Disabled
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000028   0x6008             STR      R0,[R1, #+0]
    305            DebugPrintf(au8SdCardStartedMsg);
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x.... 0x....      BL       DebugPrintf
    306          #endif /* ENABLE_SD */
    307          } /* end SdCardInitialize() */
   \   00000030   0xB007             ADD      SP,SP,#+28
   \   00000032   0xBD00             POP      {PC}             ;; return
    308          
    309          
    310          /*----------------------------------------------------------------------------------------------------------------------
    311          Function SdCardRunActiveState()
    312          
    313          Description:
    314          Selects and runs one iteration of the current state in the state machine.
    315          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    316          may take 1ms / n to execute.
    317          
    318          Requires:
    319            - State machine function pointer points at current state
    320          
    321          Promises:
    322            - Calls the function to pointed by the state machine function pointer
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          void SdCardRunActiveState(void)
    325          {
   \                     SdCardRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    326            SD_pfStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_5
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    327          
    328          } /* end SdCardRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    329          
    330          
    331          /*--------------------------------------------------------------------------------------------------------------------*/
    332          /* Private functions */
    333          /*--------------------------------------------------------------------------------------------------------------------*/
    334          
    335          /*--------------------------------------------------------------------------------------------------------------------
    336          Function: SdCommand
    337          
    338          Description:
    339          Queues a command and sets up the application to read the response when it arrives.
    340          
    341          Requires:
    342            - No other commands should be queued for the SSP peripheral being used.
    343            - All commands have the same size, SD_CMD_SIZE which include an extra byte which is the first
    344              read back for the response.
    345            - pau8Command_ is a pointer to the first byte of the command byte array
    346          
    347          Promises:
    348            - Requested command is queued to the SSP peripheral
    349            - SD_u32CurrentMsgToken updated with the corresponding message token
    350            - SD_u32Timeout loaded to start counting the timeout period for the command
    351            - State machine set to wait command
    352          */

   \                                 In section .text, align 2, keep-with-next
    353          void SdCommand(u8* pau8Command_)
    354          {
   \                     SdCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    355            /* Queue the transmit message with this command */
    356            SD_u32CurrentMsgToken = SspWriteData(SD_Ssp, SD_CMD_SIZE, pau8Command_);
   \   00000004   0x0022             MOVS     R2,R4
   \   00000006   0x2106             MOVS     R1,#+6
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       SspWriteData
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \   00000016   0x6008             STR      R0,[R1, #+0]
    357            if(SD_u32CurrentMsgToken)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26_7
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD010             BEQ.N    ??SdCommand_0
    358            {
    359              SspAssertCS(SD_Ssp);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x.... 0x....      BL       SspAssertCS
    360          
    361              /* Set up time-outs and next state */
    362              SD_u32Timeout = G_u32SystemTime1ms;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable26_8
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   00000036   0x6008             STR      R0,[R1, #+0]
    363              SD_pfStateMachine = SdCardSM_WaitCommand;
   \   00000038   0x.... 0x....      ADR.W    R0,SdCardSM_WaitCommand
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE008             B.N      ??SdCommand_1
    364            }
    365            else
    366            {
    367              /* We didn't get a return token, so abort */
    368              SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCommand_0: (+1)
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    369              SD_pfStateMachine = SdCardSM_Error;
   \   0000004C   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000054   0x6008             STR      R0,[R1, #+0]
    370            }
    371              
    372          } /* end SdCommand() */
   \                     ??SdCommand_1: (+1)
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    373          
    374          
    375          /*--------------------------------------------------------------------------------------------------------------------
    376          Function: CheckTimeout
    377          
    378          Description:
    379          Checks on timeout and updates the state machine if required.
    380          
    381          Requires:
    382            - State machine is running through states where timeouts are frequently checked and where the result of
    383              a timeout should be a timeout error and redirection to the error state.
    384            - u32Time_ is ms count for timeout
    385            - SD_u32Timeout is the reference time
    386          
    387          Promises:
    388            - if the timeout has occured, sets the erorr code and directs the SM to SdCardSM_Error state
    389          */

   \                                 In section .text, align 2, keep-with-next
    390          void CheckTimeout(u32 u32Time_)
    391          {
   \                     CheckTimeout: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    392            if( IsTimeUp(&SD_u32Timeout, u32Time_) )
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \   0000000A   0x.... 0x....      BL       IsTimeUp
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ.N    ??CheckTimeout_0
    393            {
    394              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    395              SD_pfStateMachine = SdCardSM_Error;
   \   0000001A   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000022   0x6008             STR      R0,[R1, #+0]
    396            }
    397          
    398          } /* end CheckTimeout() */
   \                     ??CheckTimeout_0: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    399          
    400          #if 0
    401          /*--------------------------------------------------------------------------------------------------------------------
    402          Function: AdvanceSD_pu8RxBufferParser
    403          
    404          Description:
    405          Safely advances SD_pu8RxBufferParser by the number of bytes required.
    406          
    407          Requires:
    408            - u32NumBytes_ is the number of bytes that the buffer pointer will be advanced
    409          
    410          Promises:
    411            - SD_pu8RxBufferParser moved u32NumBytes_ with wrap-around protection.
    412          */
    413          void AdvanceSD_pu8RxBufferParser(u32 u32NumBytes_)
    414          {
    415            for(u32 i = 0; i < u32NumBytes_; i++)
    416            {
    417              SD_pu8RxBufferParser++;
    418              if(SD_pu8RxBufferParser == &SD_au8RxBuffer[SDCARD_RX_BUFFER_SIZE])
    419              {
    420                SD_pu8RxBufferParser = &SD_au8RxBuffer[0];
    421              }
    422            }
    423            
    424          } /* end AdvanceSD_pu8RxBufferParser() */
    425          
    426          
    427          /*--------------------------------------------------------------------------------------------------------------------
    428          Function: FlushSdRxBuffer
    429          
    430          Description:
    431          Skips all new bytes currently in the RxBuffer.
    432          
    433          Requires:
    434            - 
    435          
    436          Promises:
    437            - SD_pu8RxBufferParser set to SD_pu8RxBufferNextByte
    438          */
    439          void FlushSdRxBuffer(void)
    440          {
    441            SD_pu8RxBufferParser = SD_pu8RxBufferNextByte;
    442            
    443          } /* end FlushSdRxBuffer() */
    444          #endif
    445          
    446          /**********************************************************************************************************************
    447          State Machine Function Definitions
    448          **********************************************************************************************************************/
    449          
    450          /*-------------------------------------------------------------------------------------------------------------------*/
    451          /* Wait for a card to be inserted */

   \                                 In section .text, align 2, keep-with-next
    452          static void SdCardSM_IdleNoCard(void)
    453          {
   \                     SdCardSM_IdleNoCard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    454          
    455            if( SdIsCardInserted() )
   \   00000002   0x.... 0x....      BL       SdIsCardInserted
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD044             BEQ.N    ??SdCardSM_IdleNoCard_0
    456            {
    457              /* Request the SSP resource to talk to the card */
    458              SD_Ssp = SspRequest(&SD_sSspConfig);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   0000000E   0x.... 0x....      BL       SspRequest
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   00000016   0x6008             STR      R0,[R1, #+0]
    459              if(SD_Ssp == NULL)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD114             BNE.N    ??SdCardSM_IdleNoCard_1
    460              {
    461                /* Go to wait state if SSP is not available */
    462                DebugPrintf(SD_au8SspRequestFailed);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable26_12
   \   00000026   0x.... 0x....      BL       DebugPrintf
    463                SD_u32Timeout = G_u32SystemTime1ms;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable26_8
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   00000034   0x6008             STR      R0,[R1, #+0]
    464                SD_pfWaitReturnState = SdCardSM_IdleNoCard;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable26_13
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    465                SD_pfStateMachine = SdCardSM_WaitSSP;
   \   00000040   0x.... 0x....      ADR.W    R0,SdCardSM_WaitSSP
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE023             B.N      ??SdCardSM_IdleNoCard_0
    466              }
    467              else
    468              {
    469                /* If card is in, set flag and then try to talk to card.  Note that the SSP peripheral will 
    470                be allocated to the SD card for this whole initialization process. */
    471                SD_u32Flags &= SD_CLEAR_CARD_TYPE_BITS;
   \                     ??SdCardSM_IdleNoCard_1: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF030 0x007C      BICS     R0,R0,#0x7C
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    472          
    473                /* CS is NOT asserted for initial dummy clocks */
    474                SspDeAssertCS(SD_Ssp);
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x.... 0x....      BL       SspDeAssertCS
    475                
    476                /* Queue up a set of dummy transfers to make sure the card is awake; */
    477                if(SspReadData(SD_Ssp, SD_WAKEUP_BYTES))
   \   00000066   0x2114             MOVS     R1,#+20
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       SspReadData
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD005             BEQ.N    ??SdCardSM_IdleNoCard_2
    478                {
    479                  SD_pfStateMachine = SdCardSM_Dummies;
   \   00000076   0x.... 0x....      ADR.W    R0,SdCardSM_Dummies
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   \   00000080   0xE008             B.N      ??SdCardSM_IdleNoCard_0
    480                }
    481                else
    482                {
    483                  /* We didn't get a return token, so abort */
    484                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_IdleNoCard_2: (+1)
   \   00000082   0x2004             MOVS     R0,#+4
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000088   0x7008             STRB     R0,[R1, #+0]
    485                  SD_pfStateMachine = SdCardSM_Error;
   \   0000008A   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000092   0x6008             STR      R0,[R1, #+0]
    486                }
    487              }
    488            }  
    489            
    490          } /* end SdCardSM_IdleNoCard() */
   \                     ??SdCardSM_IdleNoCard_0: (+1)
   \   00000094   0xBD01             POP      {R0,PC}          ;; return
    491          
    492          
    493          /*-------------------------------------------------------------------------------------------------------------------*/
    494          /* Wait for the dummies to be sent to wake up card. Data that will clock in to RxBuffer is ignored. */

   \                                 In section .text, align 4, keep-with-next
    495          static void SdCardSM_Dummies(void)
    496          {
   \                     SdCardSM_Dummies: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    497            if( SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE )
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       SspQueryReceiveStatus
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD108             BNE.N    ??SdCardSM_Dummies_0
    498            { 
    499              /* Queue CMD0 to be sent. SdCommand sets SD_pfStateMachine for the next state. */
    500              SdCommand(&SD_au8CMD0[0]);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_15
   \   00000014   0x.... 0x....      BL       SdCommand
    501              SD_pfWaitReturnState = SdCardSM_ResponseCMD0;
   \   00000018   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   00000020   0x6008             STR      R0,[R1, #+0]
    502            }
    503          } /* end SdCardSM_Dummies() */
   \                     ??SdCardSM_Dummies_0: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
    504          
    505          
    506          /*-------------------------------------------------------------------------------------------------------------------*/
    507          /* Check the response to CMD0. SD_pu8RxBufferParser is pointing to the RxBuffer where a response R1 is sitting */
    508          /* This is not a state but more a call-back after CMD0 */
    509          

   \                                 In section .text, align 4, keep-with-next
    510          static void SdCardSM_ResponseCMD0(void)
    511          {
   \                     SdCardSM_ResponseCMD0: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    512            /* CS is deasserted after CMD0 */
    513            SspDeAssertCS(SD_Ssp);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       SspDeAssertCS
    514          
    515            /* Process the received byte */
    516            if(SD_au8RxBuffer[0] == SD_STATUS_IDLE)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD109             BNE.N    ??SdCardSM_ResponseCMD0_0
    517            {
    518              /* Card is in Idle state, so issue CMD8 */
    519              SdCommand(&SD_au8CMD8[0]);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26_16
   \   0000001A   0x.... 0x....      BL       SdCommand
    520              SD_pfWaitReturnState = SdCardSM_ResponseCMD8;
   \   0000001E   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD8
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0xE008             B.N      ??SdCardSM_ResponseCMD0_1
    521            }
    522            else
    523            {
    524              /* Unexpected response, go to error */
    525              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD0_0: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    526              SD_pfStateMachine = SdCardSM_Error;
   \   00000032   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    527            }
    528            
    529            /* In any case, advance the buffer pointer */
    530            //AdvanceSD_pu8RxBufferParser(1);
    531                 
    532          } /* end SdCardSM_ResponseCMD0() */
   \                     ??SdCardSM_ResponseCMD0_1: (+1)
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    533          
    534          
    535          /*-------------------------------------------------------------------------------------------------------------------*/
    536          /* Queue a read to get the CMD8 data. */
    537          /* This is not a state but more a call-back after CMD8 */

   \                                 In section .text, align 4, keep-with-next
    538          static void SdCardSM_ResponseCMD8(void)
    539          {
   \                     SdCardSM_ResponseCMD8: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    540            /* Check the response byte (response R1) */
    541            if(SD_au8RxBuffer[0] == SD_STATUS_IDLE)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD11F             BNE.N    ??SdCardSM_ResponseCMD8_0
    542            {
    543              /* Command is good which means the card is at least SDv2 so we can read 4 more bytes of the CMD8 response. */
    544              SD_u32Flags |= _SD_TYPE_SD2;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    545              
    546              /* CS is still asserted since we are reading data */
    547              if(SspReadData(SD_Ssp, 4))
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x.... 0x....      BL       SspReadData
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD005             BEQ.N    ??SdCardSM_ResponseCMD8_1
    548              {
    549                SD_pfStateMachine = SdCardSM_ReadCMD8;
   \   0000002C   0x.... 0x....      ADR.W    R0,SdCardSM_ReadCMD8
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE01F             B.N      ??SdCardSM_ResponseCMD8_2
    550              }
    551              else
    552              {
    553                /* SSP read error - we'll just abort */
    554                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_ResponseCMD8_1: (+1)
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    555                SD_pfStateMachine = SdCardSM_Error;
   \   00000040   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE015             B.N      ??SdCardSM_ResponseCMD8_2
    556              }
    557            }
    558            /* CMD8 not supported => not SDv2 */
    559            else
    560            {
    561              /* The card does not support CMD8 so Deassert CS and go directly to ACMD41 */
    562              SD_u32Flags &= ~_SD_TYPE_SD2;
   \                     ??SdCardSM_ResponseCMD8_0: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    563              SspDeAssertCS(SD_Ssp);
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x.... 0x....      BL       SspDeAssertCS
    564              /* Do we need a delay here since CS will be asserted almost immediately in SdCommand? */
    565              
    566              SdCommand(&SD_au8ACMD41[0]);
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable26_17
   \   0000006A   0x.... 0x....      BL       SdCommand
    567              SD_pfWaitReturnState = SdCardSM_ResponseCMD55;
   \   0000006E   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD55
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   00000076   0x6008             STR      R0,[R1, #+0]
    568            }
    569              
    570            /* In either case, advance the buffer pointer */
    571            //AdvanceSD_pu8RxBufferParser(1);
    572             
    573          } /* end SdCardSM_ResponseCMD8() */
   \                     ??SdCardSM_ResponseCMD8_2: (+1)
   \   00000078   0xBD01             POP      {R0,PC}          ;; return
    574               
    575          
    576          /*-------------------------------------------------------------------------------------------------------------------*/
    577          /* Wait for the 4 payload bytes from CMD8. */

   \                                 In section .text, align 4, keep-with-next
    578          static void SdCardSM_ReadCMD8(void)
    579          {
   \                     SdCardSM_ReadCMD8: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    580            /* Check to see if the SSP peripheral has sent the data request */
    581          //  if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    582            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       SspQueryReceiveStatus
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD121             BNE.N    ??SdCardSM_ReadCMD8_0
    583            {
    584              /* CMD8 is finished so deassert CS */
    585              SspDeAssertCS(SD_Ssp);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       SspDeAssertCS
    586              
    587              /* Process the four response bytes (only the last two matter) */
    588              //SD_pu8RxBufferParser = ;
    589              if(SD_au8RxBuffer[SD_CMD8_INDEX_VHS] == SD_VHS_VALUE)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x7880             LDRB     R0,[R0, #+2]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD10E             BNE.N    ??SdCardSM_ReadCMD8_1
    590              {
    591                //AdvanceSD_pu8RxBufferParser(1);
    592                if(SD_au8RxBuffer[SD_CMD8_INDEX_CHECK] == SD_CHECK_PATTERN)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000028   0x78C0             LDRB     R0,[R0, #+3]
   \   0000002A   0x28AA             CMP      R0,#+170
   \   0000002C   0xD112             BNE.N    ??SdCardSM_ReadCMD8_0
    593                {
    594                  /* Card supports VCC 2.7 - 3.6V so we're good to go */
    595                  /* Next we need to send CMD55 so we can send ACMD41 */
    596                  SdCommand(&SD_au8CMD55[0]);
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable26_18
   \   00000032   0x.... 0x....      BL       SdCommand
    597                  SD_pfWaitReturnState = SdCardSM_ResponseCMD55;
   \   00000036   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD55
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE008             B.N      ??SdCardSM_ReadCMD8_0
    598                }
    599                //AdvanceSD_pu8RxBufferParser(1);
    600              }
    601              else
    602              {
    603                /* The card does not support the voltage range so is not usable */
    604                SD_u8ErrorCode = SD_ERROR_CARD_VOLTAGE;
   \                     ??SdCardSM_ReadCMD8_1: (+1)
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    605                SD_pfStateMachine = SdCardSM_Error;
   \   0000004A   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000052   0x6008             STR      R0,[R1, #+0]
    606              }
    607            }
    608            
    609            /* Watch for SSP timeout */
    610            CheckTimeout(SD_SPI_WAIT_TIME_MS);
   \                     ??SdCardSM_ReadCMD8_0: (+1)
   \   00000054   0xF44F 0x70FA      MOV      R0,#+500
   \   00000058   0x.... 0x....      BL       CheckTimeout
    611               
    612          } /* end SdCardSM_ReadCMD8() */
   \   0000005C   0xBD01             POP      {R0,PC}          ;; return
    613          
    614               
    615          /*-------------------------------------------------------------------------------------------------------------------*/
    616          /* Check the response to CMD55. */
    617          /* This is really a call-back to CMD55 */

   \                                 In section .text, align 4, keep-with-next
    618          static void SdCardSM_ResponseCMD55(void)
    619          {
   \                     SdCardSM_ResponseCMD55: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    620            /* CMD55 is finished so deassert CS */
    621            SspDeAssertCS(SD_Ssp);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       SspDeAssertCS
    622          
    623            /* Process the received byte from CMD55 */
    624            if(SD_au8RxBuffer[0] == SD_STATUS_IDLE)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD116             BNE.N    ??SdCardSM_ResponseCMD55_0
    625            {
    626              /* Card is ready for ACMD41 to configure Host Capacity Support (HCS) bit */
    627              if(SD_u32Flags & _SD_TYPE_SD2)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x06C0             LSLS     R0,R0,#+27
   \   0000001E   0xD507             BPL.N    ??SdCardSM_ResponseCMD55_1
    628              {
    629                SD_au8ACMD41[1] |= BIT6;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_17
   \   00000024   0x7840             LDRB     R0,[R0, #+1]
   \   00000026   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable26_17
   \   0000002E   0x7048             STRB     R0,[R1, #+1]
    630              }
    631              SdCommand(&SD_au8ACMD41[0]);
   \                     ??SdCardSM_ResponseCMD55_1: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable26_17
   \   00000034   0x.... 0x....      BL       SdCommand
    632              SD_pfWaitReturnState = SdCardSM_ResponseACMD41;
   \   00000038   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseACMD41
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE008             B.N      ??SdCardSM_ResponseCMD55_2
    633            }
    634            else
    635            {
    636              /* Unexpected response, go to error */
    637              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD55_0: (+1)
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    638              SD_pfStateMachine = SdCardSM_Error;
   \   0000004C   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000054   0x6008             STR      R0,[R1, #+0]
    639            }
    640            
    641            /* In any case, advance the buffer pointer */
    642            //AdvanceSD_pu8RxBufferParser(1);
    643                 
    644          } /* end SdCardSM_ResponseCMD55() */
   \                     ??SdCardSM_ResponseCMD55_2: (+1)
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    645               
    646               
    647          /*-------------------------------------------------------------------------------------------------------------------*/
    648          /* Check the response to ACMD41 which is waiting for the card to NOT be in idle (repeat CMD55 + ACMD41 sequence).
    649          Once the card is ready, can send CMD58.  The next step is different for version 1 and version 2 cards.  MMC will not be supported. */

   \                                 In section .text, align 4, keep-with-next
    650          static void SdCardSM_ResponseACMD41(void)
    651          {
   \                     SdCardSM_ResponseACMD41: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    652            /* ACMD41 is finished so deassert CS */
    653            SspDeAssertCS(SD_Ssp);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       SspDeAssertCS
    654          
    655            /* Process the received byte based on card type */
    656            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD120             BNE.N    ??SdCardSM_ResponseACMD41_0
    657            {
    658              /* Card is ready for next command */
    659              if(SD_u32Flags & _SD_TYPE_SD2)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x06C0             LSLS     R0,R0,#+27
   \   0000001E   0xD509             BPL.N    ??SdCardSM_ResponseACMD41_1
    660              {
    661                /* SDv2 cards use CMD58 */
    662                SdCommand(&SD_au8CMD58[0]);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_19
   \   00000024   0x.... 0x....      BL       SdCommand
    663                SD_pfWaitReturnState = SdCardSM_ResponseCMD58;
   \   00000028   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD58
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE01A             B.N      ??SdCardSM_ResponseACMD41_2
    664              }
    665              else
    666              {
    667                /* SDv1 card: set flag and block access size */
    668                SD_u32Flags |= _SD_TYPE_SD1;
   \                     ??SdCardSM_ResponseACMD41_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000042   0x6008             STR      R0,[R1, #+0]
    669                
    670                /* SDv1 cards are always low capacity, but can have variable block access.   
    671                Set to 512 to match SDv2. */
    672                SdCommand(&SD_au8CMD16[0]);
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable26_20
   \   00000048   0x.... 0x....      BL       SdCommand
    673                SD_pfWaitReturnState = SdCardSM_ResponseCMD16;
   \   0000004C   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD16
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   00000054   0x6008             STR      R0,[R1, #+0]
   \   00000056   0xE008             B.N      ??SdCardSM_ResponseACMD41_2
    674              }
    675            }
    676            else 
    677            {
    678              /* Card is not idle yet, so repeat */
    679              SdCommand(&SD_au8CMD55[0]);
   \                     ??SdCardSM_ResponseACMD41_0: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable26_18
   \   0000005C   0x.... 0x....      BL       SdCommand
    680              SD_pfWaitReturnState = SdCardSM_ResponseCMD55;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable26_21
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   00000068   0x6008             STR      R0,[R1, #+0]
    681            }
    682            
    683            /* In any case, advance the buffer pointer */
    684            //AdvanceSD_pu8RxBufferParser(1);
    685                 
    686          } /* end SdCardSM_ResponseCMD55() */     
   \                     ??SdCardSM_ResponseACMD41_2: (+1)
   \   0000006A   0xBD01             POP      {R0,PC}          ;; return
    687          
    688          
    689          /*-------------------------------------------------------------------------------------------------------------------*/
    690          /* Queue a read to get the CMD58 data. RxBuffer has R1 response byte. */

   \                                 In section .text, align 4, keep-with-next
    691          static void SdCardSM_ResponseCMD58(void)
    692          {
   \                     SdCardSM_ResponseCMD58: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    693            /* Check the response byte (response R1) */
    694            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD117             BNE.N    ??SdCardSM_ResponseCMD58_0
    695            {
    696              /* Command is good so we can read 4 more bytes of the CMD58 response */
    697              /* CS is still asserted since we are reading data */
    698              if(SspReadData(SD_Ssp, 4))
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       SspReadData
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD005             BEQ.N    ??SdCardSM_ResponseCMD58_1
    699              {
    700                SD_pfStateMachine = SdCardSM_ReadCMD58;
   \   0000001C   0x.... 0x....      ADR.W    R0,SdCardSM_ReadCMD58
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000024   0x6008             STR      R0,[R1, #+0]
   \   00000026   0xE012             B.N      ??SdCardSM_ResponseCMD58_2
    701              }
    702              else
    703              {
    704                /* SSP read error - we'll just abort */
    705                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_ResponseCMD58_1: (+1)
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    706                SD_pfStateMachine = SdCardSM_Error;
   \   00000030   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000038   0x6008             STR      R0,[R1, #+0]
   \   0000003A   0xE008             B.N      ??SdCardSM_ResponseCMD58_2
    707              }
    708            }
    709            else
    710            {
    711              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD58_0: (+1)
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    712              SD_pfStateMachine = SdCardSM_Error;
   \   00000044   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    713            }
    714              
    715            /* In either case, advance the buffer pointer */
    716            //AdvanceSD_pu8RxBufferParser(1);
    717                 
    718          } /* end SdCardSM_ResponseCMD8() */
   \                     ??SdCardSM_ResponseCMD58_2: (+1)
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
    719               
    720          
    721          /*-------------------------------------------------------------------------------------------------------------------*/
    722          /* Process response to CMD16. */
    723          /* Not a state, just a call back for CMD16 */

   \                                 In section .text, align 4, keep-with-next
    724          static void SdCardSM_ResponseCMD16(void)
    725          {
   \                     SdCardSM_ResponseCMD16: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    726            /* Check the response byte (response R1) */
    727            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD117             BNE.N    ??SdCardSM_ResponseCMD16_0
    728            {
    729              /* Success! Card is ready for read/write operations.  We can release the SSP resource for now. */
    730              SspDeAssertCS(SD_Ssp);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       SspDeAssertCS
    731              SspRelease(SD_Ssp);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       SspRelease
    732          
    733              SD_CardState = SD_IDLE;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    734              DebugPrintf(SD_au8CardReady);
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable26_22
   \   0000002C   0x.... 0x....      BL       DebugPrintf
    735          
    736              SD_pfStateMachine = SdCardSM_ReadyIdle;
   \   00000030   0x.... 0x....      ADR.W    R0,SdCardSM_ReadyIdle
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000038   0x6008             STR      R0,[R1, #+0]
   \   0000003A   0xE008             B.N      ??SdCardSM_ResponseCMD16_1
    737            }
    738            else
    739            {
    740              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD16_0: (+1)
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    741              SD_pfStateMachine = SdCardSM_Error;
   \   00000044   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    742            }
    743              
    744            /* In either case, advance the buffer pointer */
    745            //AdvanceSD_pu8RxBufferParser(1);
    746                 
    747          } /* end SdCardSM_ResponseCMD8() */
   \                     ??SdCardSM_ResponseCMD16_1: (+1)
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
    748               
    749          
    750          /*-------------------------------------------------------------------------------------------------------------------*/
    751          /* Wait for a data for CMD58. RxBuffer will have four response bytes when SSP is complete. */

   \                                 In section .text, align 4, keep-with-next
    752          static void SdCardSM_ReadCMD58(void)
    753          {
   \                     SdCardSM_ReadCMD58: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    754            /* Check to see if the SSP peripheral has sent the command */
    755          //  if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    756            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       SspQueryReceiveStatus
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD135             BNE.N    ??SdCardSM_ReadCMD58_0
    757            {
    758              /* CMD58 is finished so deassert CS */
    759              SspDeAssertCS(SD_Ssp);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       SspDeAssertCS
    760          
    761              /* Determine card capacity */
    762              SD_u32Flags &= ~_SD_CARD_HC;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000028   0x6008             STR      R0,[R1, #+0]
    763              if(SD_au8RxBuffer[0] & _SD_OCR_CCS_BIT)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x0640             LSLS     R0,R0,#+25
   \   00000032   0xD51A             BPL.N    ??SdCardSM_ReadCMD58_1
    764              {
    765                SD_u32Flags |= _SD_CARD_HC;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000042   0x6008             STR      R0,[R1, #+0]
    766                
    767                /* Success! Card is ready for read/write operations */
    768                SspRelease(SD_Ssp);
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       SspRelease
    769            
    770                SD_CardState = SD_IDLE;
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    771                DebugPrintf(SD_au8CardReady);
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable26_22
   \   0000005A   0x.... 0x....      BL       DebugPrintf
    772              
    773                SD_pfStateMachine = SdCardSM_ReadyIdle;
   \   0000005E   0x.... 0x....      ADR.W    R0,SdCardSM_ReadyIdle
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xE008             B.N      ??SdCardSM_ReadCMD58_0
    774              }
    775              /* For standard capacity, make sure block size is 512 */
    776              else
    777              {
    778                SdCommand(&SD_au8CMD16[0]);
   \                     ??SdCardSM_ReadCMD58_1: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable26_20
   \   0000006E   0x.... 0x....      BL       SdCommand
    779                SD_pfWaitReturnState = SdCardSM_ResponseCMD16;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable26_23
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable26_14
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    780              }
    781              
    782              /* Ignore the other 3 response bytes */
    783              //AdvanceSD_pu8RxBufferParser(4);
    784            }
    785            
    786            /* Watch for SSP timeout */
    787            CheckTimeout(SD_SPI_WAIT_TIME_MS);
   \                     ??SdCardSM_ReadCMD58_0: (+1)
   \   0000007C   0xF44F 0x70FA      MOV      R0,#+500
   \   00000080   0x.... 0x....      BL       CheckTimeout
    788               
    789          } /* end SdCardSM_ReadCMD58() */
   \   00000084   0xBD01             POP      {R0,PC}          ;; return
    790                     
    791          #if 0     
    792          /*-------------------------------------------------------------------------------------------------------------------*/
    793          /* Kill time waiting for the SD card to indicate it is ready after CS.
    794          SD_NextCommand is queue with the command that will be sent once
    795          the card is ready. */
    796               
    797          static void SdCardSM_WaitReady(void)
    798          {
    799            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
    800            {  
    801              if( *SD_pu8RxBufferParser != 0xFF )
    802              {
    803                if(!SspReadByte(SD_Ssp))
    804                {
    805                  /* We didn't get a return token, so abort */
    806                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
    807                  SD_pfStateMachine = SdCardSM_Error;
    808                }
    809              }
    810              /* The card is ready for the command */
    811              else
    812              {
    813                SD_u32CurrentMsgToken = SspWriteData(SD_Ssp, SD_CMD_SIZE, SD_NextCommand);
    814                
    815                /* Pre-emptively move RxBufferParser so it will point to command response */
    816                //AdvanceSD_pu8RxBufferParser(SD_CMD_SIZE);
    817              
    818                /* Set up time-outs and next state */
    819                SD_u32Timeout = G_u32SystemTime1ms;
    820                SD_pfStateMachine = SdCardSM_WaitCommand;
    821              }
    822            }
    823            
    824            /* Watch for SSP timeout */
    825            CheckTimeout(SD_SPI_WAIT_TIME_MS);
    826               
    827          } /* end SdCardSM_WaitReady() */
    828          #endif
    829          
    830          /*-------------------------------------------------------------------------------------------------------------------*/
    831          /* Kill time waiting for a command to finish sending; the first byte from all completed commands
    832          is response R1 which has BIT7 clear.
    833               
    834          REQUIRES: 
    835            - SD_u32CurrentMsgToken references the message that is being sent
    836               
    837          PROMISES: 
    838            - State machine set to either SdCardSM_WaitResponse or SdCardSM_Error
    839          */

   \                                 In section .text, align 4, keep-with-next
    840          static void SdCardSM_WaitCommand(void)
    841          {
   \                     SdCardSM_WaitCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    842            /* Check to see if the SSP peripheral has sent the command */
    843            if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       QueryMessageStatus
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD115             BNE.N    ??SdCardSM_WaitCommand_0
    844            {
    845              /* Request 1 byte (response byte from card) */  
    846              if( SspReadByte(SD_Ssp) )
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       SspReadByte
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??SdCardSM_WaitCommand_1
    847              {
    848                SD_pfStateMachine = SdCardSM_WaitResponse;
   \   0000001E   0x.... 0x....      ADR.W    R0,SdCardSM_WaitResponse
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0xE008             B.N      ??SdCardSM_WaitCommand_0
    849              }
    850              else
    851              {
    852                /* We didn't get a return token, so abort */
    853                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_WaitCommand_1: (+1)
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    854                SD_pfStateMachine = SdCardSM_Error;
   \   00000032   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    855              }
    856            }
    857          
    858            /* Monitor time out */
    859            if( IsTimeUp(&SD_u32Timeout, SD_WAIT_TIME) )
   \                     ??SdCardSM_WaitCommand_0: (+1)
   \   0000003C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable26_9
   \   00000044   0x.... 0x....      BL       IsTimeUp
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD008             BEQ.N    ??SdCardSM_WaitCommand_2
    860            {
    861              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    862              SD_pfStateMachine = SdCardSM_Error;
   \   00000054   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    863            }
    864               
    865          } /* end SdCardSM_WaitCommand() */
   \                     ??SdCardSM_WaitCommand_2: (+1)
   \   0000005E   0xBD01             POP      {R0,PC}          ;; return
    866          
    867          
    868          /*-------------------------------------------------------------------------------------------------------------------*/
    869          /* Kill time waiting for a response read to finish; the first byte from all completed commands
    870          is response R1 which has BIT7 clear.  This response will be at SD_au8RxBuffer[0].
    871               
    872          REQUIRES: 
    873            - SD_pfWaitReturnState points to the function that should be accessed next.
    874               
    875          PROMISES: 
    876            - State machine set to either SD_pfWaitReturnState or SdCardSM_Error
    877            - RxBuffer holds response byte 
    878          */

   \                                 In section .text, align 4, keep-with-next
    879          static void SdCardSM_WaitResponse(void)
    880          {
   \                     SdCardSM_WaitResponse: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    881            static u8 u8Retries = SD_CMD_RETRIES;
    882            
    883            /* Check to see if the SSP peripheral has sent the read request */
    884            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       SspQueryReceiveStatus
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD139             BNE.N    ??SdCardSM_WaitResponse_0
    885            {
    886              /* If no response but retries left, queue another read */
    887              if( (SD_au8RxBuffer[0] & BIT7) && (u8Retries != 0) )
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x0600             LSLS     R0,R0,#+24
   \   00000018   0xD52B             BPL.N    ??SdCardSM_WaitResponse_1
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_24
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD026             BEQ.N    ??SdCardSM_WaitResponse_1
    888              {
    889                u8Retries--;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable26_24
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable26_24
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    890                
    891                if(u8Retries == 0)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_24
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD109             BNE.N    ??SdCardSM_WaitResponse_2
    892                {
    893                  SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000042   0x7008             STRB     R0,[R1, #+0]
    894                  SD_pfStateMachine = SdCardSM_Error;
   \   00000044   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0xE019             B.N      ??SdCardSM_WaitResponse_0
    895                }
    896                else if( !SspReadByte(SD_Ssp) )
   \                     ??SdCardSM_WaitResponse_2: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x.... 0x....      BL       SspReadByte
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD112             BNE.N    ??SdCardSM_WaitResponse_0
    897                {
    898                  /* We didn't get a return token, so abort */
    899                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    900                  SD_pfStateMachine = SdCardSM_Error;
   \   00000066   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   \   00000070   0xE008             B.N      ??SdCardSM_WaitResponse_0
    901                }
    902              }
    903              else
    904              {
    905                /* Otherwise we have a good response, so return now */
    906                u8Retries = SD_CMD_RETRIES;
   \                     ??SdCardSM_WaitResponse_1: (+1)
   \   00000072   0x2014             MOVS     R0,#+20
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable26_24
   \   00000078   0x7008             STRB     R0,[R1, #+0]
    907                SD_pfStateMachine = SD_pfWaitReturnState;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable26_14
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x....             LDR.N    R1,??DataTable26_5
   \   00000082   0x6008             STR      R0,[R1, #+0]
    908              }
    909            }
    910          
    911            /* Monitor time out */
    912            if( IsTimeUp(&SD_u32Timeout, SD_WAIT_TIME) )
   \                     ??SdCardSM_WaitResponse_0: (+1)
   \   00000084   0xF44F 0x717A      MOV      R1,#+1000
   \   00000088   0x....             LDR.N    R0,??DataTable26_9
   \   0000008A   0x.... 0x....      BL       IsTimeUp
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00A             BEQ.N    ??SdCardSM_WaitResponse_3
    913            {
    914              u8Retries = SD_CMD_RETRIES;
   \   00000092   0x2014             MOVS     R0,#+20
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable26_24
   \   00000098   0x7008             STRB     R0,[R1, #+0]
    915              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x....             LDR.N    R1,??DataTable26_10
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
    916              SD_pfStateMachine = SdCardSM_Error;
   \   000000A0   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   000000A4   0x....             LDR.N    R1,??DataTable26_5
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    917            }
    918               
    919          } /* end SdCardSM_WaitResponse() */
   \                     ??SdCardSM_WaitResponse_3: (+1)
   \   000000A8   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .data, align 1
   \                     `SdCardSM_WaitResponse::u8Retries`:
   \   00000000   0x14               DC8 20
    920          
    921            
    922          /*-------------------------------------------------------------------------------------------------------------------*/
    923          /* Kill time before checking SSP availability again */

   \                                 In section .text, align 4, keep-with-next
    924          static void SdCardSM_WaitSSP(void)          
    925          {
   \                     SdCardSM_WaitSSP: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    926            if( IsTimeUp(&SD_u32Timeout, SD_SPI_WAIT_TIME_MS) )
   \   00000002   0xF44F 0x71FA      MOV      R1,#+500
   \   00000006   0x....             LDR.N    R0,??DataTable26_9
   \   00000008   0x.... 0x....      BL       IsTimeUp
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??SdCardSM_WaitSSP_0
    927            {
    928              SD_pfStateMachine = SD_pfWaitReturnState;
   \   00000010   0x....             LDR.N    R0,??DataTable26_14
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x....             LDR.N    R1,??DataTable26_5
   \   00000016   0x6008             STR      R0,[R1, #+0]
    929            }
    930            
    931          } /* end SdCardSM_WaitSSP() */
   \                     ??SdCardSM_WaitSSP_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    932               
    933               
    934          /*-------------------------------------------------------------------------------------------------------------------*/
    935          /* SD card is initialized: wait for action request. */

   \                                 In section .text, align 4, keep-with-next
    936          static void SdCardSM_ReadyIdle(void)          
    937          {
   \                     SdCardSM_ReadyIdle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    938            /* Check if the card is still in; if not return through WaitSSP to allow some debounce time */
    939            if( !SdIsCardInserted() )
   \   00000002   0x.... 0x....      BL       SdIsCardInserted
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD110             BNE.N    ??SdCardSM_ReadyIdle_0
    940            {
    941              SD_u32Flags &= SD_CLEAR_CARD_TYPE_BITS;
   \   0000000A   0x....             LDR.N    R0,??DataTable25_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF030 0x007C      BICS     R0,R0,#0x7C
   \   00000012   0x....             LDR.N    R1,??DataTable25_1
   \   00000014   0x6008             STR      R0,[R1, #+0]
    942              
    943              /* Exit through a wait state for effective debouncing */
    944              SD_u32Timeout = G_u32SystemTime1ms;
   \   00000016   0x....             LDR.N    R0,??DataTable26_8
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable26_9
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    945              SD_pfWaitReturnState = SdCardSM_IdleNoCard;
   \   0000001E   0x....             LDR.N    R0,??DataTable26_13
   \   00000020   0x....             LDR.N    R1,??DataTable26_14
   \   00000022   0x6008             STR      R0,[R1, #+0]
    946              SD_pfStateMachine = SdCardSM_WaitSSP;
   \   00000024   0x....             LDR.N    R0,??DataTable26_25
   \   00000026   0x....             LDR.N    R1,??DataTable26_5
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0xE043             B.N      ??SdCardSM_ReadyIdle_1
    947            }
    948            else
    949            {
    950              /* Look for a request to read or write file data */
    951              if( (SD_CardState == SD_WRITING) || (SD_CardState == SD_READING) )
   \                     ??SdCardSM_ReadyIdle_0: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable26
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2805             CMP      R0,#+5
   \   00000032   0xD003             BEQ.N    ??SdCardSM_ReadyIdle_2
   \   00000034   0x....             LDR.N    R0,??DataTable26
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD13B             BNE.N    ??SdCardSM_ReadyIdle_1
    952              {
    953                /* Request the SSP resource to talk to the card */
    954                SD_Ssp = SspRequest(&SD_sSspConfig);
   \                     ??SdCardSM_ReadyIdle_2: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable26_11
   \   0000003E   0x.... 0x....      BL       SspRequest
   \   00000042   0x....             LDR.N    R1,??DataTable26_6
   \   00000044   0x6008             STR      R0,[R1, #+0]
    955                if(SD_Ssp == NULL)
   \   00000046   0x....             LDR.N    R0,??DataTable26_6
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD10D             BNE.N    ??SdCardSM_ReadyIdle_3
    956                {
    957                  /* Go to wait state if SSP is not available */
    958                  DebugPrintf(SD_au8SspRequestFailed);
   \   0000004E   0x....             LDR.N    R0,??DataTable26_12
   \   00000050   0x.... 0x....      BL       DebugPrintf
    959                  SD_u32Timeout = G_u32SystemTime1ms;
   \   00000054   0x....             LDR.N    R0,??DataTable26_8
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x....             LDR.N    R1,??DataTable26_9
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    960                  SD_pfWaitReturnState = SdCardSM_ReadyIdle;
   \   0000005C   0x....             LDR.N    R0,??DataTable26_26
   \   0000005E   0x....             LDR.N    R1,??DataTable26_14
   \   00000060   0x6008             STR      R0,[R1, #+0]
    961                  SD_pfStateMachine = SdCardSM_WaitSSP;
   \   00000062   0x....             LDR.N    R0,??DataTable26_25
   \   00000064   0x....             LDR.N    R1,??DataTable26_5
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xE024             B.N      ??SdCardSM_ReadyIdle_1
    962                }
    963                else
    964                {
    965                  /* Got SSP, so start read or write */
    966                  if(SD_CardState == SD_WRITING)
   \                     ??SdCardSM_ReadyIdle_3: (+1)
   \   0000006A   0x....             LDR.N    R0,??DataTable26
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x2805             CMP      R0,#+5
   \   00000070   0xD106             BNE.N    ??SdCardSM_ReadyIdle_4
    967                  {
    968                    /* Not yet implemented */
    969                    SD_pfStateMachine = SdCardSM_ReadyIdle;
   \   00000072   0x....             LDR.N    R0,??DataTable26_26
   \   00000074   0x....             LDR.N    R1,??DataTable26_5
   \   00000076   0x6008             STR      R0,[R1, #+0]
    970                    SD_CardState = SD_IDLE;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x....             LDR.N    R1,??DataTable26
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
   \   0000007E   0xE019             B.N      ??SdCardSM_ReadyIdle_1
    971                  }
    972                  else
    973                  {
    974                    /* Parse out the bytes of the address into the command array */
    975                    SD_au8CMD17[1] = (u8)(SD_u32Address >> 24);
   \                     ??SdCardSM_ReadyIdle_4: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable26_1
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x0E00             LSRS     R0,R0,#+24
   \   00000086   0x....             LDR.N    R1,??DataTable26_27
   \   00000088   0x7048             STRB     R0,[R1, #+1]
    976                    SD_au8CMD17[2] = (u8)(SD_u32Address >> 16);
   \   0000008A   0x....             LDR.N    R0,??DataTable26_1
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x0C00             LSRS     R0,R0,#+16
   \   00000090   0x....             LDR.N    R1,??DataTable26_27
   \   00000092   0x7088             STRB     R0,[R1, #+2]
    977                    SD_au8CMD17[3] = (u8)(SD_u32Address >> 8);
   \   00000094   0x....             LDR.N    R0,??DataTable26_1
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x0A00             LSRS     R0,R0,#+8
   \   0000009A   0x....             LDR.N    R1,??DataTable26_27
   \   0000009C   0x70C8             STRB     R0,[R1, #+3]
    978                    SD_au8CMD17[4] = (u8)SD_u32Address;
   \   0000009E   0x....             LDR.N    R0,??DataTable26_1
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x....             LDR.N    R1,??DataTable26_27
   \   000000A4   0x7108             STRB     R0,[R1, #+4]
    979                    
    980                    SdCommand(&SD_au8CMD17[0]);
   \   000000A6   0x....             LDR.N    R0,??DataTable26_27
   \   000000A8   0x.... 0x....      BL       SdCommand
    981                    SD_pfWaitReturnState = SdCardSM_ResponseCMD17;
   \   000000AC   0x.... 0x....      ADR.W    R0,SdCardSM_ResponseCMD17
   \   000000B0   0x....             LDR.N    R1,??DataTable26_14
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    982                  }
    983                }
    984              }
    985            }
    986          } /* end SdCardSM_ReadyIdle() */
   \                     ??SdCardSM_ReadyIdle_1: (+1)
   \   000000B4   0xBD01             POP      {R0,PC}          ;; return
    987               
    988          
    989          /*-------------------------------------------------------------------------------------------------------------------*/
    990          /* Start read sequence */

   \                                 In section .text, align 4, keep-with-next
    991          static void SdCardSM_ResponseCMD17(void)
    992          {
   \                     SdCardSM_ResponseCMD17: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    993            /* Check the response byte (response R1) */
    994            if(SD_au8RxBuffer[0] == SD_STATUS_READY)
   \   00000002   0x....             LDR.N    R0,??DataTable26_2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD116             BNE.N    ??SdCardSM_ResponseCMD17_0
    995            {
    996              /* Queue a read looking to get TOKEN_START_BLOCK back from the card */
    997              //SD_u32CurrentMsgToken = SspReadByte(SD_Ssp);
    998              if(SspReadByte(SD_Ssp))
   \   0000000A   0x....             LDR.N    R0,??DataTable26_6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       SspReadByte
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD008             BEQ.N    ??SdCardSM_ResponseCMD17_1
    999              {
   1000                SD_u32Timeout = G_u32SystemTime1ms;
   \   00000016   0x....             LDR.N    R0,??DataTable26_8
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable26_9
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   1001                SD_pfStateMachine = SdCardSM_WaitStartToken;
   \   0000001E   0x.... 0x....      ADR.W    R0,SdCardSM_WaitStartToken
   \   00000022   0x....             LDR.N    R1,??DataTable26_5
   \   00000024   0x6008             STR      R0,[R1, #+0]
   \   00000026   0xE00E             B.N      ??SdCardSM_ResponseCMD17_2
   1002              }
   1003              else
   1004              {
   1005                /* SSP read error - we'll just abort */
   1006                SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_ResponseCMD17_1: (+1)
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x....             LDR.N    R1,??DataTable26_10
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1007                SD_pfStateMachine = SdCardSM_Error;
   \   0000002E   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000032   0x....             LDR.N    R1,??DataTable26_5
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE006             B.N      ??SdCardSM_ResponseCMD17_2
   1008              }
   1009            }
   1010            else
   1011            {
   1012              /* Incorrect response from the SD card, so abort */
   1013              SD_u8ErrorCode = SD_ERROR_BAD_RESPONSE;
   \                     ??SdCardSM_ResponseCMD17_0: (+1)
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable26_10
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
   1014              SD_pfStateMachine = SdCardSM_FailedDataTransfer;
   \   0000003E   0x.... 0x....      ADR.W    R0,SdCardSM_FailedDataTransfer
   \   00000042   0x....             LDR.N    R1,??DataTable26_5
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1015            }
   1016          
   1017            /* Either way, advance the RxBuffer pointer */  
   1018            //AdvanceSD_pu8RxBufferParser(1);
   1019          
   1020          } /* end SdCardSM_ResponseCMD17() */
   \                     ??SdCardSM_ResponseCMD17_2: (+1)
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
   1021          
   1022          
   1023          /*-------------------------------------------------------------------------------------------------------------------*/
   1024          /* Look for the returned token that indicates the read or write process has begun */

   \                                 In section .text, align 4, keep-with-next
   1025          static void SdCardSM_WaitStartToken(void)          
   1026          {
   \                     SdCardSM_WaitStartToken: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1027            /* Check if the SSP peripheral has sent the data request */
   1028          //  if( QueryMessageStatus(SD_u32CurrentMsgToken) == COMPLETE )
   1029            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \   00000002   0x....             LDR.N    R0,??DataTable26_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       SspQueryReceiveStatus
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD129             BNE.N    ??SdCardSM_WaitStartToken_0
   1030            {
   1031              /* Check the response byte */
   1032              if(SD_au8RxBuffer[0] == TOKEN_START_BLOCK)
   \   0000000E   0x....             LDR.N    R0,??DataTable26_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x28FE             CMP      R0,#+254
   \   00000014   0xD114             BNE.N    ??SdCardSM_WaitStartToken_1
   1033              {
   1034                /* Set the RxBuffer pointers to the start of the RxBuffer so the sector data occupies the beginning */
   1035                //SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
   1036                //SD_pu8RxBufferParser   = &SD_au8RxBuffer[0];
   1037                
   1038                /* Queue a read for the entire sector plus two checksum bytes */
   1039                /* CS is still asserted since we are reading data */
   1040                if(SspReadData(SD_Ssp, 514))
   \   00000016   0xF240 0x2102      MOVW     R1,#+514
   \   0000001A   0x....             LDR.N    R0,??DataTable26_6
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       SspReadData
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??SdCardSM_WaitStartToken_2
   1041                {
   1042                  SD_pfStateMachine = SdCardSM_DataTransfer;
   \   00000026   0x.... 0x....      ADR.W    R0,SdCardSM_DataTransfer
   \   0000002A   0x....             LDR.N    R1,??DataTable26_5
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   \   0000002E   0xE018             B.N      ??SdCardSM_WaitStartToken_0
   1043                }
   1044                else
   1045                {
   1046                  /* SSP read error - we'll just abort */
   1047                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_WaitStartToken_2: (+1)
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x....             LDR.N    R1,??DataTable26_10
   \   00000034   0x7008             STRB     R0,[R1, #+0]
   1048                  SD_pfStateMachine = SdCardSM_Error;
   \   00000036   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   0000003A   0x....             LDR.N    R1,??DataTable26_5
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   \   0000003E   0xE010             B.N      ??SdCardSM_WaitStartToken_0
   1049                }
   1050              }
   1051              else
   1052              {
   1053                /* Didn't get the start token so retry */
   1054                if(SspReadByte(SD_Ssp))
   \                     ??SdCardSM_WaitStartToken_1: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable26_6
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x.... 0x....      BL       SspReadByte
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD003             BEQ.N    ??SdCardSM_WaitStartToken_3
   1055                {
   1056                  SD_pfStateMachine = SdCardSM_WaitStartToken;
   \   0000004C   0x....             LDR.N    R0,??DataTable26_28
   \   0000004E   0x....             LDR.N    R1,??DataTable26_5
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE006             B.N      ??SdCardSM_WaitStartToken_0
   1057                }
   1058                else
   1059                {
   1060                  /* SSP read error - we'll just abort */
   1061                  SD_u8ErrorCode = SD_ERROR_NO_TOKEN;
   \                     ??SdCardSM_WaitStartToken_3: (+1)
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0x....             LDR.N    R1,??DataTable26_10
   \   00000058   0x7008             STRB     R0,[R1, #+0]
   1062                  SD_pfStateMachine = SdCardSM_Error;
   \   0000005A   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   0000005E   0x....             LDR.N    R1,??DataTable26_5
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1063                }
   1064              }
   1065            }
   1066            
   1067            /* Monitor time */
   1068            if(IsTimeUp(&SD_u32Timeout, SD_READ_TOKEN_MS))
   \                     ??SdCardSM_WaitStartToken_0: (+1)
   \   00000062   0x21C8             MOVS     R1,#+200
   \   00000064   0x....             LDR.N    R0,??DataTable26_9
   \   00000066   0x.... 0x....      BL       IsTimeUp
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD006             BEQ.N    ??SdCardSM_WaitStartToken_4
   1069            {
   1070              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x....             LDR.N    R1,??DataTable26_10
   \   00000072   0x7008             STRB     R0,[R1, #+0]
   1071              SD_pfStateMachine = SdCardSM_FailedDataTransfer;
   \   00000074   0x.... 0x....      ADR.W    R0,SdCardSM_FailedDataTransfer
   \   00000078   0x....             LDR.N    R1,??DataTable26_5
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1072            }
   1073            
   1074          } /* end SdCardSM_WaitStartToken() */
   \                     ??SdCardSM_WaitStartToken_4: (+1)
   \   0000007C   0xBD01             POP      {R0,PC}          ;; return
   1075          
   1076          
   1077          /*-------------------------------------------------------------------------------------------------------------------*/
   1078          /* Read the sector */

   \                                 In section .text, align 4, keep-with-next
   1079          static void SdCardSM_DataTransfer(void)
   1080          {
   \                     SdCardSM_DataTransfer: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1081            /* Check if the SSP peripheral is finished with the data request */
   1082            if(SspQueryReceiveStatus(SD_Ssp) == SSP_RX_COMPLETE)
   \   00000002   0x....             LDR.N    R0,??DataTable26_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       SspQueryReceiveStatus
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD10D             BNE.N    ??SdCardSM_DataTransfer_0
   1083            {
   1084              SD_CardState = SD_DATA_READY;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x....             LDR.N    R1,??DataTable26
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1085          
   1086              SspDeAssertCS(SD_Ssp);
   \   00000014   0x....             LDR.N    R0,??DataTable26_6
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       SspDeAssertCS
   1087              SspRelease(SD_Ssp);
   \   0000001C   0x....             LDR.N    R0,??DataTable26_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       SspRelease
   1088          
   1089              /* Reset the RxBuffer pointers to the start of the RxBuffer */
   1090              //SD_pu8RxBufferNextByte = &SD_au8RxBuffer[0];
   1091              //SD_pu8RxBufferParser   = &SD_au8RxBuffer[0];
   1092          
   1093              SD_pfStateMachine = SdCardSM_ReadyIdle;
   \   00000024   0x....             LDR.N    R0,??DataTable26_26
   \   00000026   0x....             LDR.N    R1,??DataTable26_5
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1094            }
   1095          
   1096            /* Monitor time */
   1097            if(IsTimeUp(&SD_u32Timeout, SD_SECTOR_READ_TIMEOUT_MS))
   \                     ??SdCardSM_DataTransfer_0: (+1)
   \   0000002A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000002E   0x....             LDR.N    R0,??DataTable26_9
   \   00000030   0x.... 0x....      BL       IsTimeUp
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??SdCardSM_DataTransfer_1
   1098            {
   1099              SD_u8ErrorCode = SD_ERROR_TIMEOUT;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x....             LDR.N    R1,??DataTable26_10
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
   1100              SD_pfStateMachine = SdCardSM_Error;
   \   0000003E   0x.... 0x....      ADR.W    R0,SdCardSM_Error
   \   00000042   0x....             LDR.N    R1,??DataTable26_5
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1101            }
   1102          
   1103          } /* end SdCardSM_DataTransfer() */
   \                     ??SdCardSM_DataTransfer_1: (+1)
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
   1104          
   1105          
   1106          /*-------------------------------------------------------------------------------------------------------------------*/
   1107          /* Handle a failed data transfer */

   \                                 In section .text, align 4, keep-with-next
   1108          static void SdCardSM_FailedDataTransfer(void)
   1109          {
   \                     SdCardSM_FailedDataTransfer: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1110            /* Reset the system variables */
   1111            SspDeAssertCS(SD_Ssp);
   \   00000002   0x....             LDR.N    R0,??DataTable26_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       SspDeAssertCS
   1112            SspRelease(SD_Ssp);
   \   0000000A   0x....             LDR.N    R0,??DataTable26_6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       SspRelease
   1113            //FlushSdRxBuffer();
   1114            SD_CardState = SD_CARD_ERROR;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable26
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   1115            
   1116            SD_u32Timeout = G_u32SystemTime1ms;
   \   00000018   0x....             LDR.N    R0,??DataTable26_8
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x....             LDR.N    R1,??DataTable26_9
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1117            SD_pfStateMachine = SdCardSM_WaitSSP;
   \   00000020   0x....             LDR.N    R0,??DataTable26_25
   \   00000022   0x....             LDR.N    R1,??DataTable26_5
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1118            
   1119          } /* end SdCardSM_FailedDataTransfer() */
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
   1120          
   1121          
   1122          /*-------------------------------------------------------------------------------------------------------------------*/
   1123          /* Handle an error */

   \                                 In section .text, align 4, keep-with-next
   1124          static void SdCardSM_Error(void)          
   1125          {
   \                     SdCardSM_Error: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1126            u8* pu8ErrorMessage;
   1127            //u8 u8MessageSize;
   1128            
   1129            /* Reset the system variables */
   1130            SspDeAssertCS(SD_Ssp);
   \   00000002   0x....             LDR.N    R0,??DataTable26_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       SspDeAssertCS
   1131            SspRelease(SD_Ssp);
   \   0000000A   0x....             LDR.N    R0,??DataTable26_6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       SspRelease
   1132            //FlushSdRxBuffer();
   1133          
   1134            /* Indicate error and return through the SSP delay state to give the system some recovery time */
   1135            DebugPrintf(SD_au8CardError);
   \   00000012   0x....             LDR.N    R0,??DataTable26_29
   \   00000014   0x.... 0x....      BL       DebugPrintf
   1136            switch (SD_u8ErrorCode)
   \   00000018   0x....             LDR.N    R0,??DataTable26_10
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD007             BEQ.N    ??SdCardSM_Error_0
   \   00000020   0xD315             BCC.N    ??SdCardSM_Error_1
   \   00000022   0x2803             CMP      R0,#+3
   \   00000024   0xD00A             BEQ.N    ??SdCardSM_Error_2
   \   00000026   0xD306             BCC.N    ??SdCardSM_Error_3
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD00D             BEQ.N    ??SdCardSM_Error_4
   \   0000002C   0xD309             BCC.N    ??SdCardSM_Error_5
   \   0000002E   0xE00E             B.N      ??SdCardSM_Error_1
   1137            {
   1138              case SD_ERROR_TIMEOUT:
   1139              {
   1140                //u8MessageSize = sizeof(SD_au8CardError1) - 1;
   1141                pu8ErrorMessage = SD_au8CardError1;
   \                     ??SdCardSM_Error_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable26_30
   \   00000032   0x0004             MOVS     R4,R0
   1142                break;
   \   00000034   0xE00D             B.N      ??SdCardSM_Error_6
   1143              }
   1144              
   1145              case SD_ERROR_CARD_VOLTAGE:
   1146              {
   1147                //u8MessageSize = sizeof(SD_au8CardError2) - 1;
   1148                pu8ErrorMessage = SD_au8CardError2;
   \                     ??SdCardSM_Error_3: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable26_31
   \   00000038   0x0004             MOVS     R4,R0
   1149                break;
   \   0000003A   0xE00A             B.N      ??SdCardSM_Error_6
   1150              }
   1151          
   1152              case SD_ERROR_BAD_RESPONSE:
   1153              {
   1154                //u8MessageSize = sizeof(SD_au8CardError3) - 1;
   1155                pu8ErrorMessage = SD_au8CardError3;
   \                     ??SdCardSM_Error_2: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable26_32
   \   0000003E   0x0004             MOVS     R4,R0
   1156                break;
   \   00000040   0xE007             B.N      ??SdCardSM_Error_6
   1157              }
   1158          
   1159              case SD_ERROR_NO_TOKEN:
   1160              {
   1161                //u8MessageSize = sizeof(SD_au8CardError4) - 1;
   1162                pu8ErrorMessage = SD_au8CardError4;
   \                     ??SdCardSM_Error_5: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable26_33
   \   00000044   0x0004             MOVS     R4,R0
   1163                break;
   \   00000046   0xE004             B.N      ??SdCardSM_Error_6
   1164              }
   1165          
   1166              case SD_ERROR_NO_SD_TOKEN:
   1167              {
   1168                //u8MessageSize = sizeof(SD_au8CardError5) - 1;
   1169                pu8ErrorMessage = SD_au8CardError5;
   \                     ??SdCardSM_Error_4: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable26_34
   \   0000004A   0x0004             MOVS     R4,R0
   1170                break;
   \   0000004C   0xE001             B.N      ??SdCardSM_Error_6
   1171              }
   1172              
   1173             default:
   1174             {
   1175              //u8MessageSize = sizeof(SD_au8CardError0) - 1;
   1176              pu8ErrorMessage = SD_au8CardError0;
   \                     ??SdCardSM_Error_1: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable26_35
   \   00000050   0x0004             MOVS     R4,R0
   1177              break;
   1178            }
   1179             
   1180            } /* end switch */
   1181            
   1182            DebugPrintf(pu8ErrorMessage);
   \                     ??SdCardSM_Error_6: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       DebugPrintf
   1183            
   1184            SD_CardState = SD_NO_CARD;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR.N    R1,??DataTable26
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
   1185            SD_u32Timeout = G_u32SystemTime1ms;
   \   0000005E   0x....             LDR.N    R0,??DataTable26_8
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x....             LDR.N    R1,??DataTable26_9
   \   00000064   0x6008             STR      R0,[R1, #+0]
   1186            SD_pfWaitReturnState = SdCardSM_IdleNoCard;
   \   00000066   0x....             LDR.N    R0,??DataTable26_13
   \   00000068   0x....             LDR.N    R1,??DataTable26_14
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   1187            SD_pfStateMachine = SdCardSM_WaitSSP;
   \   0000006C   0x....             LDR.N    R0,??DataTable26_25
   \   0000006E   0x....             LDR.N    R1,??DataTable26_5
   \   00000070   0x6008             STR      R0,[R1, #+0]
   1188            
   1189          } /* end SdCardSM_Error() */
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
   1190          
   1191          
   1192          #ifndef ENABLE_SD 
   1193          /*-------------------------------------------------------------------------------------------------------------------*/
   1194          /* SD card disbled state */

   \                                 In section .text, align 4, keep-with-next
   1195          static void SdCardSM_Disabled(void)
   1196          {
   1197            
   1198          } /* end SdCardSM_Disabled */
   \                     SdCardSM_Disabled: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x400E0C3C         DC32     0x400e0c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     SD_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     SD_CardState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     SD_u32Address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     SD_au8RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x........         DC32     SD_pfStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x........         DC32     SD_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \   00000000   0x........         DC32     SD_u32CurrentMsgToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_9:
   \   00000000   0x........         DC32     SD_u32Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_10:
   \   00000000   0x........         DC32     SD_u8ErrorCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_11:
   \   00000000   0x........         DC32     SD_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_12:
   \   00000000   0x........         DC32     SD_au8SspRequestFailed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_13:
   \   00000000   0x........         DC32     SdCardSM_IdleNoCard

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_14:
   \   00000000   0x........         DC32     SD_pfWaitReturnState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_15:
   \   00000000   0x........         DC32     SD_au8CMD0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_16:
   \   00000000   0x........         DC32     SD_au8CMD8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_17:
   \   00000000   0x........         DC32     SD_au8ACMD41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_18:
   \   00000000   0x........         DC32     SD_au8CMD55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_19:
   \   00000000   0x........         DC32     SD_au8CMD58

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_20:
   \   00000000   0x........         DC32     SD_au8CMD16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_21:
   \   00000000   0x........         DC32     SdCardSM_ResponseCMD55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_22:
   \   00000000   0x........         DC32     SD_au8CardReady

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_23:
   \   00000000   0x........         DC32     SdCardSM_ResponseCMD16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_24:
   \   00000000   0x........         DC32     `SdCardSM_WaitResponse::u8Retries`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_25:
   \   00000000   0x........         DC32     SdCardSM_WaitSSP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_26:
   \   00000000   0x........         DC32     SdCardSM_ReadyIdle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_27:
   \   00000000   0x........         DC32     SD_au8CMD17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_28:
   \   00000000   0x........         DC32     SdCardSM_WaitStartToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_29:
   \   00000000   0x........         DC32     SD_au8CardError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_30:
   \   00000000   0x........         DC32     SD_au8CardError1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_31:
   \   00000000   0x........         DC32     SD_au8CardError2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_32:
   \   00000000   0x........         DC32     SD_au8CardError3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_33:
   \   00000000   0x........         DC32     SD_au8CardError4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_34:
   \   00000000   0x........         DC32     SD_au8CardError5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_35:
   \   00000000   0x........         DC32     SD_au8CardError0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x53 0x64          DC8 "SdCard task disabled\012\015"
   \              0x43 0x61    
   \              0x72 0x64    
   \              0x20 0x74    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x64 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000017   0x00               DC8 0
   1199          #endif /* ENABLE_SD */
   1200          
   1201          
   1202          
   1203          /*--------------------------------------------------------------------------------------------------------------------*/
   1204          /* End of File */
   1205          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CheckTimeout
         8   -> IsTimeUp
      32   SdCardInitialize
        32   -> DebugPrintf
        32   -> __aeabi_memcpy
       8   SdCardRunActiveState
         8   -- Indirect call
       8   SdCardSM_DataTransfer
         8   -> IsTimeUp
         8   -> SspDeAssertCS
         8   -> SspQueryReceiveStatus
         8   -> SspRelease
       0   SdCardSM_Disabled
       8   SdCardSM_Dummies
         8   -> SdCommand
         8   -> SspQueryReceiveStatus
       8   SdCardSM_Error
         8   -> DebugPrintf
         8   -> SspDeAssertCS
         8   -> SspRelease
       8   SdCardSM_FailedDataTransfer
         8   -> SspDeAssertCS
         8   -> SspRelease
       8   SdCardSM_IdleNoCard
         8   -> DebugPrintf
         8   -> SdIsCardInserted
         8   -> SspDeAssertCS
         8   -> SspReadData
         8   -> SspRequest
       8   SdCardSM_ReadCMD58
         8   -> CheckTimeout
         8   -> DebugPrintf
         8   -> SdCommand
         8   -> SspDeAssertCS
         8   -> SspQueryReceiveStatus
         8   -> SspRelease
       8   SdCardSM_ReadCMD8
         8   -> CheckTimeout
         8   -> SdCommand
         8   -> SspDeAssertCS
         8   -> SspQueryReceiveStatus
       8   SdCardSM_ReadyIdle
         8   -> DebugPrintf
         8   -> SdCommand
         8   -> SdIsCardInserted
         8   -> SspRequest
       8   SdCardSM_ResponseACMD41
         8   -> SdCommand
         8   -> SspDeAssertCS
       8   SdCardSM_ResponseCMD0
         8   -> SdCommand
         8   -> SspDeAssertCS
       8   SdCardSM_ResponseCMD16
         8   -> DebugPrintf
         8   -> SspDeAssertCS
         8   -> SspRelease
       8   SdCardSM_ResponseCMD17
         8   -> SspReadByte
       8   SdCardSM_ResponseCMD55
         8   -> SdCommand
         8   -> SspDeAssertCS
       8   SdCardSM_ResponseCMD58
         8   -> SspReadData
       8   SdCardSM_ResponseCMD8
         8   -> SdCommand
         8   -> SspDeAssertCS
         8   -> SspReadData
       8   SdCardSM_WaitCommand
         8   -> IsTimeUp
         8   -> QueryMessageStatus
         8   -> SspReadByte
       8   SdCardSM_WaitResponse
         8   -> IsTimeUp
         8   -> SspQueryReceiveStatus
         8   -> SspReadByte
       8   SdCardSM_WaitSSP
         8   -> IsTimeUp
       8   SdCardSM_WaitStartToken
         8   -> IsTimeUp
         8   -> SspQueryReceiveStatus
         8   -> SspReadByte
         8   -> SspReadData
       8   SdCommand
         8   -> SspAssertCS
         8   -> SspWriteData
       0   SdGetReadData
       0   SdGetStatus
       0   SdIsCardInserted
       0   SdReadBlock
       0   SdWriteBlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_12
       4  ??DataTable26_13
       4  ??DataTable26_14
       4  ??DataTable26_15
       4  ??DataTable26_16
       4  ??DataTable26_17
       4  ??DataTable26_18
       4  ??DataTable26_19
       4  ??DataTable26_2
       4  ??DataTable26_20
       4  ??DataTable26_21
       4  ??DataTable26_22
       4  ??DataTable26_23
       4  ??DataTable26_24
       4  ??DataTable26_25
       4  ??DataTable26_26
       4  ??DataTable26_27
       4  ??DataTable26_28
       4  ??DataTable26_29
       4  ??DataTable26_3
       4  ??DataTable26_30
       4  ??DataTable26_31
       4  ??DataTable26_32
       4  ??DataTable26_33
       4  ??DataTable26_34
       4  ??DataTable26_35
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
      24  ?_0
      38  CheckTimeout
       4  G_u32SdCardFlags
       1  SD_CardState
       4  SD_Ssp
       8  SD_au8ACMD41
       8  SD_au8CMD0
       8  SD_au8CMD16
       8  SD_au8CMD17
       8  SD_au8CMD55
       8  SD_au8CMD58
       8  SD_au8CMD8
      12  SD_au8CardError
      12  SD_au8CardError0
      12  SD_au8CardError1
      16  SD_au8CardError2
      16  SD_au8CardError3
      12  SD_au8CardError4
      16  SD_au8CardError5
      12  SD_au8CardReady
     548  SD_au8RxBuffer
      20  SD_au8SspRequestFailed
       4  SD_pfStateMachine
       4  SD_pfWaitReturnState
      36  SD_sSspConfig
       4  SD_u32Address
       4  SD_u32CurrentMsgToken
       4  SD_u32Flags
       4  SD_u32Timeout
       1  SD_u8ErrorCode
      52  SdCardInitialize
      12  SdCardRunActiveState
      72  SdCardSM_DataTransfer
       2  SdCardSM_Disabled
      36  SdCardSM_Dummies
     116  SdCardSM_Error
      40  SdCardSM_FailedDataTransfer
     150  SdCardSM_IdleNoCard
     134  SdCardSM_ReadCMD58
      94  SdCardSM_ReadCMD8
     182  SdCardSM_ReadyIdle
     108  SdCardSM_ResponseACMD41
      62  SdCardSM_ResponseCMD0
      80  SdCardSM_ResponseCMD16
      72  SdCardSM_ResponseCMD17
      88  SdCardSM_ResponseCMD55
      80  SdCardSM_ResponseCMD58
     122  SdCardSM_ResponseCMD8
      96  SdCardSM_WaitCommand
     170  SdCardSM_WaitResponse
      26  SdCardSM_WaitSSP
     126  SdCardSM_WaitStartToken
      88  SdCommand
      54  SdGetReadData
       8  SdGetStatus
      58  SdIsCardInserted
      62  SdReadBlock
       6  SdWriteBlock
       1  u8Retries

 
   618 bytes in section .bss
   185 bytes in section .data
    24 bytes in section .rodata
 2 386 bytes in section .text
 
 2 386 bytes of CODE  memory
    24 bytes of CONST memory
   803 bytes of DATA  memory

Errors: none
Warnings: 2
