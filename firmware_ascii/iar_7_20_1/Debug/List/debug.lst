###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       26/Jun/2018  22:49:19
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\application\debug.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\application\debug.c" -D
#        EIE1 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List" -o
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\debug.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\debug.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\application\debug.c
      1          /***********************************************************************************************************************
      2          File: debug.c                                                                
      3          
      4          Description:
      5          Debugging functions and state machine.  Since the system is small, debugger commands
      6          will be strictly numerical, though each command will have a string name that can
      7          be requested by the user.  The debugger will print a list of these commands if 
      8          requested using en+c00.  Commands range from 01 to 99 (must include the leading 0
      9          for single-digit commands) and all commands must have the prefix en+c. 
     10          The current command list can be quickly checked in debug_x.h (where x is application-specific)
     11          
     12          This application requires a UART resource for input/output data.
     13          
     14          The terminal program used to interface to the debugger should be set to:
     15          - no local echo
     16          - send "CR" for new line
     17          - 115200-8-N-1
     18          
     19          
     20          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     21          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     22          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     23          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     24          
     25          ------------------------------------------------------------------------------------------------------------------------
     26          API:
     27          Types: none
     28          
     29          Globals:
     30          G_au8DebugScanfBuffer[] is the DebugScanf() input buffer that can be read directly
     31          G_u8DebugScanfCharCount holds number of characters in Debug_au8ScanfBuffer
     32          Both of these variables are cleared whenever DebugScanf() is called.
     33          
     34          Constants:
     35          DEBUG_SCANF_BUFFER_SIZE is the size of G_au8DebugScanfBuffer and thus the max of G_u8DebugScanfCharCount
     36          
     37          Public:
     38          u32 DebugPrintf(u8* u8String_)
     39          Queues the string pointed to by u8String_ to the Debug port.  The string must be
     40          null-terminated.  It may also contain control charactesr like newline (\n) and line feed (\f)
     41          e.g.
     42          u8 u8String[] = "A string to print.\n\r"
     43          DebugPrintf(u8String);
     44          
     45          void DebugLineFeed(void)
     46          Queues a <CR><LF> sequence to the debug UART.
     47          e.g.
     48          DebugLineFeed();
     49          
     50          void DebugPrintNumber(u32 u32Number_)
     51          Formats a long into an ASCII string and queues to print.  Leading zeros are not printed.
     52          e.g.
     53          u32 u32Number = 1234567;
     54          DebugPrintNumber(u32Number);
     55          
     56          u8 DebugScanf(u8* au8Buffer_)
     57          Copies the current input buffer to au8Buffer_ and returns the number of new characters.
     58          Everytime DebugScanf is called, the 
     59          e.g.
     60          u8 u8MyBuffer[SCANF_BUFFER_SIZE]
     61          u8 u8NumChars;
     62          u8NumChars = DebugScanf(u8MyBuffer);
     63          
     64          
     65          void DebugSetPassthrough(void)
     66          Puts the Debug task in Passthrough mode so ALL characters received are put in to the Scanf buffer and
     67          the Debug task does not look for input for the menu system. 
     68          
     69          
     70          void DebugClearPassthrough(void)
     71          Takes the Debug task out of Passthrough mode.
     72          
     73          
     74          ***********************************************************************************************************************/
     75          
     76          #include "configuration.h"
     77          
     78          /***********************************************************************************************************************
     79          Global variable definitions with scope across entire project.
     80          All Global variable names shall start with "G_Debug"
     81          ***********************************************************************************************************************/
     82          /* New variables */

   \                                 In section .bss, align 4
     83          u32 G_u32DebugFlags;                                     /* Debug flag register */
   \                     G_u32DebugFlags:
   \   00000000                      DS8 4
     84          

   \                                 In section .bss, align 4
     85          u8 G_au8DebugScanfBuffer[DEBUG_SCANF_BUFFER_SIZE]; /* Space to latch characters for DebugScanf() */
   \                     G_au8DebugScanfBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 1
     86          u8 G_u8DebugScanfCharCount = 0;                    /* Counter for # of characters in Debug_au8ScanfBuffer */
   \                     G_u8DebugScanfCharCount:
   \   00000000                      DS8 1
     87          
     88          
     89          /*--------------------------------------------------------------------------------------------------------------------*/
     90          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     91          extern volatile u32 G_u32SystemFlags;                    /* From main.c */
     92          extern volatile u32 G_u32ApplicationFlags;               /* From main.c */
     93          
     94          extern volatile u32 G_u32SystemTime1ms;                  /* From board-specific source file */
     95          extern volatile u32 G_u32SystemTime1s;                   /* From board-specific source file */
     96          
     97          extern u8 G_au8MessageOK[];                              /* From utilities.c */
     98          extern u8 G_au8MessageFAIL[];                            /* From utilities.c */
     99          extern u8 G_au8MessageON[];                              /* From utilities.c */
    100          extern u8 G_au8MessageOFF[];                             /* From utilities.c */
    101          
    102          
    103          /***********************************************************************************************************************
    104          Global variable definitions with scope limited to this local application.
    105          Variable names shall start with "Debug_" and be declared as static.
    106          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    107          static fnCode_type Debug_pfnStateMachine;                /* The Debug state machine function pointer */
   \                     Debug_pfnStateMachine:
   \   00000000                      DS8 4
    108          

   \                                 In section .bss, align 4
    109          static UartPeripheralType* Debug_Uart;                   /* Pointer to debug UART peripheral object */
   \                     Debug_Uart:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    110          static u32 Debug_u32CurrentMessageToken;                 /* Token for current message */
   \                     Debug_u32CurrentMessageToken:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    111          static u8 Debug_u8ErrorCode;                             /* Error code */
   \                     Debug_u8ErrorCode:
   \   00000000                      DS8 1
    112          

   \                                 In section .bss, align 4
    113          static u8 Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE];       /* Space for incoming characters of debug commands */
   \                     Debug_au8RxBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
    114          static u8 *Debug_pu8RxBufferNextChar;                    /* Pointer to next spot in the Rxbuffer */
   \                     Debug_pu8RxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    115          static u8 *Debug_pu8RxBufferParser;                      /* Pointer to loop through the Rx buffer */
   \                     Debug_pu8RxBufferParser:
   \   00000000                      DS8 4
    116          

   \                                 In section .bss, align 4
    117          static u8 Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]; /* Space to store chars as they build up to the next command */ 
   \                     Debug_au8CommandBuffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
    118          static u8 *Debug_pu8CmdBufferNextChar;                   /* Pointer to incoming char location in the command buffer */
   \                     Debug_pu8CmdBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    119          static u16 Debug_u16CommandSize;                         /* Number of characters in the command buffer */
   \                     Debug_u16CommandSize:
   \   00000000                      DS8 2
    120          

   \                                 In section .bss, align 1
    121          static u8 Debug_u8Command;                               /* A validated command number */
   \                     Debug_u8Command:
   \   00000000                      DS8 1
    122          
    123          /* Add commands by updating debug.h in the Command-Specific Definitions section, then update this list
    124          with the function name to call for the corresponding command: */
    125          #ifdef EIE1

   \                                 In section .data, align 4
    126          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
   \                     Debug_au8Commands:
   \   00000000   0x........         DC32 ?_0, DebugCommandPrepareList, ?_1, DebugCommandLedTestToggle, ?_2
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 DebugCommandSysTimeToggle, ?_3, DebugCommandDummy, ?_4
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 DebugCommandDummy, ?_5, DebugCommandDummy, ?_6, DebugCommandDummy
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000038   0x........         DC32 ?_7, DebugCommandDummy
   \              0x........   
    127                                                                 {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    128                                                                 {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    129                                                                 {DEBUG_CMD_NAME03, DebugCommandDummy},
    130                                                                 {DEBUG_CMD_NAME04, DebugCommandDummy},
    131                                                                 {DEBUG_CMD_NAME05, DebugCommandDummy},
    132                                                                 {DEBUG_CMD_NAME06, DebugCommandDummy},
    133                                                                 {DEBUG_CMD_NAME07, DebugCommandDummy} 
    134                                                               };
    135          

   \                                 In section .data, align 4
    136          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 ASCII LCD DEVELOPMENT BOARD ***\n\rDebug ready\n\r";
   \                     Debug_au8StartupMsg:
   \   00000000   0x0A 0x0A          DC8 0AH, 0AH, 0DH, 2AH, 2AH, 2AH, 20H, 52H
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x20 0x52    
   \   00000008   0x41 0x5A          DC8 41H, 5AH, 4FH, 52H, 20H, 53H, 41H, 4DH
   \              0x4F 0x52    
   \              0x20 0x53    
   \              0x41 0x4D    
   \   00000010   0x33 0x55          DC8 33H, 55H, 32H, 20H, 41H, 53H, 43H, 49H
   \              0x32 0x20    
   \              0x41 0x53    
   \              0x43 0x49    
   \   00000018   0x49 0x20          DC8 49H, 20H, 4CH, 43H, 44H, 20H, 44H, 45H
   \              0x4C 0x43    
   \              0x44 0x20    
   \              0x44 0x45    
   \   00000020   0x56 0x45          DC8 56H, 45H, 4CH, 4FH, 50H, 4DH, 45H, 4EH
   \              0x4C 0x4F    
   \              0x50 0x4D    
   \              0x45 0x4E    
   \   00000028   0x54 0x20          DC8 54H, 20H, 42H, 4FH, 41H, 52H, 44H, 20H
   \              0x42 0x4F    
   \              0x41 0x52    
   \              0x44 0x20    
   \   00000030   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 0AH, 0DH, 44H, 65H, 62H
   \              0x2A 0x0A    
   \              0x0D 0x44    
   \              0x65 0x62    
   \   00000038   0x75 0x67          DC8 75H, 67H, 20H, 72H, 65H, 61H, 64H, 79H
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \   00000040   0x0A 0x0D          DC8 0AH, 0DH, 0
   \              0x00         
   \   00000043   0x00               DC8 0
    137          #endif /* EIE1 */
    138          
    139          #ifdef MPGL2
    140          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
    141                                                                 {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    142                                                                 {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    143                                                                 {DEBUG_CMD_NAME03, DebugCommandCaptouchValuesToggle},
    144                                                                 {DEBUG_CMD_NAME04, DebugCommandDummy},
    145                                                                 {DEBUG_CMD_NAME05, DebugCommandDummy},
    146                                                                 {DEBUG_CMD_NAME06, DebugCommandDummy},
    147                                                                 {DEBUG_CMD_NAME07, DebugCommandDummy} 
    148                                                               };
    149          
    150          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 DOT MATRIX DEVELOPMENT BOARD ***\n\rDebug ready\n\r";
    151          #endif /* MPGL2 */
    152          
    153          
    154          /***********************************************************************************************************************
    155          * Function Definitions
    156          ***********************************************************************************************************************/
    157          
    158          /*--------------------------------------------------------------------------------------------------------------------*/
    159          /* Public Functions */
    160          /*--------------------------------------------------------------------------------------------------------------------*/
    161          
    162          /*----------------------------------------------------------------------------------------------------------------------
    163          Function: DebugPrintf
    164          
    165          Description:
    166          Sends a text string to the debug UART.
    167          
    168          Requires:
    169            - u8String_ is a NULL-terminated C-string
    170            - The debug UART resource has been setup for the debug application.
    171          
    172          Promises:
    173            - The string is queued to the debug UART.
    174            - The message token is returned
    175          */

   \                                 In section .text, align 2, keep-with-next
    176          u32 DebugPrintf(u8* u8String_)
    177          {
   \                     DebugPrintf: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    178            u8* pu8Parser = u8String_;
   \   00000004   0x0025             MOVS     R5,R4
    179            u32 u32Size = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    180            
    181            while(*pu8Parser != NULL)
   \                     ??DebugPrintf_0: (+1)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??DebugPrintf_1
    182            {
    183              u32Size++;
   \   0000000E   0x1C76             ADDS     R6,R6,#+1
    184              pu8Parser++;
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \   00000012   0xE7F9             B.N      ??DebugPrintf_0
    185            }
    186            return( UartWriteData(Debug_Uart, u32Size, u8String_) );
   \                     ??DebugPrintf_1: (+1)
   \   00000014   0x0022             MOVS     R2,R4
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       UartWriteData
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    187           
    188          } /* end DebugPrintf() */
    189          
    190          
    191          /*----------------------------------------------------------------------------------------------------------------------
    192          Function: DebugLineFeed
    193          
    194          Description:
    195          Queues a <CR><LF> sequence to the debug UART.
    196          
    197          Requires:
    198            -
    199          
    200          Promises:
    201            - <CR><LF> sequence to the debug UART
    202          */

   \                                 In section .text, align 2, keep-with-next
    203          void DebugLineFeed(void)
    204          {
   \                     DebugLineFeed: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    205            u8 au8Linefeed[] = {ASCII_LINEFEED, ASCII_CARRIAGE_RETURN};
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    206            
    207            UartWriteData(Debug_Uart, sizeof(au8Linefeed), &au8Linefeed[0]);
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       UartWriteData
    208          
    209          } /* end DebugLineFeed() */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    210          
    211          
    212          /*-----------------------------------------------------------------------------/
    213          Function: DebugPrintNumber
    214          
    215          Description:
    216          Formats a long into an ASCII string and queues to print
    217          
    218          Requires:
    219            - Enough space is available on the heap to temporarily store the number array
    220          
    221          Promises:
    222            - The number is converted to an array of ascii without leading zeros and sent to UART
    223          */

   \                                 In section .text, align 2, keep-with-next
    224          void DebugPrintNumber(u32 u32Number_)
    225          {
   \                     DebugPrintNumber: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    226            bool bFoundDigit = FALSE;
   \   00000006   0x2500             MOVS     R5,#+0
    227            u8 au8AsciiNumber[10];
    228            u8 u8CharCount = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    229            u32 u32Temp, u32Divider = 1000000000;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable17_2  ;; 0x3b9aca00
    230            u8 *pu8Data;
    231          
    232            /* Parse out all the digits, start counting after leading zeros */
    233            for(u8 index = 0; index < 10; index++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??DebugPrintNumber_0: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x280A             CMP      R0,#+10
   \   00000014   0xDA19             BGE.N    ??DebugPrintNumber_1
    234            {
    235              au8AsciiNumber[index] = (u32Number_ / u32Divider) + 0x30;
   \   00000016   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000001A   0x3130             ADDS     R1,R1,#+48
   \   0000001C   0x466A             MOV      R2,SP
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x5411             STRB     R1,[R2, R0]
    236              if(au8AsciiNumber[index] != '0')
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x5C09             LDRB     R1,[R1, R0]
   \   00000028   0x2930             CMP      R1,#+48
   \   0000002A   0xD001             BEQ.N    ??DebugPrintNumber_2
    237              {
    238                bFoundDigit = TRUE;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x000D             MOVS     R5,R1
    239              }
    240              if(bFoundDigit)
   \                     ??DebugPrintNumber_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD000             BEQ.N    ??DebugPrintNumber_3
    241              {
    242                u8CharCount++;
   \   00000036   0x1C76             ADDS     R6,R6,#+1
    243              }
    244              u32Number_ %= u32Divider;
   \                     ??DebugPrintNumber_3: (+1)
   \   00000038   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000003C   0xFB08 0x4411      MLS      R4,R8,R1,R4
    245              u32Divider /= 10;
   \   00000040   0x210A             MOVS     R1,#+10
   \   00000042   0xFBB8 0xF8F1      UDIV     R8,R8,R1
    246            }
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xE7E2             B.N      ??DebugPrintNumber_0
    247            
    248            /* Handle special case where u32Number == 0 */
    249            if(!bFoundDigit)
   \                     ??DebugPrintNumber_1: (+1)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD101             BNE.N    ??DebugPrintNumber_4
    250            {
    251              u8CharCount = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0006             MOVS     R6,R0
    252            }
    253            
    254            /* Allocate memory for the right number and copy the array */
    255            pu8Data = malloc(u8CharCount);
   \                     ??DebugPrintNumber_4: (+1)
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x.... 0x....      BL       malloc
   \   0000005C   0x4681             MOV      R9,R0
    256            if (pu8Data == NULL)
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD108             BNE.N    ??DebugPrintNumber_5
    257            {
    258              Debug_u8ErrorCode = DEBUG_ERROR_MALLOC;
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    259              Debug_pfnStateMachine = DebugSM_Error;
   \   0000006C   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000074   0x6008             STR      R0,[R1, #+0]
    260            }
    261            
    262            u32Temp = 9;
   \                     ??DebugPrintNumber_5: (+1)
   \   00000076   0x2009             MOVS     R0,#+9
   \   00000078   0x0007             MOVS     R7,R0
    263            for(u8 index = u8CharCount; index != 0; index--)
   \   0000007A   0x0030             MOVS     R0,R6
   \                     ??DebugPrintNumber_6: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD009             BEQ.N    ??DebugPrintNumber_7
    264            {
    265              pu8Data[index - 1] = au8AsciiNumber[u32Temp--];
   \   00000082   0x4669             MOV      R1,SP
   \   00000084   0x5DC9             LDRB     R1,[R1, R7]
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xEB09 0x0200      ADD      R2,R9,R0
   \   0000008C   0xF802 0x1C01      STRB     R1,[R2, #-1]
   \   00000090   0x1E7F             SUBS     R7,R7,#+1
    266            }
   \   00000092   0x1E40             SUBS     R0,R0,#+1
   \   00000094   0xE7F2             B.N      ??DebugPrintNumber_6
    267              
    268            /* Print the ascii string and free the memory */
    269            UartWriteData(Debug_Uart, u8CharCount, pu8Data);
   \                     ??DebugPrintNumber_7: (+1)
   \   00000096   0x464A             MOV      R2,R9
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      BL       UartWriteData
    270            free(pu8Data);
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0x.... 0x....      BL       free
    271            
    272          } /* end DebugDebugPrintNumber() */
   \   000000AC   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    273          
    274          
    275          /*----------------------------------------------------------------------------------------------------------------------
    276          Function: DebugScanf
    277          
    278          Description:
    279          Copies G_u8DebugScanfCharCount characters from G_au8DebugScanfBuffer to a target array 
    280          so the input can be saved.  Once copied, G_au8DebugScanfBuffer is cleared and
    281          G_u8DebugScanfCharCount is zeroed.
    282          
    283          Requires:
    284            - G_u8DebugScanfCharCount holds the number of characters in the G_au8DebugScanfBuffer
    285            - au8Buffer_ points to an array large enough to hold G_u8DebugScanfCharCount characters
    286            - Debug task is blocked here so new characters are not added
    287          
    288          Promises:
    289            - G_u8DebugScanfCharCount characters copied to *au8Buffer_
    290            - G_au8DebugScanfBuffer[i] = '\0', where 0 <= i <= DEBUG_SCANF_BUFFER_SIZE
    291            - G_u8DebugScanfCharCount = 0
    292          */

   \                                 In section .text, align 2, keep-with-next
    293          u8 DebugScanf(u8* au8Buffer_)
    294          {
   \                     DebugScanf: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    295            u8 u8Temp = G_u8DebugScanfCharCount;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
    296            
    297            /* Copy the characters, clearing as we go */
    298            for(u8 i = 0; i < G_u8DebugScanfCharCount; i++)
   \   0000000A   0x2200             MOVS     R2,#+0
   \                     ??DebugScanf_0: (+1)
   \   0000000C   0x0013             MOVS     R3,R2
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable17_5
   \   00000012   0x7824             LDRB     R4,[R4, #+0]
   \   00000014   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000016   0x42A3             CMP      R3,R4
   \   00000018   0xD20C             BCS.N    ??DebugScanf_1
    299            {
    300              *(au8Buffer_ + i) = G_au8DebugScanfBuffer[i];
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable17_6
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x5C9B             LDRB     R3,[R3, R2]
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x548B             STRB     R3,[R1, R2]
    301              G_au8DebugScanfBuffer[i] = '\0';
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x.... 0x....      LDR.W    R4,??DataTable17_6
   \   0000002C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002E   0x54A3             STRB     R3,[R4, R2]
    302            }
   \   00000030   0x1C52             ADDS     R2,R2,#+1
   \   00000032   0xE7EB             B.N      ??DebugScanf_0
    303            
    304            G_u8DebugScanfCharCount = 0;
   \                     ??DebugScanf_1: (+1)
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x.... 0x....      LDR.W    R3,??DataTable17_5
   \   0000003A   0x701A             STRB     R2,[R3, #+0]
    305            return u8Temp;
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return
    306            
    307          } /* end DebugScanf() */
    308          
    309          
    310          
    311          /*----------------------------------------------------------------------------------------------------------------------
    312          Function: DebugSetPassthrough
    313          
    314          Description:
    315          Puts the Debug task in Passthrough mode so ALL characters received are put in to the Scanf buffer and
    316          the Debug task does not look for input for the menu system. This allows task to have full access to 
    317          terminal input without the Debug task printing messages or stealing Backspace characters!
    318          
    319          Passthrough mode does NOT disable any other Debug functions that have already been enabled.  For example,
    320          if you want the 1ms timing violation warning you can enable this and then enable Passthrough mode.
    321          
    322          Requires:
    323            -
    324          
    325          Promises:
    326            - G_u32DebugFlags _DEBUG_PASSTHROUGH is set
    327          */

   \                                 In section .text, align 2, keep-with-next
    328          void DebugSetPassthrough(void)
    329          {
   \                     DebugSetPassthrough: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    330            G_u32DebugFlags |= _DEBUG_PASSTHROUGH;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000010   0x6008             STR      R0,[R1, #+0]
    331            
    332            DebugPrintf("\n\n\r***Debug Passthrough enabled***\n\n\r");
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_8
   \   00000016   0x.... 0x....      BL       DebugPrintf
    333          
    334          } /* end DebugSetPassthrough */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    335          
    336          
    337          /*----------------------------------------------------------------------------------------------------------------------
    338          Function: DebugClearPassthrough
    339          
    340          Description:
    341          Takes the Debug task out of Passthrough mode.
    342          
    343          Requires:
    344            -
    345          
    346          Promises:
    347            - G_u32DebugFlags _DEBUG_PASSTHROUGH is cleared
    348          */

   \                                 In section .text, align 2, keep-with-next
    349          void DebugClearPassthrough(void)
    350          {
   \                     DebugClearPassthrough: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    351            G_u32DebugFlags &= ~_DEBUG_PASSTHROUGH;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000010   0x6008             STR      R0,[R1, #+0]
    352            
    353            DebugPrintf("\n\n\r***Debug Passthrough disabled***\n\n\r");
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \   00000016   0x.... 0x....      BL       DebugPrintf
    354            
    355          } /* end DebugClearPassthrough */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    356          
    357          
    358          /*----------------------------------------------------------------------------------------------------------------------
    359          Function: SystemStatusReport
    360          
    361          Description:
    362          Reports if system is good or not.
    363          
    364          Requires:
    365            - G_u32SystemFlags up to date with system status
    366            - New tasks should be added to the check list below including in the message string for the task name
    367            - The system is in initialization state so MsgSenderForceSend() is used
    368              to output each meassage after it is queued.
    369          
    370          Promises:
    371            - Prints out messages for any system tests that failed
    372            - Prints out overall good message if all tests passed
    373          */

   \                                 In section .text, align 2, keep-with-next
    374          void SystemStatusReport(void)
    375          {
   \                     SystemStatusReport: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0AC             SUB      SP,SP,#+176
    376            u8 au8SystemPassed[] = "No failed tasks.";
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   0000000A   0x2211             MOVS     R2,#+17
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    377            u8 au8SystemReady[] = "\n\rInitialization complete. Type en+c00 for debug menu.  Failed tasks:\n\r";
   \   00000010   0xA819             ADD      R0,SP,#+100
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable17_11
   \   00000016   0x2248             MOVS     R2,#+72
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    378            u32 u32TaskFlagMaskBit = (u32)0x01;
   \   0000001C   0x2401             MOVS     R4,#+1
    379            bool bNoFailedTasks = TRUE;
   \   0000001E   0x2501             MOVS     R5,#+1
    380          
    381          #ifdef EIE1
    382            u8 aau8AppShortNames[NUMBER_APPLICATIONS][MAX_TASK_NAME_SIZE] = {"LED", "BUTTON", "DEBUG", "LCD", "ANT", "TIMER", "ADC", "SD"};
   \   00000020   0xA805             ADD      R0,SP,#+20
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_12
   \   00000026   0x2250             MOVS     R2,#+80
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
    383          #endif /* EIE1 */
    384          
    385          #ifdef MPGL2
    386            u8 aau8AppShortNames[NUMBER_APPLICATIONS][MAX_TASK_NAME_SIZE] = {"LED", "BUTTON", "DEBUG", "LCD", "ANT", "TIMER", "ADC", "CAPTOUCH"};
    387          #endif /* MPGL2 */
    388          
    389            /* Announce init complete then report any tasks that failed init */
    390            DebugPrintf(au8SystemReady);
   \   0000002C   0xA819             ADD      R0,SP,#+100
   \   0000002E   0x.... 0x....      BL       DebugPrintf
    391              
    392            for(u8 i = 0; i < NUMBER_APPLICATIONS; i++)
   \   00000032   0x2600             MOVS     R6,#+0
   \                     ??SystemStatusReport_0: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E08             CMP      R6,#+8
   \   00000038   0xDA13             BGE.N    ??SystemStatusReport_1
    393            {
    394              if( !(u32TaskFlagMaskBit & G_u32ApplicationFlags) )
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4204             TST      R4,R0
   \   00000042   0xD10B             BNE.N    ??SystemStatusReport_2
    395              {
    396                bNoFailedTasks = FALSE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
    397                DebugPrintf(&aau8AppShortNames[i][0]);
   \   00000048   0xA805             ADD      R0,SP,#+20
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x210A             MOVS     R1,#+10
   \   0000004E   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000052   0x4408             ADD      R0,R0,R1
   \   00000054   0x.... 0x....      BL       DebugPrintf
    398                DebugLineFeed();
   \   00000058   0x.... 0x....      BL       DebugLineFeed
    399              }
    400              
    401              u32TaskFlagMaskBit <<= 1;
   \                     ??SystemStatusReport_2: (+1)
   \   0000005C   0x0064             LSLS     R4,R4,#+1
    402            }     
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7E8             B.N      ??SystemStatusReport_0
    403                  
    404            if( bNoFailedTasks)
   \                     ??SystemStatusReport_1: (+1)
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D00             CMP      R5,#+0
   \   00000066   0xD002             BEQ.N    ??SystemStatusReport_3
    405            {
    406              DebugPrintf(au8SystemPassed);
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x.... 0x....      BL       DebugPrintf
    407            }
    408            
    409            DebugLineFeed();
   \                     ??SystemStatusReport_3: (+1)
   \   0000006E   0x.... 0x....      BL       DebugLineFeed
    410            
    411          } /* end SystemStatusReport() */
   \   00000072   0xB02C             ADD      SP,SP,#+176
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x4C 0x45          DC8 "LED"
   \              0x44 0x00    
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000000A   0x42 0x55          DC8 "BUTTON"
   \              0x54 0x54    
   \              0x4F 0x4E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000014   0x44 0x45          DC8 "DEBUG"
   \              0x42 0x55    
   \              0x47 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001E   0x4C 0x43          DC8 "LCD"
   \              0x44 0x00    
   \   00000022   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x41 0x4E          DC8 "ANT"
   \              0x54 0x00    
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000032   0x54 0x49          DC8 "TIMER"
   \              0x4D 0x45    
   \              0x52 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000003C   0x41 0x44          DC8 "ADC"
   \              0x43 0x00    
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000046   0x53 0x44          DC8 "SD"
   \              0x00         
   \   00000049   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
    412          
    413          
    414          /*--------------------------------------------------------------------------------------------------------------------*/
    415          /* Protected Functions */
    416          /*--------------------------------------------------------------------------------------------------------------------*/
    417          
    418          /*----------------------------------------------------------------------------------------------------------------------
    419          Function: DebugInitialize
    420          
    421          Description:
    422          Sets up the debug command list and activates the debug functionality.
    423          
    424          Requires:
    425            - The debug application is not yet running
    426            - The UART resource requested should be free
    427          
    428          Promises:
    429            - UART resource Debug_au8RxBuffer initialized to all 0
    430            - Buffer pointers Debug_pu8CmdBufferCurrentChar and Debug_pu8RxBufferParser set to the start of the buffer
    431            - Debug_pfnStateMachine set to Idle
    432          */

   \                                 In section .text, align 2, keep-with-next
    433          void DebugInitialize(void)
    434          {
   \                     DebugInitialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    435            UartConfigurationType sUartConfig;  
    436          
    437            /* Clear the receive buffer */
    438            for (u16 i = 0; i < DEBUG_RX_BUFFER_SIZE; i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_0: (+1)
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x2880             CMP      R0,#+128
   \   0000000A   0xD206             BCS.N    ??DebugInitialize_1
    439            {
    440              Debug_au8RxBuffer[i] = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable17_14
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x5411             STRB     R1,[R2, R0]
    441            }
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0xE7F5             B.N      ??DebugInitialize_0
    442          
    443            /* Clear the scanf buffer and counter */
    444            G_u8DebugScanfCharCount = 0;
   \                     ??DebugInitialize_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    445            for (u8 i = 0; i < DEBUG_SCANF_BUFFER_SIZE; i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_2: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2880             CMP      R0,#+128
   \   00000028   0xDA06             BGE.N    ??DebugInitialize_3
    446            {
    447              G_au8DebugScanfBuffer[i] = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable17_6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5411             STRB     R1,[R2, R0]
    448            }
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0xE7F5             B.N      ??DebugInitialize_2
    449          
    450            /* Initailze startup values and the command array */
    451            Debug_pu8RxBufferParser    = &Debug_au8RxBuffer[0];
   \                     ??DebugInitialize_3: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable17_15
   \   00000040   0x6008             STR      R0,[R1, #+0]
    452            Debug_pu8RxBufferNextChar  = &Debug_au8RxBuffer[0]; 
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    453            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0]; 
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable17_17
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable17_18
   \   00000054   0x6008             STR      R0,[R1, #+0]
    454          
    455            /* Request the UART resource to be used for the Debug application */
    456            sUartConfig.UartPeripheral     = DEBUG_UART;
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
    457            sUartConfig.pu8RxBufferAddress = &Debug_au8RxBuffer[0];
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   00000060   0x9001             STR      R0,[SP, #+4]
    458            sUartConfig.pu8RxNextByte      = &Debug_pu8RxBufferNextChar;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable17_16
   \   00000066   0x9002             STR      R0,[SP, #+8]
    459            sUartConfig.u16RxBufferSize    = DEBUG_RX_BUFFER_SIZE;
   \   00000068   0x2080             MOVS     R0,#+128
   \   0000006A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    460            sUartConfig.fnRxCallback       = DebugRxCallback;
   \   0000006E   0x.... 0x....      ADR.W    R0,DebugRxCallback
   \   00000072   0x9003             STR      R0,[SP, #+12]
    461            
    462            Debug_Uart = UartRequest(&sUartConfig);
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x.... 0x....      BL       UartRequest
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    463            
    464            /* Go to error state if the UartRequest failed */
    465            if(Debug_Uart == NULL)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD105             BNE.N    ??DebugInitialize_4
    466            {
    467              Debug_pfnStateMachine = DebugSM_Error;
   \   0000008A   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000092   0x6008             STR      R0,[R1, #+0]
   \   00000094   0xE010             B.N      ??DebugInitialize_5
    468          
    469            }
    470            /* Otherwise send the first message, set "good" flag and head to Idle */
    471            else
    472            {
    473              DebugPrintf(Debug_au8StartupMsg);   
   \                     ??DebugInitialize_4: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable17_19
   \   0000009A   0x.... 0x....      BL       DebugPrintf
    474              G_u32ApplicationFlags |= _APPLICATION_FLAGS_DEBUG;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable17_13
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    475              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000AE   0x.... 0x....      ADR.W    R0,DebugSM_Idle
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    476            }
    477            
    478          } /* end  DebugInitialize() */
   \                     ??DebugInitialize_5: (+1)
   \   000000B8   0xB005             ADD      SP,SP,#+20
   \   000000BA   0xBD00             POP      {PC}             ;; return
    479          
    480          
    481          /*----------------------------------------------------------------------------------------------------------------------
    482          Function DebugRunActiveState()
    483          
    484          Description:
    485          Selects and runs one iteration of the current state in the state machine.
    486          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    487          may take 1ms / n to execute.
    488          
    489          Requires:
    490            - State machine function pointer points at current state
    491          
    492          Promises:
    493            - Calls the function to pointed by the state machine function pointer
    494          */

   \                                 In section .text, align 2, keep-with-next
    495          void DebugRunActiveState(void)
    496          {
   \                     DebugRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    497            Debug_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    498          
    499          } /* end DebugRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    500          
    501          
    502          /*----------------------------------------------------------------------------------------------------------------------
    503          Function DebugRxCallback()
    504          
    505          Description:
    506          Call back function used when character received.
    507          
    508          Requires:
    509            - None
    510          
    511          Promises:
    512            - Safely advances Debug_pu8RxBufferNextChar.
    513          */

   \                                 In section .text, align 4, keep-with-next
    514          void DebugRxCallback(void)
    515          {
    516            /* Safely advance the NextChar pointer */
    517            Debug_pu8RxBufferNextChar++;
   \                     DebugRxCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_16
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    518            if(Debug_pu8RxBufferNextChar == &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_16
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17_20
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??DebugRxCallback_0
    519            {
    520              Debug_pu8RxBufferNextChar = &Debug_au8RxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   00000024   0x6008             STR      R0,[R1, #+0]
    521            }
    522            
    523          } /* end DebugRxCallback() */
   \                     ??DebugRxCallback_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    524          
    525          
    526          /*--------------------------------------------------------------------------------------------------------------------*/
    527          /* Private Functions */
    528          /*--------------------------------------------------------------------------------------------------------------------*/
    529          
    530          /*----------------------------------------------------------------------------------------------------------------------
    531          Function DebugCommandPrepareList
    532          
    533          Description:
    534          Queues the entire list of debug commands available in the system so they will
    535          be sent out the debug UART for the user to view.
    536          
    537          Requires:
    538            - Message Sender application is running
    539          
    540          Promises:
    541            - Command numbers and names of all installed commands are queued to messagesender.
    542          */

   \                                 In section .text, align 2, keep-with-next
    543          static void DebugCommandPrepareList(void)
    544          {
   \                     DebugCommandPrepareList: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
    545            u8 au8ListHeading[] = "\n\n\rAvailable commands:\n\r";
   \   00000004   0xA80A             ADD      R0,SP,#+40
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \   0000000A   0x2219             MOVS     R2,#+25
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    546            u8 au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + DEBUG_CMD_POSTFIX_LENGTH];
    547            
    548            /* Write static characters to command list line */
    549            au8CommandLine[2] = ':';
   \   00000010   0x203A             MOVS     R0,#+58
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
    550            au8CommandLine[3] = ' ';
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    551            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH] = '\n';
   \   0000001C   0x200A             MOVS     R0,#+10
   \   0000001E   0xF88D 0x0024      STRB     R0,[SP, #+36]
    552            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 1] = '\r';
   \   00000022   0x200D             MOVS     R0,#+13
   \   00000024   0xF88D 0x0025      STRB     R0,[SP, #+37]
    553            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 2] = '\0';
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0026      STRB     R0,[SP, #+38]
    554          
    555            /* Prepare a nicely formatted list of commands */
    556            DebugPrintf(au8ListHeading);
   \   0000002E   0xA80A             ADD      R0,SP,#+40
   \   00000030   0x.... 0x....      BL       DebugPrintf
    557            
    558            /* Loop through the array of commands parsing out the command number
    559            and printing it along with the command name. */  
    560            for(u8 i = 0; i < DEBUG_COMMANDS; i++)
   \   00000034   0x2400             MOVS     R4,#+0
   \                     ??DebugCommandPrepareList_0: (+1)
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2C08             CMP      R4,#+8
   \   0000003A   0xDA2C             BGE.N    ??DebugCommandPrepareList_1
    561            {
    562              /* Get the command number in ASCII */
    563              if(i >= 10)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C0A             CMP      R4,#+10
   \   00000040   0xDB07             BLT.N    ??DebugCommandPrepareList_2
    564              {
    565                au8CommandLine[0] = (i / 10) + 0x30;
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000004A   0x3030             ADDS     R0,R0,#+48
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000050   0xE002             B.N      ??DebugCommandPrepareList_3
    566              }
    567              else
    568              {
    569                au8CommandLine[0] = 0x30;
   \                     ??DebugCommandPrepareList_2: (+1)
   \   00000052   0x2030             MOVS     R0,#+48
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    570              }
    571              
    572              au8CommandLine[1] = (i % 10) + 0x30;
   \                     ??DebugCommandPrepareList_3: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   00000060   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   00000064   0x3030             ADDS     R0,R0,#+48
   \   00000066   0xF88D 0x0001      STRB     R0,[SP, #+1]
    573              
    574              /* Read the command name */
    575              for(u8 j = 0; j < DEBUG_CMD_NAME_LENGTH; j++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??DebugCommandPrepareList_4: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2820             CMP      R0,#+32
   \   00000070   0xDA0C             BGE.N    ??DebugCommandPrepareList_5
    576              {
    577                au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + j] = Debug_au8Commands[i].pu8CommandName[j];
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable17_22
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0xF851 0x1034      LDR      R1,[R1, R4, LSL #+3]
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x5C09             LDRB     R1,[R1, R0]
   \   00000080   0x466A             MOV      R2,SP
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x4402             ADD      R2,R2,R0
   \   00000086   0x7111             STRB     R1,[R2, #+4]
    578              }
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0xE7EF             B.N      ??DebugCommandPrepareList_4
    579              
    580              /* Queue the command name to the UART */
    581              DebugPrintf(au8CommandLine);
   \                     ??DebugCommandPrepareList_5: (+1)
   \   0000008C   0x4668             MOV      R0,SP
   \   0000008E   0x.... 0x....      BL       DebugPrintf
    582            }
   \   00000092   0x1C64             ADDS     R4,R4,#+1
   \   00000094   0xE7CF             B.N      ??DebugCommandPrepareList_0
    583          
    584            DebugLineFeed();
   \                     ??DebugCommandPrepareList_1: (+1)
   \   00000096   0x.... 0x....      BL       DebugLineFeed
    585            
    586          } /* end DebugCommand0PrepareList() */
   \   0000009A   0xB012             ADD      SP,SP,#+72
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
    587          
    588          
    589          
    590          /*----------------------------------------------------------------------------------------------------------------------
    591          Function: DebugCommandDummy
    592          
    593          Description:
    594          A command place-holder.
    595          */

   \                                 In section .text, align 2, keep-with-next
    596          static void DebugCommandDummy(void)
    597          {
   \                     DebugCommandDummy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    598            u8 au8DummyCommand[] = "\n\rDummy!\n\n\r";
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_23
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    599            
    600            DebugPrintf(au8DummyCommand);
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       DebugPrintf
    601            
    602          } /* end DebugCommandDummy() */
   \   00000018   0xBD1F             POP      {R0-R4,PC}       ;; return
    603          
    604          
    605          /*----------------------------------------------------------------------------------------------------------------------
    606          Function: DebugCommandLedTestToggle
    607          
    608          Description:
    609          Toggles the active state of the LED test which allows typed characters corresponding to LED colors
    610          to toggle those LEDs on or off.  LEDs are started all ON.  They are left in their current state when
    611          the function exits.
    612          */

   \                                 In section .text, align 2, keep-with-next
    613          static void DebugCommandLedTestToggle(void)
    614          {
   \                     DebugCommandLedTestToggle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    615            u8 au8LedTestMessage[] = "\n\rLed Test ";
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_24
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    616            
    617            /* Print message and toggle the flag */
    618            DebugPrintf(au8LedTestMessage);
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       DebugPrintf
    619            if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD50C             BPL.N    ??DebugCommandLedTestToggle_0
    620            {
    621              G_u32DebugFlags &= ~_DEBUG_LED_TEST_ENABLE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x0040             LSLS     R0,R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000030   0x6008             STR      R0,[R1, #+0]
    622              DebugPrintf(G_au8MessageOFF);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable17_25
   \   00000036   0x.... 0x....      BL       DebugPrintf
   \   0000003A   0xE023             B.N      ??DebugCommandLedTestToggle_1
    623            }
    624            else
    625            {
    626              G_u32DebugFlags |= _DEBUG_LED_TEST_ENABLE;
   \                     ??DebugCommandLedTestToggle_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    627              DebugPrintf(G_au8MessageON);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   00000050   0x.... 0x....      BL       DebugPrintf
    628              
    629          #ifdef EIE1
    630              LedOn(WHITE);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       LedOn
    631              LedOn(PURPLE);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       LedOn
    632              LedOn(BLUE);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      BL       LedOn
    633              LedOn(CYAN);
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x.... 0x....      BL       LedOn
    634              LedOn(GREEN);
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0x.... 0x....      BL       LedOn
    635              LedOn(YELLOW);
   \   00000072   0x2005             MOVS     R0,#+5
   \   00000074   0x.... 0x....      BL       LedOn
    636              LedOn(ORANGE);
   \   00000078   0x2006             MOVS     R0,#+6
   \   0000007A   0x.... 0x....      BL       LedOn
    637              LedOn(RED);
   \   0000007E   0x2007             MOVS     R0,#+7
   \   00000080   0x.... 0x....      BL       LedOn
    638          #endif /* EIE1 */   
    639              
    640          #ifdef MPGL2
    641          #ifdef MPGL2_R01
    642              LedOn(BLUE);
    643              LedOn(GREEN);
    644              LedOn(YELLOW);
    645              LedOn(RED);
    646          #else
    647              LedOn(BLUE0);
    648              LedOn(BLUE1);
    649              LedOn(BLUE2);
    650              LedOn(BLUE3);
    651              LedOn(RED0);
    652              LedOn(RED1);
    653              LedOn(RED2);
    654              LedOn(RED3);
    655              LedOn(GREEN0);
    656              LedOn(GREEN1);
    657              LedOn(GREEN2);
    658              LedOn(GREEN3);
    659          #endif /* MPGL2_R01 */
    660          #endif /* MPGL2 */
    661            }
    662            
    663          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugCommandLedTestToggle_1: (+1)
   \   00000084   0xBD1F             POP      {R0-R4,PC}       ;; return
    664          
    665          
    666          /*----------------------------------------------------------------------------------------------------------------------
    667          Function: DebugLedTestCharacter
    668          
    669          Description:
    670          Checks the character and toggles associated LED if applicable.
    671          This implementation is specific to the target hardware.
    672          
    673          Requires:
    674            - u8Char_ is the character to check
    675          
    676          Promises:
    677            - If u8Char_ is a valid toggling character, the corresponding LED will be toggled.
    678          */

   \                                 In section .text, align 2, keep-with-next
    679          static void DebugLedTestCharacter(u8 u8Char_)
    680          {
   \                     DebugLedTestCharacter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    681            /* Check the char to see if an LED should be toggled */  
    682          #ifdef EIE1
    683            if(u8Char_ == 'W')
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C57             CMP      R4,#+87
   \   00000008   0xD102             BNE.N    ??DebugLedTestCharacter_0
    684            {
    685              LedToggle(WHITE);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       LedToggle
    686            }  
    687          
    688            if(u8Char_ == 'P')
   \                     ??DebugLedTestCharacter_0: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C50             CMP      R4,#+80
   \   00000014   0xD102             BNE.N    ??DebugLedTestCharacter_1
    689            {
    690              LedToggle(PURPLE);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       LedToggle
    691            } 
    692          
    693            if(u8Char_ == 'B')
   \                     ??DebugLedTestCharacter_1: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C42             CMP      R4,#+66
   \   00000020   0xD102             BNE.N    ??DebugLedTestCharacter_2
    694            {
    695              LedToggle(BLUE);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       LedToggle
    696            } 
    697          
    698            if(u8Char_ == 'C')
   \                     ??DebugLedTestCharacter_2: (+1)
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C43             CMP      R4,#+67
   \   0000002C   0xD102             BNE.N    ??DebugLedTestCharacter_3
    699            {
    700              LedToggle(CYAN);
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      BL       LedToggle
    701            } 
    702          
    703            if(u8Char_ == 'G')
   \                     ??DebugLedTestCharacter_3: (+1)
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C47             CMP      R4,#+71
   \   00000038   0xD102             BNE.N    ??DebugLedTestCharacter_4
    704            {
    705              LedToggle(GREEN);
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x.... 0x....      BL       LedToggle
    706            } 
    707          
    708            if(u8Char_ == 'Y')
   \                     ??DebugLedTestCharacter_4: (+1)
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2C59             CMP      R4,#+89
   \   00000044   0xD102             BNE.N    ??DebugLedTestCharacter_5
    709            {
    710              LedToggle(YELLOW);
   \   00000046   0x2005             MOVS     R0,#+5
   \   00000048   0x.... 0x....      BL       LedToggle
    711            } 
    712          
    713            if(u8Char_ == 'O')
   \                     ??DebugLedTestCharacter_5: (+1)
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C4F             CMP      R4,#+79
   \   00000050   0xD102             BNE.N    ??DebugLedTestCharacter_6
    714            {
    715              LedToggle(ORANGE);
   \   00000052   0x2006             MOVS     R0,#+6
   \   00000054   0x.... 0x....      BL       LedToggle
    716            } 
    717          
    718            if(u8Char_ == 'R')
   \                     ??DebugLedTestCharacter_6: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2C52             CMP      R4,#+82
   \   0000005C   0xD102             BNE.N    ??DebugLedTestCharacter_7
    719            {
    720              LedToggle(RED);
   \   0000005E   0x2007             MOVS     R0,#+7
   \   00000060   0x.... 0x....      BL       LedToggle
    721            } 
    722          
    723          #endif /* EIE1 */
    724            
    725          #ifdef MPGL2
    726            
    727          #ifdef MPGL2_R01
    728            if(u8Char_ == 'B')
    729            {
    730              LedToggle(BLUE);
    731            } 
    732          
    733            if(u8Char_ == 'G')
    734            {
    735              LedToggle(GREEN);
    736            } 
    737          
    738            if(u8Char_ == 'Y')
    739            {
    740              LedToggle(YELLOW);
    741            } 
    742          
    743            if(u8Char_ == 'R')
    744            {
    745              LedToggle(RED);
    746            } 
    747            
    748          #else
    749          
    750            if(u8Char_ == 'B')
    751            {
    752              LedToggle(BLUE0);
    753              LedToggle(BLUE1);
    754              LedToggle(BLUE2);
    755              LedToggle(BLUE3);
    756            }  
    757          
    758            if(u8Char_ == 'R')
    759            {
    760              LedToggle(RED0);
    761              LedToggle(RED1);
    762              LedToggle(RED2);
    763              LedToggle(RED3);
    764            }  
    765            
    766            if(u8Char_ == 'G')
    767            {
    768              LedToggle(GREEN0);
    769              LedToggle(GREEN1);
    770              LedToggle(GREEN2);
    771              LedToggle(GREEN3);
    772            }  
    773           
    774          #endif /* MPGL2_R01 */
    775          #endif /* MPGL2 */
    776            
    777          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugLedTestCharacter_7: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    778          
    779          
    780          /*----------------------------------------------------------------------------------------------------------------------
    781          Function: DebugCommandSysTimeToggle
    782          
    783          Description:
    784          Toggles the active state of the LED test which allows typed characters corresponding to LED colors
    785          to toggle those LEDs on or off.
    786          */

   \                                 In section .text, align 2, keep-with-next
    787          static void DebugCommandSysTimeToggle(void)
    788          {
   \                     DebugCommandSysTimeToggle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    789            u8 au8SysTimeTestMessage[] = "\n\rSystem time violation reporting ";
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_27
   \   0000000A   0x2223             MOVS     R2,#+35
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    790            
    791            /* Print message and toggle the flag */
    792            DebugPrintf(au8SysTimeTestMessage);
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       DebugPrintf
    793            if(G_u32DebugFlags & _DEBUG_TIME_WARNING_ENABLE)
   \   00000016   0x....             LDR.N    R0,??DataTable17_7
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
   \   0000001C   0xD509             BPL.N    ??DebugCommandSysTimeToggle_0
    794            {
    795              G_u32DebugFlags &= ~_DEBUG_TIME_WARNING_ENABLE;
   \   0000001E   0x....             LDR.N    R0,??DataTable17_7
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000026   0x....             LDR.N    R1,??DataTable17_7
   \   00000028   0x6008             STR      R0,[R1, #+0]
    796              DebugPrintf(G_au8MessageOFF);
   \   0000002A   0x....             LDR.N    R0,??DataTable17_25
   \   0000002C   0x.... 0x....      BL       DebugPrintf
   \   00000030   0xE008             B.N      ??DebugCommandSysTimeToggle_1
    797            }
    798            else
    799            {
    800              G_u32DebugFlags |= _DEBUG_TIME_WARNING_ENABLE;
   \                     ??DebugCommandSysTimeToggle_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable17_7
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003A   0x....             LDR.N    R1,??DataTable17_7
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    801              DebugPrintf(G_au8MessageON);
   \   0000003E   0x....             LDR.N    R0,??DataTable17_26
   \   00000040   0x.... 0x....      BL       DebugPrintf
    802            }
    803            
    804          } /* end DebugCommandSysTimeToggle() */
   \                     ??DebugCommandSysTimeToggle_1: (+1)
   \   00000044   0xB009             ADD      SP,SP,#+36
   \   00000046   0xBD00             POP      {PC}             ;; return
    805          
    806          #ifdef MPGL2 /* MPGL2 only tests */
    807          /*----------------------------------------------------------------------------------------------------------------------
    808          Function: DebugCommandCaptouchValuesToggle
    809          
    810          Description:
    811          Toggles printing the current Captouch horizontal and vertical values.
    812          */
    813          static void DebugCommandCaptouchValuesToggle(void)
    814          {
    815            u8 au8CaptouchDisplayMessage[] = "\n\rDisplay Captouch values ";
    816            u8 au8CaptouchOnMessage[] = "No values displayed if Captouch is OFF\n\r";
    817            
    818            /* Print message and toggle the flag */
    819            DebugPrintf(au8CaptouchDisplayMessage);
    820            if(G_u32DebugFlags & _DEBUG_CAPTOUCH_VALUES_ENABLE)
    821            {
    822              G_u32DebugFlags &= ~_DEBUG_CAPTOUCH_VALUES_ENABLE;
    823              DebugPrintf(G_au8MessageOFF);
    824            }
    825            else
    826            {
    827              G_u32DebugFlags |= _DEBUG_CAPTOUCH_VALUES_ENABLE;
    828              DebugPrintf(G_au8MessageON);
    829              DebugPrintf(au8CaptouchOnMessage);
    830            }
    831            
    832          } /* end DebugCommandCaptouchValuesToggle() */
    833          #endif /* MPGL2 only tests */
    834          
    835          
    836          /***********************************************************************************************************************
    837          State Machine Function Declarations
    838          
    839          The debugger state machine monitors the receive buffer to grab characters as they come in
    840          from the interrupt-driven receiver and store them in the debug command buffer.  Nothing happens 
    841          until the user sends a CR indicating they think they've entered a valid command.  The command is
    842          checked and reacted to accordingly.
    843          ***********************************************************************************************************************/
    844          
    845          /*----------------------------------------------------------------------------------------------------------------------
    846          Waits for a byte to appear in the Rx buffer.  The BufferParser is always moved
    847          through all new characters placing them into the command buffer until it hits a CR or there are no new
    848          characters to read. If there is no CR in this iteration, nothing else occurs.
    849          
    850          Backspace: Echo the backspace and a space character to clear the character on screen; move Debug_pu8BufferCurrentChar back.
    851          CR: Advance states to process the command.
    852          Any other character: Echo it to the UART Tx and place a copy in Debug_au8CommandBuffer.
    853          */

   \                                 In section .text, align 4, keep-with-next
    854          void DebugSM_Idle(void)               
    855          {
   \                     DebugSM_Idle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    856            bool bCommandFound = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    857            u8 u8CurrentByte;
    858            static u8 au8BackspaceSequence[] = {ASCII_BACKSPACE, ' ', ASCII_BACKSPACE};
    859            static u8 au8CommandOverflow[] = "\r\n*** Command too long ***\r\n\n";
    860            
    861            /* Parse any new characters that have come in until no more chars or a command is found */
    862            while( (Debug_pu8RxBufferParser != Debug_pu8RxBufferNextChar) && (bCommandFound == FALSE) )
   \                     ??DebugSM_Idle_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable17_15
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable17_16
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xF000 0x809A      BEQ.W    ??DebugSM_Idle_1
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xF040 0x8096      BNE.W    ??DebugSM_Idle_1
    863            {
    864              /* Grab a copy of the current byte and echo it back */
    865              u8CurrentByte = *Debug_pu8RxBufferParser;
   \   0000001A   0x....             LDR.N    R0,??DataTable17_15
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0005             MOVS     R5,R0
    866                  
    867              /* Process the character */
    868              switch (u8CurrentByte)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD002             BEQ.N    ??DebugSM_Idle_2
   \   0000002A   0x280D             CMP      R0,#+13
   \   0000002C   0xD033             BEQ.N    ??DebugSM_Idle_3
   \   0000002E   0xE03C             B.N      ??DebugSM_Idle_4
    869              {
    870                /* Backspace: update command buffer pointer and send sequence to delete the char on the terminal */
    871                case(ASCII_BACKSPACE): 
    872                {
    873                  /* Process for scanf as long as we are not in Passthrough mode */
    874                  if( G_u32DebugFlags & _DEBUG_PASSTHROUGH )
   \                     ??DebugSM_Idle_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable17_7
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x0740             LSLS     R0,R0,#+29
   \   00000036   0xD50D             BPL.N    ??DebugSM_Idle_5
    875                  {        
    876                    if(G_u8DebugScanfCharCount < DEBUG_SCANF_BUFFER_SIZE)
   \   00000038   0x....             LDR.N    R0,??DataTable17_5
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2880             CMP      R0,#+128
   \   0000003E   0xDA26             BGE.N    ??DebugSM_Idle_6
    877                    {
    878                      G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = u8CurrentByte;
   \   00000040   0x....             LDR.N    R0,??DataTable17_6
   \   00000042   0x....             LDR.N    R1,??DataTable17_5
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0x5445             STRB     R5,[R0, R1]
    879                      G_u8DebugScanfCharCount++;
   \   00000048   0x....             LDR.N    R0,??DataTable17_5
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable17_5
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   \   00000052   0xE01C             B.N      ??DebugSM_Idle_6
    880                    }
    881                  }
    882                  else
    883                  {
    884                    if(G_u8DebugScanfCharCount != 0)
   \                     ??DebugSM_Idle_5: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable17_5
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD009             BEQ.N    ??DebugSM_Idle_7
    885                    {
    886                      G_u8DebugScanfCharCount--;
   \   0000005C   0x....             LDR.N    R0,??DataTable17_5
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable17_5
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    887                      G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = '\0';
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x....             LDR.N    R1,??DataTable17_6
   \   0000006A   0x....             LDR.N    R2,??DataTable17_5
   \   0000006C   0x7812             LDRB     R2,[R2, #+0]
   \   0000006E   0x5488             STRB     R0,[R1, R2]
    888                    }
    889          
    890                    /* Process for command */
    891                    if(Debug_pu8CmdBufferNextChar != &Debug_au8CommandBuffer[0])
   \                     ??DebugSM_Idle_7: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable17_18
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x....             LDR.N    R1,??DataTable17_17
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD009             BEQ.N    ??DebugSM_Idle_6
    892                    {
    893                      Debug_pu8CmdBufferNextChar--;
   \   0000007A   0x....             LDR.N    R0,??DataTable17_18
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x....             LDR.N    R1,??DataTable17_18
   \   00000082   0x6008             STR      R0,[R1, #+0]
    894                      Debug_u16CommandSize--;
   \   00000084   0x....             LDR.N    R0,??DataTable17_28
   \   00000086   0x8800             LDRH     R0,[R0, #+0]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x....             LDR.N    R1,??DataTable17_28
   \   0000008C   0x8008             STRH     R0,[R1, #+0]
    895                    }
    896                  }
    897                          
    898                  /* Send the Backspace sequence to clear the character on the terminal */
    899                  DebugPrintf(au8BackspaceSequence);
   \                     ??DebugSM_Idle_6: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable17_29
   \   00000090   0x.... 0x....      BL       DebugPrintf
    900                  break;
   \   00000094   0xE040             B.N      ??DebugSM_Idle_8
    901                }
    902          
    903                /* Carriage return: change states to process new command and fall through to echo character */
    904                case(ASCII_CARRIAGE_RETURN): 
    905                {
    906                  if( !( G_u32DebugFlags & _DEBUG_PASSTHROUGH) )
   \                     ??DebugSM_Idle_3: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable17_7
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x0740             LSLS     R0,R0,#+29
   \   0000009C   0xD405             BMI.N    ??DebugSM_Idle_4
    907                  {
    908                    bCommandFound = TRUE;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x0004             MOVS     R4,R0
    909                    Debug_pfnStateMachine = DebugSM_CheckCmd;
   \   000000A2   0x.... 0x....      ADR.W    R0,DebugSM_CheckCmd
   \   000000A6   0x....             LDR.N    R1,??DataTable17_4
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    910                  }
    911                  
    912                  /* Fall through to default */        
    913                }
    914                  
    915                /* Add to command buffer and echo */
    916                default: 
    917                {
    918                  /* Process for scanf */
    919                  if(G_u8DebugScanfCharCount < DEBUG_SCANF_BUFFER_SIZE)
   \                     ??DebugSM_Idle_4: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable17_5
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x2880             CMP      R0,#+128
   \   000000B0   0xDA08             BGE.N    ??DebugSM_Idle_9
    920                  {
    921                    G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = u8CurrentByte;
   \   000000B2   0x....             LDR.N    R0,??DataTable17_6
   \   000000B4   0x....             LDR.N    R1,??DataTable17_5
   \   000000B6   0x7809             LDRB     R1,[R1, #+0]
   \   000000B8   0x5445             STRB     R5,[R0, R1]
    922                    G_u8DebugScanfCharCount++;
   \   000000BA   0x....             LDR.N    R0,??DataTable17_5
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
   \   000000C0   0x....             LDR.N    R1,??DataTable17_5
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    923                  }
    924                  
    925                  /* Echo the character back to the terminal */
    926                  UartWriteByte(Debug_Uart, u8CurrentByte);
   \                     ??DebugSM_Idle_9: (+1)
   \   000000C4   0x0029             MOVS     R1,R5
   \   000000C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C8   0x....             LDR.N    R0,??DataTable17
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x.... 0x....      BL       UartWriteByte
    927                  
    928                  /* As long as Passthrough mode is not active, then update the command buffer */
    929                  if( !( G_u32DebugFlags & _DEBUG_PASSTHROUGH) )
   \   000000D0   0x....             LDR.N    R0,??DataTable17_7
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x0740             LSLS     R0,R0,#+29
   \   000000D6   0xD41F             BMI.N    ??DebugSM_Idle_10
    930                  {
    931                    *Debug_pu8CmdBufferNextChar = u8CurrentByte;
   \   000000D8   0x....             LDR.N    R0,??DataTable17_18
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x7005             STRB     R5,[R0, #+0]
    932                    Debug_pu8CmdBufferNextChar++;
   \   000000DE   0x....             LDR.N    R0,??DataTable17_18
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x1C40             ADDS     R0,R0,#+1
   \   000000E4   0x....             LDR.N    R1,??DataTable17_18
   \   000000E6   0x6008             STR      R0,[R1, #+0]
    933                    Debug_u16CommandSize++;
   \   000000E8   0x....             LDR.N    R0,??DataTable17_28
   \   000000EA   0x8800             LDRH     R0,[R0, #+0]
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \   000000EE   0x....             LDR.N    R1,??DataTable17_28
   \   000000F0   0x8008             STRH     R0,[R1, #+0]
    934          
    935                    /* If the command buffer is now full but the last character was not ASCII_CARRIAGE_RETURN, throw out the whole
    936                    buffer and report an error message */
    937                    if( (Debug_pu8CmdBufferNextChar >= &Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]) &&
    938                        (u8CurrentByte != ASCII_CARRIAGE_RETURN) )
   \   000000F2   0x....             LDR.N    R0,??DataTable17_18
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x....             LDR.N    R1,??DataTable17_30
   \   000000F8   0x4288             CMP      R0,R1
   \   000000FA   0xD30D             BCC.N    ??DebugSM_Idle_10
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0x2D0D             CMP      R5,#+13
   \   00000100   0xD00A             BEQ.N    ??DebugSM_Idle_10
    939                    {
    940                      Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   00000102   0x....             LDR.N    R0,??DataTable17_17
   \   00000104   0x....             LDR.N    R1,??DataTable17_18
   \   00000106   0x6008             STR      R0,[R1, #+0]
    941                      Debug_u16CommandSize = 0;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x....             LDR.N    R1,??DataTable17_28
   \   0000010C   0x8008             STRH     R0,[R1, #+0]
    942          
    943                      Debug_u32CurrentMessageToken = DebugPrintf(au8CommandOverflow);
   \   0000010E   0x....             LDR.N    R0,??DataTable17_31
   \   00000110   0x.... 0x....      BL       DebugPrintf
   \   00000114   0x....             LDR.N    R1,??DataTable17_32
   \   00000116   0x6008             STR      R0,[R1, #+0]
    944                    }
    945                  }
    946                  break;
    947                }
    948          
    949              } /* end switch (u8RxChar) */
    950          
    951              /* If the LED test is active, toggle LEDs based on characters */
    952              if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \                     ??DebugSM_Idle_10: (+1)
   \                     ??DebugSM_Idle_8: (+1)
   \   00000118   0x....             LDR.N    R0,??DataTable17_7
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x07C0             LSLS     R0,R0,#+31
   \   0000011E   0xD503             BPL.N    ??DebugSM_Idle_11
    953              {
    954                DebugLedTestCharacter(u8CurrentByte);
   \   00000120   0x0028             MOVS     R0,R5
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000124   0x.... 0x....      BL       DebugLedTestCharacter
    955              }
    956              
    957              /* In all cases, advance the RxBufferParser pointer safely */
    958              Debug_pu8RxBufferParser++;
   \                     ??DebugSM_Idle_11: (+1)
   \   00000128   0x....             LDR.N    R0,??DataTable17_15
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x1C40             ADDS     R0,R0,#+1
   \   0000012E   0x....             LDR.N    R1,??DataTable17_15
   \   00000130   0x6008             STR      R0,[R1, #+0]
    959              if(Debug_pu8RxBufferParser >= &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   00000132   0x....             LDR.N    R0,??DataTable17_15
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0x....             LDR.N    R1,??DataTable17_20
   \   00000138   0x4288             CMP      R0,R1
   \   0000013A   0xF4FF 0xAF63      BCC.W    ??DebugSM_Idle_0
    960              {
    961                Debug_pu8RxBufferParser = &Debug_au8RxBuffer[0];
   \   0000013E   0x....             LDR.N    R0,??DataTable17_14
   \   00000140   0x....             LDR.N    R1,??DataTable17_15
   \   00000142   0x6008             STR      R0,[R1, #+0]
   \   00000144   0xE75E             B.N      ??DebugSM_Idle_0
    962              }
    963              
    964            } /* end while */
    965            
    966            /* Clear out any completed messages */
    967            if(Debug_u32CurrentMessageToken != 0)
   \                     ??DebugSM_Idle_1: (+1)
   \   00000146   0x....             LDR.N    R0,??DataTable17_32
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD003             BEQ.N    ??DebugSM_Idle_12
    968            {
    969              QueryMessageStatus(Debug_u32CurrentMessageToken);
   \   0000014E   0x....             LDR.N    R0,??DataTable17_32
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x.... 0x....      BL       QueryMessageStatus
    970            }
    971              
    972          } /* end DebugSM_Idle() */
   \                     ??DebugSM_Idle_12: (+1)
   \   00000156   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     `DebugSM_Idle::au8BackspaceSequence`:
   \   00000000   0x08 0x20          DC8 8, 32, 8, 0
   \              0x08 0x00    

   \                                 In section .data, align 4
   \                     `DebugSM_Idle::au8CommandOverflow`:
   \   00000000   0x0D 0x0A          DC8 "\015\012*** Command too long ***\015\012\012"
   \              0x2A 0x2A    
   \              0x2A 0x20    
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x6E 0x67    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0D 0x0A    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0
    973          
    974          
    975          /*----------------------------------------------------------------------------------------------------------------------
    976          At the start of this state, the command buffer has a candidate command terminated in CR.
    977          There is a strict rule that commands are of the form
    978          en+cxx where xx is any number from 0 to DEBUG_COMMANDS, so parsing can be done based
    979          on that rule.  All other strings are invalid.  Debug interrupts remain off
    980          until the command is processed.
    981          */

   \                                 In section .text, align 4, keep-with-next
    982          void DebugSM_CheckCmd(void)        
    983          {
   \                     DebugSM_CheckCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    984            static u8 au8CommandHeader[] = "en+c";
    985            static u8 au8InvalidCommand[] = "\nInvalid command\n\n\r"; 
    986            bool bGoodCommand = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
    987            u8 u8Index;
    988            s8 s8Temp;
    989            
    990            /* Verify that the command starts with en+c */
    991            u8Index = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
    992            do
    993            {
    994              if(Debug_au8CommandBuffer[u8Index] != au8CommandHeader[u8Index])
   \                     ??DebugSM_CheckCmd_0: (+1)
   \   00000008   0x....             LDR.N    R0,??DataTable17_17
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x5D40             LDRB     R0,[R0, R5]
   \   0000000E   0x....             LDR.N    R1,??DataTable17_33
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x5D49             LDRB     R1,[R1, R5]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD001             BEQ.N    ??DebugSM_CheckCmd_1
    995              {
    996                bGoodCommand = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0004             MOVS     R4,R0
    997              }
    998          
    999              u8Index++;
   \                     ??DebugSM_CheckCmd_1: (+1)
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   1000            } while ( bGoodCommand && (u8Index < 4) );
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD002             BEQ.N    ??DebugSM_CheckCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xDBEE             BLT.N    ??DebugSM_CheckCmd_0
   1001            
   1002            /* On good header, read the command number */
   1003            if(bGoodCommand)
   \                     ??DebugSM_CheckCmd_2: (+1)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD02E             BEQ.N    ??DebugSM_CheckCmd_3
   1004            {
   1005              /* Make an assumption */
   1006              bGoodCommand = FALSE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0004             MOVS     R4,R0
   1007          
   1008              /* Verify the next char is a digit */
   1009              s8Temp = Debug_au8CommandBuffer[u8Index++] - 0x30;
   \   00000034   0x....             LDR.N    R0,??DataTable17_17
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x5740             LDRSB    R0,[R0, R5]
   \   0000003A   0x3830             SUBS     R0,R0,#+48
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   1010            
   1011              if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000040   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD423             BMI.N    ??DebugSM_CheckCmd_3
   \   00000046   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000048   0x2E0A             CMP      R6,#+10
   \   0000004A   0xDA20             BGE.N    ??DebugSM_CheckCmd_3
   1012              {
   1013                Debug_u8Command = s8Temp * 10;
   \   0000004C   0x200A             MOVS     R0,#+10
   \   0000004E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000052   0x....             LDR.N    R1,??DataTable17_34
   \   00000054   0x7008             STRB     R0,[R1, #+0]
   1014            
   1015                /* Verify the next char is a digit */
   1016                s8Temp = Debug_au8CommandBuffer[u8Index++] - 0x30;
   \   00000056   0x....             LDR.N    R0,??DataTable17_17
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x5740             LDRSB    R0,[R0, R5]
   \   0000005C   0x3830             SUBS     R0,R0,#+48
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   1017                if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000062   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD412             BMI.N    ??DebugSM_CheckCmd_3
   \   00000068   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   0000006A   0x2E0A             CMP      R6,#+10
   \   0000006C   0xDA0F             BGE.N    ??DebugSM_CheckCmd_3
   1018                {
   1019                  Debug_u8Command += s8Temp;
   \   0000006E   0x....             LDR.N    R0,??DataTable17_34
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x1830             ADDS     R0,R6,R0
   \   00000074   0x....             LDR.N    R1,??DataTable17_34
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   1020                  
   1021                  /* Check that the command number is within the range of commands available and the last char is CR */
   1022                  if( (Debug_u8Command < DEBUG_COMMANDS) && (Debug_au8CommandBuffer[u8Index] == ASCII_CARRIAGE_RETURN) )
   \   00000078   0x....             LDR.N    R0,??DataTable17_34
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x2808             CMP      R0,#+8
   \   0000007E   0xDA06             BGE.N    ??DebugSM_CheckCmd_3
   \   00000080   0x....             LDR.N    R0,??DataTable17_17
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x5D40             LDRB     R0,[R0, R5]
   \   00000086   0x280D             CMP      R0,#+13
   \   00000088   0xD101             BNE.N    ??DebugSM_CheckCmd_3
   1023                  {
   1024                    bGoodCommand = TRUE;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x0004             MOVS     R4,R0
   1025                  }
   1026                }
   1027              }
   1028            }
   1029                     
   1030            /* If still good command */
   1031            if( bGoodCommand )
   \                     ??DebugSM_CheckCmd_3: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD004             BEQ.N    ??DebugSM_CheckCmd_4
   1032            {
   1033              Debug_pfnStateMachine = DebugSM_ProcessCmd;
   \   00000094   0x.... 0x....      ADR.W    R0,DebugSM_ProcessCmd
   \   00000098   0x....             LDR.N    R1,??DataTable17_4
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0xE005             B.N      ??DebugSM_CheckCmd_5
   1034            }
   1035            /* Otherwise print an error message and return to Idle */
   1036            else
   1037            { 
   1038              DebugPrintf(au8InvalidCommand);
   \                     ??DebugSM_CheckCmd_4: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable17_35
   \   000000A0   0x.... 0x....      BL       DebugPrintf
   1039              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000A4   0x....             LDR.N    R0,??DataTable17_36
   \   000000A6   0x....             LDR.N    R1,??DataTable17_4
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1040            }
   1041          
   1042            /* Reset the command buffer */
   1043            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \                     ??DebugSM_CheckCmd_5: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable17_17
   \   000000AC   0x....             LDR.N    R1,??DataTable17_18
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1044          
   1045          } /* end DebugSM_CheckCmd() */
   \   000000B0   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     `DebugSM_CheckCmd::au8CommandHeader`:
   \   00000000   0x65 0x6E          DC8 "en+c"
   \              0x2B 0x63    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     `DebugSM_CheckCmd::au8InvalidCommand`:
   \   00000000   0x0A 0x49          DC8 "\012Invalid command\012\012\015"
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x0A 0x0A    
   \              0x0D 0x00    
   1046          
   1047          
   1048          /*----------------------------------------------------------------------------------------------------------------------
   1049          Carry out the debug instruction. 
   1050          */

   \                                 In section .text, align 4, keep-with-next
   1051          void DebugSM_ProcessCmd(void)         
   1052          {
   \                     DebugSM_ProcessCmd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1053            /* Setup for return to Idle state */
   1054            Debug_pfnStateMachine = DebugSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable17_36
   \   00000004   0x....             LDR.N    R1,??DataTable17_4
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1055          
   1056            /* Call the command function in the function array (may change next state ) */
   1057            Debug_au8Commands[Debug_u8Command].DebugFunction();
   \   00000008   0x....             LDR.N    R0,??DataTable17_22
   \   0000000A   0x....             LDR.N    R1,??DataTable17_34
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x4780             BLX      R0
   1058            
   1059          } /* end DebugSM_ProcessCmd() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1060          
   1061          
   1062          /*----------------------------------------------------------------------------------------------------------------------
   1063          Error state 
   1064          Attempt to print an error message (even though if the Debug UART has failed, then it obviously cannot print
   1065          a message to tell you that!)
   1066          */

   \                                 In section .text, align 4, keep-with-next
   1067          void DebugSM_Error(void)         
   1068          {
   \                     DebugSM_Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1069            static u8 au8DebugErrorMsg[] = "\n\nDebug task error: ";
   1070            
   1071            /* Flag an error and report it (if possible) */
   1072            G_u32DebugFlags |= _DEBUG_FLAG_ERROR;
   \   00000002   0x....             LDR.N    R0,??DataTable17_7
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000000A   0x....             LDR.N    R1,??DataTable17_7
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1073            DebugPrintf(au8DebugErrorMsg);
   \   0000000E   0x....             LDR.N    R0,??DataTable17_37
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1074            DebugPrintNumber( (u32)(Debug_u8ErrorCode) );
   \   00000014   0x....             LDR.N    R0,??DataTable17_3
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       DebugPrintNumber
   1075            DebugLineFeed();
   \   0000001C   0x.... 0x....      BL       DebugLineFeed
   1076            
   1077            /* Return to Idle state */
   1078            Debug_u16CommandSize = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable17_28
   \   00000024   0x8008             STRH     R0,[R1, #+0]
   1079            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   00000026   0x....             LDR.N    R0,??DataTable17_17
   \   00000028   0x....             LDR.N    R1,??DataTable17_18
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1080            Debug_pfnStateMachine = DebugSM_Idle;
   \   0000002C   0x....             LDR.N    R0,??DataTable17_36
   \   0000002E   0x....             LDR.N    R1,??DataTable17_4
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1081          
   1082          } /* end DebugSM_Error() */
   \   00000032   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .data, align 4
   \                     `DebugSM_Error::au8DebugErrorMsg`:
   \   00000000   0x0A 0x0A          DC8 "\012\012Debug task error: "
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     Debug_Uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     Debug_u8ErrorCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     Debug_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     G_u8DebugScanfCharCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     G_au8DebugScanfBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     G_u32DebugFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     Debug_au8RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x........         DC32     Debug_pu8RxBufferParser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x........         DC32     Debug_pu8RxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x........         DC32     Debug_pu8CmdBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x........         DC32     Debug_au8StartupMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x........         DC32     Debug_au8RxBuffer+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x........         DC32     Debug_au8Commands

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x........         DC32     G_au8MessageOFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \   00000000   0x........         DC32     G_au8MessageON

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \   00000000   0x........         DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \   00000000   0x........         DC32     Debug_u16CommandSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \   00000000   0x........         DC32     `DebugSM_Idle::au8BackspaceSequence`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_30:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_31:
   \   00000000   0x........         DC32     `DebugSM_Idle::au8CommandOverflow`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_32:
   \   00000000   0x........         DC32     Debug_u32CurrentMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_33:
   \   00000000   0x........         DC32     `DebugSM_CheckCmd::au8CommandHeader`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_34:
   \   00000000   0x........         DC32     Debug_u8Command

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_35:
   \   00000000   0x........         DC32     `DebugSM_CheckCmd::au8InvalidCommand`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_36:
   \   00000000   0x........         DC32     DebugSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_37:
   \   00000000   0x........         DC32     `DebugSM_Error::au8DebugErrorMsg`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x53 0x68          DC8 "Show debug command list         "
   \              0x6F 0x77    
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x20 0x6C    
   \              0x69 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x54 0x6F          DC8 "Toggle LED test                 "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x4C    
   \              0x45 0x44    
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x54 0x6F          DC8 "Toggle system timing warning    "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x79 0x73    
   \              0x74 0x65    
   \              0x6D 0x20    
   \              0x74 0x69    
   \              0x6D 0x69    
   \              0x6E 0x67    
   \              0x20 0x77    
   \              0x61 0x72    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x44 0x75          DC8 "Dummy3                          "
   \              0x6D 0x6D    
   \              0x79 0x33    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x44 0x75          DC8 "Dummy4                          "
   \              0x6D 0x6D    
   \              0x79 0x34    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x44 0x75          DC8 "Dummy5                          "
   \              0x6D 0x6D    
   \              0x79 0x35    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x44 0x75          DC8 "Dummy6                          "
   \              0x6D 0x6D    
   \              0x79 0x36    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x44 0x75          DC8 "Dummy7                          "
   \              0x6D 0x6D    
   \              0x79 0x37    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \                     ?_8:
   \   00000000   0x0A 0x0D          DC8 10, 13

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015***Debug Passthrough enabled***\012\012\015"
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x50 0x61    
   \              0x73 0x73    
   \              0x74 0x68    
   \              0x72 0x6F    
   \              0x75 0x67    
   \              0x68 0x20    
   \              0x65 0x6E    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x64 0x2A    
   \              0x2A 0x2A    
   \              0x0A 0x0A    
   \              0x0D 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015***Debug Passthrough disabled***\012\012\015"
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x50 0x61    
   \              0x73 0x73    
   \              0x74 0x68    
   \              0x72 0x6F    
   \              0x75 0x67    
   \              0x68 0x20    
   \              0x64 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x2A 0x2A    
   \              0x2A 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x4E 0x6F          DC8 "No failed tasks."
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x73 0x2E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 49H, 6EH, 69H, 74H, 69H, 61H
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \   00000008   0x6C 0x69          DC8 6CH, 69H, 7AH, 61H, 74H, 69H, 6FH, 6EH
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000010   0x20 0x63          DC8 20H, 63H, 6FH, 6DH, 70H, 6CH, 65H, 74H
   \              0x6F 0x6D    
   \              0x70 0x6C    
   \              0x65 0x74    
   \   00000018   0x65 0x2E          DC8 65H, 2EH, 20H, 54H, 79H, 70H, 65H, 20H
   \              0x20 0x54    
   \              0x79 0x70    
   \              0x65 0x20    
   \   00000020   0x65 0x6E          DC8 65H, 6EH, 2BH, 63H, 30H, 30H, 20H, 66H
   \              0x2B 0x63    
   \              0x30 0x30    
   \              0x20 0x66    
   \   00000028   0x6F 0x72          DC8 6FH, 72H, 20H, 64H, 65H, 62H, 75H, 67H
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \   00000030   0x20 0x6D          DC8 20H, 6DH, 65H, 6EH, 75H, 2EH, 20H, 20H
   \              0x65 0x6E    
   \              0x75 0x2E    
   \              0x20 0x20    
   \   00000038   0x46 0x61          DC8 46H, 61H, 69H, 6CH, 65H, 64H, 20H, 74H
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \   00000040   0x61 0x73          DC8 61H, 73H, 6BH, 73H, 3AH, 0AH, 0DH, 0
   \              0x6B 0x73    
   \              0x3A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015Available commands:\012\015"
   \              0x0D 0x41    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x0A 0x0D          DC8 "\012\015Dummy!\012\012\015"
   \              0x44 0x75    
   \              0x6D 0x6D    
   \              0x79 0x21    
   \              0x0A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x0A 0x0D          DC8 "\012\015Led Test "
   \              0x4C 0x65    
   \              0x64 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x0A 0x0D          DC8 "\012\015System time violation reporting "
   \              0x53 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x76 0x69    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x00         
   \   00000023   0x00               DC8 0
   1083                       
   1084          
   1085                    
   1086                       
   1087          /*--------------------------------------------------------------------------------------------------------------------*/
   1088          /* End of File                                                                                                        */
   1089          /*--------------------------------------------------------------------------------------------------------------------*/
   1090          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DebugClearPassthrough
         8   -> DebugPrintf
      24   DebugCommandDummy
        24   -> DebugPrintf
      24   DebugCommandLedTestToggle
        24   -> DebugPrintf
        24   -> LedOn
      80   DebugCommandPrepareList
        80   -> DebugLineFeed
        80   -> DebugPrintf
        80   -> __aeabi_memcpy
      40   DebugCommandSysTimeToggle
        40   -> DebugPrintf
        40   -> __aeabi_memcpy
      24   DebugInitialize
        24   -> DebugPrintf
        24   -> UartRequest
       8   DebugLedTestCharacter
         8   -> LedToggle
       8   DebugLineFeed
         8   -> UartWriteData
      40   DebugPrintNumber
        40   -> UartWriteData
        40   -> free
        40   -> malloc
      16   DebugPrintf
        16   -> UartWriteData
       8   DebugRunActiveState
         8   -- Indirect call
       0   DebugRxCallback
      16   DebugSM_CheckCmd
        16   -> DebugPrintf
       8   DebugSM_Error
         8   -> DebugLineFeed
         8   -> DebugPrintNumber
         8   -> DebugPrintf
      16   DebugSM_Idle
        16   -> DebugLedTestCharacter
        16   -> DebugPrintf
        16   -> QueryMessageStatus
        16   -> UartWriteByte
       8   DebugSM_ProcessCmd
         8   -- Indirect call
       4   DebugScanf
       8   DebugSetPassthrough
         8   -> DebugPrintf
     192   SystemStatusReport
       192   -> DebugLineFeed
       192   -> DebugPrintf
       192   -> __aeabi_memcpy
       192   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_30
       4  ??DataTable17_31
       4  ??DataTable17_32
       4  ??DataTable17_33
       4  ??DataTable17_34
       4  ??DataTable17_35
       4  ??DataTable17_36
       4  ??DataTable17_37
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      36  ?_0
      36  ?_1
      40  ?_10
      20  ?_11
      72  ?_12
      28  ?_13
      12  ?_14
      12  ?_15
      36  ?_16
      80  ?_17
      36  ?_2
      36  ?_3
      36  ?_4
      36  ?_5
      36  ?_6
      36  ?_7
       2  ?_8
      40  ?_9
      28  DebugClearPassthrough
      26  DebugCommandDummy
     134  DebugCommandLedTestToggle
     158  DebugCommandPrepareList
      72  DebugCommandSysTimeToggle
     188  DebugInitialize
     102  DebugLedTestCharacter
      28  DebugLineFeed
     176  DebugPrintNumber
      36  DebugPrintf
      12  DebugRunActiveState
      40  DebugRxCallback
     178  DebugSM_CheckCmd
      52  DebugSM_Error
     344  DebugSM_Idle
      24  DebugSM_ProcessCmd
      66  DebugScanf
      28  DebugSetPassthrough
       4  Debug_Uart
      64  Debug_au8CommandBuffer
      64  Debug_au8Commands
     128  Debug_au8RxBuffer
      68  Debug_au8StartupMsg
       4  Debug_pfnStateMachine
       4  Debug_pu8CmdBufferNextChar
       4  Debug_pu8RxBufferNextChar
       4  Debug_pu8RxBufferParser
       2  Debug_u16CommandSize
       4  Debug_u32CurrentMessageToken
       1  Debug_u8Command
       1  Debug_u8ErrorCode
     128  G_au8DebugScanfBuffer
       4  G_u32DebugFlags
       1  G_u8DebugScanfCharCount
     118  SystemStatusReport
       4  au8BackspaceSequence
       8  au8CommandHeader
      32  au8CommandOverflow
      24  au8DebugErrorMsg
      20  au8InvalidCommand

 
   353 bytes in section .bss
   220 bytes in section .data
   630 bytes in section .rodata
 1 962 bytes in section .text
 
 1 962 bytes of CODE  memory
   630 bytes of CONST memory
   573 bytes of DATA  memory

Errors: none
Warnings: none
