###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       26/Jun/2018  22:49:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\leds.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\leds.c" -D EIE1
#        --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List" -o
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\leds.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\leds.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\leds.c
      1          /***********************************************************************************************************************
      2          File: leds.c                                                                
      3          
      4          Description:
      5          LED driver that provides on, off, toggle, blink and PWM functionality.
      6          The basic on/off/toggle functionality is applied directly to the LEDs.
      7          Blinking and PWMing of LEDs rely on the EIE operating system to provide timing at
      8          regular 1ms calls to LedUpdate().
      9          
     10          ------------------------------------------------------------------------------------------------------------------------
     11          API:
     12          LedNumberType: 
     13            EIE1     - WHITE, PURPLE, BLUE, CYAN, GREEN, YELLOW, ORANGE, RED, LCD_RED, LCD_GREEN, LCD_BLUE
     14            MPGL2_R01 - BLUE, GREEN, YELLOW, RED, LCD_BL
     15            MPGL2     - BLUE0, BLUE1, BLUE2, BLUE3, GREEN0, GREEN1, GREEN2, GREEN3, RED0, RED1, RED2, RED3, LCD_BL
     16          
     17          LedRateType: LED_0_5HZ, LED_1HZ, LED_2HZ, LED_4HZ, LED_8HZ, 
     18                       LED_PWM_0, LED_PWM_5, ..., LED_PWM_100
     19          *Note that PWM values in LedRateType are continuous, thus stepping a variable of LedRateType by one will select the next 
     20          PWM level. However, decrementing past LED_PWM_0 or incrementing past LED_PWM_100 is undefined.
     21          
     22          
     23          Public:
     24          void LedOn(LedNumberType eLED_)
     25          Turn the specified LED on. LED response is immediate.
     26          e.g. LedOn(BLUE);
     27          
     28          void LedOff(LedNumberType eLED_)
     29          Turn the specified LED off. LED response is immediate.
     30          e.g. LedOff(BLUE);
     31          
     32          void LedToggle(LedNumberType eLED_)
     33          Toggle the specified LED.  LED response is immediate. LED must be in NORMAL mode.
     34          e.g. LedToggle(BLUE);
     35          
     36          void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_)
     37          Sets up an LED for PWM mode.  PWM mode requires the main loop to be running at 1ms period.
     38          e.g. LedPWM(BLUE, LED_PWM_5);
     39          
     40          void LedBlink(LedNumberType eLED_, LedRateType eBlinkRate_)
     41          Sets an LED to BLINK mode.  BLINK mode requires the main loop to be running at 1ms period.
     42          e.g. LedBlink(BLUE, LED_1HZ);
     43          
     44          Protected:
     45          void LedInitialize(void)
     46          Test all LEDs and initialize to OFF state.
     47          
     48          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     49          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     50          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     51          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     52          ***********************************************************************************************************************/
     53          
     54          #include "configuration.h"
     55          
     56          
     57          /***********************************************************************************************************************
     58          Global variable definitions with scope across entire project.
     59          All Global variable names shall start with "G_xxLed"
     60          ***********************************************************************************************************************/
     61          /*--------------------------------------------------------------------------------------------------------------------*/
     62          /* New variables (all shall start with G_xxLed*/
     63          
     64          
     65          /*--------------------------------------------------------------------------------------------------------------------*/
     66          /* External global variables defined in other files (must indicate which file they are defined in) */
     67          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     68          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     69          
     70          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     71          
     72          
     73          /***********************************************************************************************************************
     74          Global variable definitions with scope limited to this local application.
     75          Variable names shall start with "Led_" and be declared as static.
     76          ***********************************************************************************************************************/
     77          
     78          /************ %LED% EDIT BOARD-SPECIFIC GPIO DEFINITIONS BELOW ***************/
     79          
     80          #ifdef EIE1
     81          /* LED locations: order must correspond to the order set in LedNumberType in the header file. */

   \                                 In section .data, align 4
     82          static u32 Led_au32BitPositions[] = {PB_13_LED_WHT, PB_14_LED_PRP, PB_18_LED_BLU, PB_16_LED_CYN,
   \                     Led_au32BitPositions:
   \   00000000   0x00002000         DC32 8192, 16384, 262144, 65536, 524288, 131072, 32768, 1048576, 1024
   \              0x00004000   
   \              0x00040000   
   \              0x00010000   
   \              0x00080000   
   \              0x00020000   
   \              0x00008000   
   \              0x00100000   
   \              0x00000400   
   \   00000024   0x00000800         DC32 2048, 4096
   \              0x00001000   
     83                                               PB_19_LED_GRN, PB_17_LED_YLW, PB_15_LED_ORG, PB_20_LED_RED,
     84                                               PB_10_LCD_BL_RED, PB_11_LCD_BL_GRN, PB_12_LCD_BL_BLU};
     85          
     86          /* Control array for all LEDs in system initialized for LedInitialize().  Array values correspond to LedConfigType fields: 
     87               eMode         eRate      u16Count       eCurrentDuty     eActiveState     ePort      LedNumberType */

   \                                 In section .data, align 4
     88          static LedConfigType Leds_asLedArray[TOTAL_LEDS] = 
   \                     Leds_asLedArray:
   \   00000000   0x01 0x00          DC8 1, 0
   \   00000002   0x0014 0x0014      DC16 20, 20
   \   00000006   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000000C   0x0014 0x0014      DC16 20, 20
   \   00000010   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000016   0x0014 0x0014      DC16 20, 20
   \   0000001A   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000020   0x0014 0x0014      DC16 20, 20
   \   00000024   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000002A   0x0014 0x0014      DC16 20, 20
   \   0000002E   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000034   0x0014 0x0014      DC16 20, 20
   \   00000038   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000003E   0x0014 0x0014      DC16 20, 20
   \   00000042   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000048   0x0014 0x0014      DC16 20, 20
   \   0000004C   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000052   0x0014 0x0014      DC16 20, 20
   \   00000056   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   0000005C   0x0014 0x0014      DC16 20, 20
   \   00000060   0x01 0x01          DC8 1, 1, 128, 0, 1, 0
   \              0x80 0x00    
   \              0x01 0x00    
   \   00000066   0x0014 0x0014      DC16 20, 20
   \   0000006A   0x01 0x01          DC8 1, 1, 128, 0, 0, 0
   \              0x80 0x00    
   \              0x00 0x00    
     89          {{LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* WHITE      */
     90           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* PURPLE     */
     91           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE       */
     92           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* CYAN       */
     93           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* GREEN      */
     94           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* YELLOW     */
     95           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* ORANGE     */
     96           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED        */
     97           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_RED    */
     98           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_GREEN  */
     99           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}  /* LCD_BLUE   */
    100          };   
    101          #endif /* EIE1 */
    102          
    103          #ifdef MPGL2
    104          
    105          #ifdef MPGL2_R01
    106          /* LED locations: order must correspond to the order set in LedNumberType in the header file. */
    107          static u32 Led_au32BitPositions[] = {PB_18_LED_BLU, PB_19_LED_GRN, PB_17_LED_YLW, PB_20_LED_RED, PB_11_LCD_BL};
    108          
    109          /* Control array for all LEDs in system initialized for LedInitialize().  Array values correspond to LedConfigType fields: 
    110               eMode         eRate      u16Count       eCurrentDuty     eActiveState     ePort      LedNumberType */
    111          static LedConfigType Leds_asLedArray[TOTAL_LEDS] = 
    112          {{LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE       */
    113           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* GREEN      */
    114           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* YELLOW     */
    115           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED        */
    116           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_BL     */
    117          };   
    118          #else
    119          /* LED locations: order must correspond to the order set in LedNumberType in the header file. */
    120          static u32 Led_au32BitPositions[] = {PB_20_LED0_RED, PB_17_LED1_RED, PB_19_LED2_RED, PB_18_LED3_RED,
    121                                               PA_29_LED0_GRN, PB_02_LED1_GRN, PA_26_LED2_GRN, PA_07_LED3_GRN,
    122                                               PB_01_LED0_BLU, PB_13_LED1_BLU, PA_06_LED2_BLU, PA_08_LED3_BLU,
    123                                               PB_05_LCD_BL};
    124          
    125          /* Control array for all LEDs in system initialized for LedInitialize().  Array values correspond to LedConfigType fields: 
    126               eMode         eRate      u16Count       eCurrentDuty     eActiveState     ePort      LedNumberType */
    127          static LedConfigType Leds_asLedArray[TOTAL_LEDS] = 
    128          {{LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED0       */
    129           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED1       */
    130           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED2       */
    131           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* RED3       */
    132           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* GREEN0     */
    133           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* GREEN1     */
    134           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* GREEN2     */
    135           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* GREEN3     */
    136           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE0      */
    137           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* BLUE1      */
    138           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* BLUE2      */
    139           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTA}, /* BLUE3      */
    140           {LED_PWM_MODE, LED_PWM_100, LED_PWM_100, LED_PWM_DUTY_HIGH, LED_ACTIVE_HIGH, LED_PORTB}, /* LCD_BL     */
    141          };  
    142          #endif /* MPGL2_R01 */
    143          
    144          #endif /* MPGL2 */
    145          
    146          /************ EDIT BOARD-SPECIFIC GPIO DEFINITIONS ABOVE ***************/
    147           
    148          
    149          /***********************************************************************************************************************
    150          * Function Definitions
    151          ***********************************************************************************************************************/
    152          
    153          /*--------------------------------------------------------------------------------------------------------------------*/
    154          /* Public functions */
    155          /*--------------------------------------------------------------------------------------------------------------------*/
    156          
    157          /*----------------------------------------------------------------------------------------------------------------------
    158          Function: LedOn
    159          
    160          Description:
    161          Turn the specified LED on.  Automatically takes care of the active low vs. active
    162          high LEDs.  
    163          
    164          Requires:
    165            - eLED_ is a valid LED index
    166            - Definitions in Leds_asLedArray[eLED_] are correct
    167          
    168          Promises:
    169            - Requested LED is configured to be turned on next LedUpdate()
    170            - Requested LED is always set to LED_NORMAL_MODE mode
    171          */

   \                                 In section .text, align 2, keep-with-next
    172          void LedOn(LedNumberType eLED_)
    173          {
   \                     LedOn: (+1)
   \   00000000   0xB410             PUSH     {R4}
    174            u32 *pu32SetAddress;
    175          
    176            /* Configure set and clear addresses */
    177            if(Leds_asLedArray[eLED_].eActiveState == LED_ACTIVE_HIGH)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable6
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x230A             MOVS     R3,#+10
   \   0000000A   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000000E   0x441A             ADD      R2,R2,R3
   \   00000010   0x79D2             LDRB     R2,[R2, #+7]
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD10D             BNE.N    ??LedOn_0
    178            {
    179              /* Active high LEDs use SODR to turn on */
    180              pu32SetAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_SODR) + Leds_asLedArray[eLED_].ePort);
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x400e0c30
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable6
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x240A             MOVS     R4,#+10
   \   00000022   0xFB04 0xF400      MUL      R4,R4,R0
   \   00000026   0x4423             ADD      R3,R3,R4
   \   00000028   0x7A1B             LDRB     R3,[R3, #+8]
   \   0000002A   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \   0000002E   0x0011             MOVS     R1,R2
   \   00000030   0xE00C             B.N      ??LedOn_1
    181            }
    182            else
    183            {
    184              /* Active low LEDs use CODR to turn on */
    185              pu32SetAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_CODR) + Leds_asLedArray[eLED_].ePort);
   \                     ??LedOn_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable6_2  ;; 0x400e0c34
   \   00000036   0x.... 0x....      LDR.W    R3,??DataTable6
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x240A             MOVS     R4,#+10
   \   0000003E   0xFB04 0xF400      MUL      R4,R4,R0
   \   00000042   0x4423             ADD      R3,R3,R4
   \   00000044   0x7A1B             LDRB     R3,[R3, #+8]
   \   00000046   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \   0000004A   0x0011             MOVS     R1,R2
    186            }
    187            
    188            /* Turn on the LED */
    189            *pu32SetAddress = Led_au32BitPositions[(u8)eLED_];
   \                     ??LedOn_1: (+1)
   \   0000004C   0x....             LDR.N    R2,??DataTable6_3
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000054   0x600A             STR      R2,[R1, #+0]
    190            
    191            /* Always set the LED back to LED_NORMAL_MODE mode */
    192          	Leds_asLedArray[(u8)eLED_].eMode = LED_NORMAL_MODE;
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x....             LDR.N    R3,??DataTable6
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0x240A             MOVS     R4,#+10
   \   0000005E   0xFB04 0xF400      MUL      R4,R4,R0
   \   00000062   0x551A             STRB     R2,[R3, R4]
    193          
    194          } /* end LedOn() */
   \   00000064   0xBC10             POP      {R4}
   \   00000066   0x4770             BX       LR               ;; return
    195          
    196          
    197          /*----------------------------------------------------------------------------------------------------------------------
    198          Function: LedOff
    199          
    200          Description:
    201          Turn the specified LED off.  Automatically takes care of the active low vs. active
    202          high LEDs.  
    203          
    204          Requires:
    205            - eLED_ is a valid LED index
    206            - Definitions in Leds_asLedArray[eLED_] are correct
    207          
    208          Promises:
    209            - Requested LED is turned off
    210            - Requested LED is always set to LED_NORMAL_MODE mode
    211          */

   \                                 In section .text, align 2, keep-with-next
    212          void LedOff(LedNumberType eLED_)
    213          {
   \                     LedOff: (+1)
   \   00000000   0xB410             PUSH     {R4}
    214            u32 *pu32ClearAddress;
    215          
    216            /* Configure set and clear addresses */
    217            if(Leds_asLedArray[eLED_].eActiveState == LED_ACTIVE_HIGH)
   \   00000002   0x....             LDR.N    R2,??DataTable6
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000000C   0x441A             ADD      R2,R2,R3
   \   0000000E   0x79D2             LDRB     R2,[R2, #+7]
   \   00000010   0x2A01             CMP      R2,#+1
   \   00000012   0xD10B             BNE.N    ??LedOff_0
    218            {
    219              /* Active high LEDs use CODR to turn off */
    220              pu32ClearAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_CODR) + Leds_asLedArray[eLED_].ePort);
   \   00000014   0x....             LDR.N    R2,??DataTable6_2  ;; 0x400e0c34
   \   00000016   0x....             LDR.N    R3,??DataTable6
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x240A             MOVS     R4,#+10
   \   0000001C   0xFB04 0xF400      MUL      R4,R4,R0
   \   00000020   0x4423             ADD      R3,R3,R4
   \   00000022   0x7A1B             LDRB     R3,[R3, #+8]
   \   00000024   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \   00000028   0x0011             MOVS     R1,R2
   \   0000002A   0xE00A             B.N      ??LedOff_1
    221            }
    222            else
    223            {
    224              /* Active low LEDs use SODR to turn off */
    225              pu32ClearAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_SODR) + Leds_asLedArray[eLED_].ePort);
   \                     ??LedOff_0: (+1)
   \   0000002C   0x....             LDR.N    R2,??DataTable6_1  ;; 0x400e0c30
   \   0000002E   0x....             LDR.N    R3,??DataTable6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x240A             MOVS     R4,#+10
   \   00000034   0xFB04 0xF400      MUL      R4,R4,R0
   \   00000038   0x4423             ADD      R3,R3,R4
   \   0000003A   0x7A1B             LDRB     R3,[R3, #+8]
   \   0000003C   0xEB02 0x0283      ADD      R2,R2,R3, LSL #+2
   \   00000040   0x0011             MOVS     R1,R2
    226            }
    227            
    228            /* Clear the bit corresponding to eLED_ */
    229          	*pu32ClearAddress = Led_au32BitPositions[(u8)eLED_];
   \                     ??LedOff_1: (+1)
   \   00000042   0x....             LDR.N    R2,??DataTable6_3
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   0000004A   0x600A             STR      R2,[R1, #+0]
    230          
    231            /* Always set the LED back to LED_NORMAL_MODE mode */
    232          	Leds_asLedArray[(u8)eLED_].eMode = LED_NORMAL_MODE;
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x....             LDR.N    R3,??DataTable6
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x240A             MOVS     R4,#+10
   \   00000054   0xFB04 0xF400      MUL      R4,R4,R0
   \   00000058   0x551A             STRB     R2,[R3, R4]
    233            
    234          } /* end LedOff() */
   \   0000005A   0xBC10             POP      {R4}
   \   0000005C   0x4770             BX       LR               ;; return
    235          
    236          
    237          /*----------------------------------------------------------------------------------------------------------------------
    238          Function: LedToggle
    239          
    240          Description:
    241          Toggle the specified LED.
    242          
    243          Requires:
    244            - eLED_ is a valid LED index
    245            - eLED_ *should* be in LED_NORMAL_MODE
    246            - Write access to PIOx_ODSR is enabled
    247          
    248          Promises:
    249            - Requested LED is toggled if the LED is in LED_NORMAL_MODE mode
    250          */

   \                                 In section .text, align 2, keep-with-next
    251          void LedToggle(LedNumberType eLED_)
    252          {
    253            u32 *pu32Address = (u32*)(&(AT91C_BASE_PIOA->PIO_ODSR) + Leds_asLedArray[eLED_].ePort);
   \                     LedToggle: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6_4  ;; 0x400e0c38
   \   00000002   0x....             LDR.N    R2,??DataTable6
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000000C   0x441A             ADD      R2,R2,R3
   \   0000000E   0x7A12             LDRB     R2,[R2, #+8]
   \   00000010   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
    254          
    255            *pu32Address ^= Led_au32BitPositions[ (u8)eLED_ ];
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x....             LDR.N    R3,??DataTable6_3
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xF853 0x3020      LDR      R3,[R3, R0, LSL #+2]
   \   0000001E   0x405A             EORS     R2,R3,R2
   \   00000020   0x600A             STR      R2,[R1, #+0]
    256            
    257          } /* end LedToggle() */
   \   00000022   0x4770             BX       LR               ;; return
    258          
    259          
    260          /*----------------------------------------------------------------------------------------------------------------------
    261          Function: LedPWM
    262          
    263          Description:
    264          Sets an LED to PWM mode
    265          
    266          Requires:
    267            - eLED_ is a valid LED index
    268            - ePwmRate_ is an allowed duty cycle:
    269              LED_PWM_0, LED_PWM_5, LED_PWM_10, ..., LED_PWM_95, LED_PWM_100
    270          
    271          Promises:
    272            - Requested LED is set to PWM mode at the duty cycle specified
    273          */

   \                                 In section .text, align 2, keep-with-next
    274          void LedPWM(LedNumberType eLED_, LedRateType ePwmRate_)
    275          {
   \                     LedPWM: (+1)
   \   00000000   0xB410             PUSH     {R4}
    276          	Leds_asLedArray[(u8)eLED_].eMode = LED_PWM_MODE;
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x....             LDR.N    R3,??DataTable6
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x240A             MOVS     R4,#+10
   \   0000000A   0xFB04 0xF400      MUL      R4,R4,R0
   \   0000000E   0x551A             STRB     R2,[R3, R4]
    277          	Leds_asLedArray[(u8)eLED_].eRate = ePwmRate_;
   \   00000010   0x....             LDR.N    R2,??DataTable6
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x230A             MOVS     R3,#+10
   \   00000016   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000001A   0x441A             ADD      R2,R2,R3
   \   0000001C   0x8051             STRH     R1,[R2, #+2]
    278          	Leds_asLedArray[(u8)eLED_].u16Count = (u16)ePwmRate_;
   \   0000001E   0x....             LDR.N    R2,??DataTable6
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x230A             MOVS     R3,#+10
   \   00000024   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000028   0x441A             ADD      R2,R2,R3
   \   0000002A   0x8091             STRH     R1,[R2, #+4]
    279            Leds_asLedArray[(u8)eLED_].eCurrentDuty = LED_PWM_DUTY_HIGH;
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x....             LDR.N    R3,??DataTable6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x240A             MOVS     R4,#+10
   \   00000034   0xFB04 0xF400      MUL      R4,R4,R0
   \   00000038   0x4423             ADD      R3,R3,R4
   \   0000003A   0x719A             STRB     R2,[R3, #+6]
    280          
    281          } /* end LedPWM() */
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    282          
    283          
    284          /*----------------------------------------------------------------------------------------------------------------------
    285          Function: LedBlink
    286          
    287          Description:
    288          Sets an LED to BLINK mode.
    289          
    290          Requires:
    291            - eLED_ is a valid LED index
    292            - eBlinkRate_ is an allowed frequency:
    293              LED_0_5HZ, LED_1HZ, LED_2HZ, LED_4HZ, LED_8HZ
    294          
    295          Promises:
    296            - Requested LED is set to BLINK mode at the rate specified
    297          */

   \                                 In section .text, align 2, keep-with-next
    298          void LedBlink(LedNumberType eLED_, LedRateType eBlinkRate_)
    299          {
   \                     LedBlink: (+1)
   \   00000000   0xB410             PUSH     {R4}
    300          	Leds_asLedArray[(u8)eLED_].eMode = LED_BLINK_MODE;
   \   00000002   0x2202             MOVS     R2,#+2
   \   00000004   0x....             LDR.N    R3,??DataTable6
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x240A             MOVS     R4,#+10
   \   0000000A   0xFB04 0xF400      MUL      R4,R4,R0
   \   0000000E   0x551A             STRB     R2,[R3, R4]
    301          	Leds_asLedArray[(u8)eLED_].eRate = eBlinkRate_;
   \   00000010   0x....             LDR.N    R2,??DataTable6
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x230A             MOVS     R3,#+10
   \   00000016   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000001A   0x441A             ADD      R2,R2,R3
   \   0000001C   0x8051             STRH     R1,[R2, #+2]
    302          	Leds_asLedArray[(u8)eLED_].u16Count = eBlinkRate_;
   \   0000001E   0x....             LDR.N    R2,??DataTable6
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x230A             MOVS     R3,#+10
   \   00000024   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000028   0x441A             ADD      R2,R2,R3
   \   0000002A   0x8091             STRH     R1,[R2, #+4]
    303          
    304          } /* end LedBlink() */
   \   0000002C   0xBC10             POP      {R4}
   \   0000002E   0x4770             BX       LR               ;; return
    305          
    306          
    307          /*--------------------------------------------------------------------------------------------------------------------*/
    308          /* Protected functions */
    309          /*--------------------------------------------------------------------------------------------------------------------*/
    310          
    311          /*----------------------------------------------------------------------------------------------------------------------
    312          Function: LedInitialize
    313          
    314          Description:
    315          Initialization of LED system paramters and visual LED check.
    316          
    317          Requires:
    318            - G_u32SystemTime1ms ticking
    319            - All LEDs already initialized to LED_NORMAL_MODE mode ON
    320          
    321          Promises:
    322            - All LEDs in LED_NORMAL_MODE mode with OFF
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          void LedInitialize(void)
    325          {
   \                     LedInitialize: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
    326            u32 u32Timer;
    327            u8  u8Index;
    328          
    329            u32 u32Buzzer1Frequency = 4000;
   \   00000006   0xF44F 0x657A      MOV      R5,#+4000
    330            u32 u32Buzzer2Frequency = 500;
   \   0000000A   0xF44F 0x76FA      MOV      R6,#+500
    331            u32 u32StepSize = (u32Buzzer1Frequency - u32Buzzer2Frequency) / 20;
   \   0000000E   0x1BA8             SUBS     R0,R5,R6
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0xFBB0 0xF7F1      UDIV     R7,R0,R1
    332          
    333            static u8 au8LedStartupMsg[] = "LED functions ready\n\r";
    334          
    335          #if MPGL2
    336            /* Test code for checking LEDs */
    337          #if 0
    338            LedOn(RED0);
    339            LedOn(RED1);
    340            LedOn(RED2);
    341            LedOn(RED3);
    342            LedOn(BLUE0);
    343            LedOn(BLUE1);
    344            LedOn(BLUE2);
    345            LedOn(BLUE3);
    346            LedOn(GREEN0);
    347            LedOn(GREEN1);
    348            LedOn(GREEN2);
    349            LedOn(GREEN3);
    350          #endif
    351          
    352          #endif /* MPGL2 */
    353            
    354            /* Turn all LEDs on full, then fade them out over a few seconds */
    355            for(u8Index = 20; u8Index > 0; u8Index--)
   \   00000016   0x2014             MOVS     R0,#+20
   \   00000018   0x0004             MOVS     R4,R0
   \                     ??LedInitialize_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD030             BEQ.N    ??LedInitialize_1
    356            {
    357          #ifdef STARTUP_SOUND
    358              /* Configure Buzzers to provide some audio during start up */
    359              PWMAudioSetFrequency(BUZZER1, u32Buzzer1Frequency);
    360              PWMAudioOn(BUZZER1);
    361          #ifdef  EIE1
    362              PWMAudioSetFrequency(BUZZER2, u32Buzzer2Frequency);
    363              PWMAudioOn(BUZZER2);
    364          #endif /* EIE1 */
    365          #endif /* STARTUP_SOUND */
    366              
    367              /* Spend a little bit of time in each level of intensity */
    368              for(u16 j = 20; j > 0; j--)
   \   00000020   0xF05F 0x0814      MOVS     R8,#+20
   \                     ??LedInitialize_2: (+1)
   \   00000024   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD00D             BEQ.N    ??LedInitialize_3
    369              {
    370                u32Timer = G_u32SystemTime1ms;
   \   0000002E   0x....             LDR.N    R0,??DataTable6_5
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x9000             STR      R0,[SP, #+0]
    371                while( !IsTimeUp(&u32Timer, 1) );
   \                     ??LedInitialize_4: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       IsTimeUp
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD0F9             BEQ.N    ??LedInitialize_4
    372                LedUpdate();
   \   00000040   0x.... 0x....      BL       LedUpdate
    373              }
   \   00000044   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000048   0xE7EC             B.N      ??LedInitialize_2
    374              /* Pause for a bit on the first iteration to show the LEDs on for little while */
    375              if(u8Index == 20)
   \                     ??LedInitialize_3: (+1)
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x2C14             CMP      R4,#+20
   \   0000004E   0xD105             BNE.N    ??LedInitialize_5
    376              {
    377                while( !IsTimeUp(&u32Timer, 200) );
   \                     ??LedInitialize_6: (+1)
   \   00000050   0x21C8             MOVS     R1,#+200
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       IsTimeUp
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD0F9             BEQ.N    ??LedInitialize_6
    378              }
    379              
    380              /* Set the LED intensity for the next iteration */
    381              for(u8 j = 0; j < TOTAL_LEDS; j++)
   \                     ??LedInitialize_5: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??LedInitialize_7: (+1)
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x280B             CMP      R0,#+11
   \   00000062   0xDA0A             BGE.N    ??LedInitialize_8
    382              {
    383                Leds_asLedArray[j].eRate = (LedRateType)(u8Index - 1);
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0x1E61             SUBS     R1,R4,#+1
   \   00000068   0x....             LDR.N    R2,??DataTable6
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x230A             MOVS     R3,#+10
   \   0000006E   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000072   0x441A             ADD      R2,R2,R3
   \   00000074   0x8051             STRH     R1,[R2, #+2]
    384              }
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0xE7F1             B.N      ??LedInitialize_7
    385              
    386              /* Set the buzzer frequency for the next iteration */
    387              u32Buzzer1Frequency -= u32StepSize;
   \                     ??LedInitialize_8: (+1)
   \   0000007A   0x1BED             SUBS     R5,R5,R7
    388              u32Buzzer2Frequency += u32StepSize;
   \   0000007C   0x19BE             ADDS     R6,R7,R6
    389            }
   \   0000007E   0x1E64             SUBS     R4,R4,#+1
   \   00000080   0xE7CB             B.N      ??LedInitialize_0
    390          
    391            /* Final update to set last state, hold for a short period */
    392            LedUpdate();
   \                     ??LedInitialize_1: (+1)
   \   00000082   0x.... 0x....      BL       LedUpdate
    393            while( !IsTimeUp(&u32Timer, 200) );
   \                     ??LedInitialize_9: (+1)
   \   00000086   0x21C8             MOVS     R1,#+200
   \   00000088   0x4668             MOV      R0,SP
   \   0000008A   0x.... 0x....      BL       IsTimeUp
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD0F9             BEQ.N    ??LedInitialize_9
    394            
    395          #ifdef STARTUP_SOUND
    396            /* Turn off the buzzers */
    397            PWMAudioOff(BUZZER1);
    398          #ifdef  EIE1
    399            PWMAudioOff(BUZZER2);
    400          #endif /* EIE1 */
    401            
    402          #endif /* STARTUP_SOUND */
    403          
    404           
    405            /* The discrete LEDs are off and the backlight is on (white) -- this
    406            is how we will exit the LED init.  But should we set all the LEDs to
    407            NORMAL mode?  This would solve the LedToggle() problem described in 
    408            LedBasic module.  So if the code below is added, then the module
    409            information must be updated. */
    410          #if 0 
    411            for(u8 i = 0; i < TOTAL_LEDS; i++)
    412            {
    413              Leds_asLedArray[i].eMode = LED_NORMAL_MODE;
    414            }
    415          #endif
    416          
    417          #ifdef EIE1
    418            LedOn(LCD_RED);
   \   00000092   0x2008             MOVS     R0,#+8
   \   00000094   0x.... 0x....      BL       LedOn
    419            LedOn(LCD_GREEN);
   \   00000098   0x2009             MOVS     R0,#+9
   \   0000009A   0x.... 0x....      BL       LedOn
    420            LedOn(LCD_BLUE);
   \   0000009E   0x200A             MOVS     R0,#+10
   \   000000A0   0x.... 0x....      BL       LedOn
    421          #endif
    422            
    423          #ifdef MPGL2
    424            LedOn(LCD_BL);
    425          #endif
    426          
    427            /* Final setup and report that LED system is ready */
    428            G_u32ApplicationFlags |= _APPLICATION_FLAGS_LED;
   \   000000A4   0x....             LDR.N    R0,??DataTable6_6
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000AC   0x....             LDR.N    R1,??DataTable6_6
   \   000000AE   0x6008             STR      R0,[R1, #+0]
    429            DebugPrintf(au8LedStartupMsg);
   \   000000B0   0x....             LDR.N    R0,??DataTable6_7
   \   000000B2   0x.... 0x....      BL       DebugPrintf
    430            
    431          } /* end LedInitialize() */
   \   000000B6   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .data, align 4
   \                     `LedInitialize::au8LedStartupMsg`:
   \   00000000   0x4C 0x45          DC8 "LED functions ready\012\015"
   \              0x44 0x20    
   \              0x66 0x75    
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
    432          
    433          
    434          /*--------------------------------------------------------------------------------------------------------------------*/
    435          /* Private functions */
    436          /*--------------------------------------------------------------------------------------------------------------------*/
    437          
    438          /*----------------------------------------------------------------------------------------------------------------------
    439          Function: LedUpdate
    440          
    441          Description:
    442          Update all LEDs for the current cycle.
    443          
    444          Requires:
    445           - G_u32SystemTime1ms is counting
    446          
    447          Promises:
    448             - All LEDs updated based on their counters
    449          */

   \                                 In section .text, align 2, keep-with-next
    450          void LedUpdate(void)
    451          {
   \                     LedUpdate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    452          	/* Loop through each LED */
    453            for(u8 i = 0; i < TOTAL_LEDS; i++)
   \   00000002   0x2400             MOVS     R4,#+0
   \                     ??LedUpdate_0: (+1)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C0B             CMP      R4,#+11
   \   00000008   0xF280 0x80BC      BGE.W    ??LedUpdate_1
    454            {
    455              /* Check if LED is PWMing */
    456              if(Leds_asLedArray[(LedNumberType)i].eMode == LED_PWM_MODE)
   \   0000000C   0x....             LDR.N    R0,??DataTable6
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x210A             MOVS     R1,#+10
   \   00000012   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000016   0x5C40             LDRB     R0,[R0, R1]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xF040 0x807F      BNE.W    ??LedUpdate_2
    457              {
    458                /* Handle special case of 0% duty cycle */
    459                if( Leds_asLedArray[i].eRate == LED_PWM_0 )
   \   0000001E   0x....             LDR.N    R0,??DataTable6
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x210A             MOVS     R1,#+10
   \   00000024   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000028   0x4408             ADD      R0,R0,R1
   \   0000002A   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD104             BNE.N    ??LedUpdate_3
    460                {
    461                  LedOff( (LedNumberType)i );
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       LedOff
   \   0000003A   0xE067             B.N      ??LedUpdate_4
    462                }
    463                
    464                /* Handle special case of 100% duty cycle */
    465                else if( Leds_asLedArray[i].eRate == LED_PWM_100 )
   \                     ??LedUpdate_3: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable6
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x210A             MOVS     R1,#+10
   \   00000042   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000046   0x4408             ADD      R0,R0,R1
   \   00000048   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   0000004C   0x2814             CMP      R0,#+20
   \   0000004E   0xD104             BNE.N    ??LedUpdate_5
    466                {
    467                  LedOn( (LedNumberType)i );
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x.... 0x....      BL       LedOn
   \   00000058   0xE058             B.N      ??LedUpdate_4
    468                }
    469            
    470                /* Otherwise, regular PWM: decrement counter; toggle and reload if counter reaches 0 */
    471                else
    472                {
    473                  if(--Leds_asLedArray[(LedNumberType)i].u16Count == 0)
   \                     ??LedUpdate_5: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable6
   \   0000005C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005E   0x210A             MOVS     R1,#+10
   \   00000060   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000064   0x4408             ADD      R0,R0,R1
   \   00000066   0x8880             LDRH     R0,[R0, #+4]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x....             LDR.N    R1,??DataTable6
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x220A             MOVS     R2,#+10
   \   00000070   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000074   0x4411             ADD      R1,R1,R2
   \   00000076   0x8088             STRH     R0,[R1, #+4]
   \   00000078   0x....             LDR.N    R0,??DataTable6
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x210A             MOVS     R1,#+10
   \   0000007E   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000082   0x4408             ADD      R0,R0,R1
   \   00000084   0x8880             LDRH     R0,[R0, #+4]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD140             BNE.N    ??LedUpdate_4
    474                  {
    475                    if(Leds_asLedArray[(LedNumberType)i].eCurrentDuty == LED_PWM_DUTY_HIGH)
   \   0000008A   0x....             LDR.N    R0,??DataTable6
   \   0000008C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008E   0x210A             MOVS     R1,#+10
   \   00000090   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000094   0x4408             ADD      R0,R0,R1
   \   00000096   0x7980             LDRB     R0,[R0, #+6]
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD11D             BNE.N    ??LedUpdate_6
    476                    {
    477                      /* Turn the LED off and update the counters for the next cycle */
    478                      LedOff( (LedNumberType)i );
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x.... 0x....      BL       LedOff
    479                      Leds_asLedArray[(LedNumberType)i].u16Count = LED_PWM_PERIOD - Leds_asLedArray[(LedNumberType)i].eRate;
   \   000000A4   0x....             LDR.N    R0,??DataTable6
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x210A             MOVS     R1,#+10
   \   000000AA   0xFB01 0xF104      MUL      R1,R1,R4
   \   000000AE   0x4408             ADD      R0,R0,R1
   \   000000B0   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000B4   0xF1D0 0x0014      RSBS     R0,R0,#+20
   \   000000B8   0x....             LDR.N    R1,??DataTable6
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x220A             MOVS     R2,#+10
   \   000000BE   0xFB02 0xF204      MUL      R2,R2,R4
   \   000000C2   0x4411             ADD      R1,R1,R2
   \   000000C4   0x8088             STRH     R0,[R1, #+4]
    480                      Leds_asLedArray[(LedNumberType)i].eCurrentDuty = LED_PWM_DUTY_LOW;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x....             LDR.N    R1,??DataTable6
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0x220A             MOVS     R2,#+10
   \   000000CE   0xFB02 0xF204      MUL      R2,R2,R4
   \   000000D2   0x4411             ADD      R1,R1,R2
   \   000000D4   0x7188             STRB     R0,[R1, #+6]
   \   000000D6   0xE019             B.N      ??LedUpdate_4
    481                    }
    482                    else
    483                    {
    484                      /* Turn the LED on and update the counters for the next cycle */
    485                      LedOn( (LedNumberType)i );
   \                     ??LedUpdate_6: (+1)
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0x.... 0x....      BL       LedOn
    486                      Leds_asLedArray[i].u16Count = Leds_asLedArray[i].eRate;
   \   000000E0   0x....             LDR.N    R0,??DataTable6
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0x210A             MOVS     R1,#+10
   \   000000E6   0xFB01 0xF104      MUL      R1,R1,R4
   \   000000EA   0x4408             ADD      R0,R0,R1
   \   000000EC   0x8840             LDRH     R0,[R0, #+2]
   \   000000EE   0x....             LDR.N    R1,??DataTable6
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0x220A             MOVS     R2,#+10
   \   000000F4   0xFB02 0xF204      MUL      R2,R2,R4
   \   000000F8   0x4411             ADD      R1,R1,R2
   \   000000FA   0x8088             STRH     R0,[R1, #+4]
    487                      Leds_asLedArray[i].eCurrentDuty = LED_PWM_DUTY_HIGH;
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x....             LDR.N    R1,??DataTable6
   \   00000100   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000102   0x220A             MOVS     R2,#+10
   \   00000104   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000108   0x4411             ADD      R1,R1,R2
   \   0000010A   0x7188             STRB     R0,[R1, #+6]
    488                    }
    489                  }
    490                }
    491          
    492                /* Set the LED back to PWM mode since LedOff and LedOn set it to normal mode */
    493               	Leds_asLedArray[(LedNumberType)i].eMode = LED_PWM_MODE;
   \                     ??LedUpdate_4: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x....             LDR.N    R1,??DataTable6
   \   00000110   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000112   0x220A             MOVS     R2,#+10
   \   00000114   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000118   0x5488             STRB     R0,[R1, R2]
   \   0000011A   0xE031             B.N      ??LedUpdate_7
    494                
    495              } /* end if PWM mode */
    496              
    497              /* LED is in LED_BLINK_MODE mode */
    498              else if(Leds_asLedArray[(LedNumberType)i].eMode == LED_BLINK_MODE)
   \                     ??LedUpdate_2: (+1)
   \   0000011C   0x....             LDR.N    R0,??DataTable6
   \   0000011E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000120   0x210A             MOVS     R1,#+10
   \   00000122   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000126   0x5C40             LDRB     R0,[R0, R1]
   \   00000128   0x2802             CMP      R0,#+2
   \   0000012A   0xD129             BNE.N    ??LedUpdate_7
    499              {
    500                /* Decrement counter; toggle and reload if counter reaches 0 */
    501                if( --Leds_asLedArray[(LedNumberType)i].u16Count == 0)
   \   0000012C   0x....             LDR.N    R0,??DataTable6
   \   0000012E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000130   0x210A             MOVS     R1,#+10
   \   00000132   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000136   0x4408             ADD      R0,R0,R1
   \   00000138   0x8880             LDRH     R0,[R0, #+4]
   \   0000013A   0x1E40             SUBS     R0,R0,#+1
   \   0000013C   0x....             LDR.N    R1,??DataTable6
   \   0000013E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000140   0x220A             MOVS     R2,#+10
   \   00000142   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000146   0x4411             ADD      R1,R1,R2
   \   00000148   0x8088             STRH     R0,[R1, #+4]
   \   0000014A   0x....             LDR.N    R0,??DataTable6
   \   0000014C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014E   0x210A             MOVS     R1,#+10
   \   00000150   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000154   0x4408             ADD      R0,R0,R1
   \   00000156   0x8880             LDRH     R0,[R0, #+4]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD111             BNE.N    ??LedUpdate_7
    502                {
    503                  LedToggle( (LedNumberType)i );
   \   0000015C   0x0020             MOVS     R0,R4
   \   0000015E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000160   0x.... 0x....      BL       LedToggle
    504                  Leds_asLedArray[(LedNumberType)i].u16Count = Leds_asLedArray[(LedNumberType)i].eRate;
   \   00000164   0x....             LDR.N    R0,??DataTable6
   \   00000166   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000168   0x210A             MOVS     R1,#+10
   \   0000016A   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000016E   0x4408             ADD      R0,R0,R1
   \   00000170   0x8840             LDRH     R0,[R0, #+2]
   \   00000172   0x....             LDR.N    R1,??DataTable6
   \   00000174   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000176   0x220A             MOVS     R2,#+10
   \   00000178   0xFB02 0xF204      MUL      R2,R2,R4
   \   0000017C   0x4411             ADD      R1,R1,R2
   \   0000017E   0x8088             STRH     R0,[R1, #+4]
    505                }
    506              }
    507            } /* end for */
   \                     ??LedUpdate_7: (+1)
   \   00000180   0x1C64             ADDS     R4,R4,#+1
   \   00000182   0xE73F             B.N      ??LedUpdate_0
    508          } /* end LedUpdate() */
   \                     ??LedUpdate_1: (+1)
   \   00000184   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     Leds_asLedArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x400E0C30         DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x400E0C34         DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     Led_au32BitPositions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x400E0C38         DC32     0x400e0c38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     `LedInitialize::au8LedStartupMsg`
    509          
    510          
    511          
    512          
    513          /*--------------------------------------------------------------------------------------------------------------------*/
    514          /* End of File */
    515          /*--------------------------------------------------------------------------------------------------------------------*/
    516          
    517          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   LedBlink
      32   LedInitialize
        32   -> DebugPrintf
        32   -> IsTimeUp
        32   -> LedOn
        32   -> LedUpdate
       4   LedOff
       4   LedOn
       4   LedPWM
       0   LedToggle
       8   LedUpdate
         8   -> LedOff
         8   -> LedOn
         8   -> LedToggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
      48  LedBlink
     186  LedInitialize
      94  LedOff
     104  LedOn
      64  LedPWM
      36  LedToggle
     390  LedUpdate
      44  Led_au32BitPositions
     112  Leds_asLedArray
      24  au8LedStartupMsg

 
 180 bytes in section .data
 954 bytes in section .text
 
 954 bytes of CODE memory
 180 bytes of DATA memory

Errors: none
Warnings: none
