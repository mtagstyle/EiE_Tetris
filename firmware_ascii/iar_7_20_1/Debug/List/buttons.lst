###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       26/Jun/2018  22:49:19
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\buttons.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\buttons.c" -D
#        EIE1 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List" -o
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\bsp\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\List\buttons.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_ascii\iar_7_20_1\Debug\Obj\buttons.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\buttons.c
      1          /***********************************************************************************************************************
      2          File: buttons.c                                                                
      3          
      4          Description:
      5          Button functions and state machine.  The application handles all debouncing and glitch filtering.
      6          
      7          ------------------------------------------------------------------------------------------------------------------------
      8          API:
      9          Types:
     10          EIE1: The argument u32Button_ is either BUTTON0, BUTTON1, BUTTON2, or BUTTON3.  
     11          MPG2: The argument u32Button_ is either BUTTON0 or BUTTON1.  
     12          
     13          Public:
     14          bool IsButtonPressed(u32 u32Button_)
     15          Returns TRUE if a particular button is currently pressed (and debounced).
     16          
     17          bool WasButtonPressed(u32 u32Button_)
     18          Returns TRUE if a particular button was pressed since last time it was checked even if it is no longer pressed.
     19          ButtonAcknowledge is typically called immediately after WasButtonPressed() returns TRUE to clear the button
     20          pressed state.
     21          
     22          void ButtonAcknowledge(u32 u32Button_)
     23          Clears the New Press state of a button -- generally always called after WasButtonPressed() returns TRUE.
     24          
     25          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
     26          Returns TRUE if a button has been held for u32ButtonHeldTime_ time in milliseconds.
     27          
     28          Protected:
     29          void ButtonInitialize(void)
     30          Configures the button system for the product including enabling button GPIO interrupts.  
     31          
     32          u32 GetButtonBitLocation(u8 u8Button_, ButtonPortType ePort_)
     33          Returns the location of the button within its port (should be required only for interrupt service routines).  
     34          
     35          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     36          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     37          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     38          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     39          
     40          ***********************************************************************************************************************/
     41          
     42          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable10  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable10_1  ;; 0xe000e280
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     43          
     44          /***********************************************************************************************************************
     45          Global variable definitions with scope across entire project.
     46          All Global variable names shall start with "G_<type>Button"
     47          ***********************************************************************************************************************/
     48          /* New variables */

   \                                 In section .bss, align 4
     49          volatile bool G_abButtonDebounceActive[TOTAL_BUTTONS];           /* Flags for buttons being debounced */
   \                     G_abButtonDebounceActive:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     50          volatile u32 G_au32ButtonDebounceTimeStart[TOTAL_BUTTONS];       /* Button debounce start time */
   \                     G_au32ButtonDebounceTimeStart:
   \   00000000                      DS8 16
     51          
     52          /*--------------------------------------------------------------------------------------------------------------------*/
     53          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     54          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     55          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     56          
     57          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     58          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     59          
     60          
     61          /***********************************************************************************************************************
     62          Global variable definitions with scope limited to this local application.
     63          Variable names shall start with "Button_" and be declared as static.
     64          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     65          static fnCode_type Button_pfnStateMachine;                  /* The Button application state machine function pointer */
   \                     Button_pfnStateMachine:
   \   00000000                      DS8 4
     66          

   \                                 In section .bss, align 4
     67          static ButtonStateType Button_aeCurrentState[TOTAL_BUTTONS];/* Current pressed state of button */
   \                     Button_aeCurrentState:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     68          static ButtonStateType Button_aeNewState[TOTAL_BUTTONS];    /* New (pending) pressed state of button */
   \                     Button_aeNewState:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     69          static u32 Button_au32HoldTimeStart[TOTAL_BUTTONS];         /* System 1ms time when a button press started */
   \                     Button_au32HoldTimeStart:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     70          static bool Button_abNewPress[TOTAL_BUTTONS];               /* Flags to indicate a button was pressed */    
   \                     Button_abNewPress:
   \   00000000                      DS8 4
     71          
     72          
     73          /************ %BUTTON% EDIT BOARD-SPECIFIC GPIO DEFINITIONS BELOW ***************/
     74          /* Add all of the GPIO pin names for the buttons in the system.  
     75          The order of the definitions below must match the order of the definitions provided in configuration.h */ 
     76          
     77          #ifdef EIE1

   \                                 In section .rodata, align 4
     78          static const u32 Button_au32ButtonPins[TOTAL_BUTTONS] = 
   \                     Button_au32ButtonPins:
   \   00000000   0x00020000         DC32 131072, 1, 2, 4
   \              0x00000001   
   \              0x00000002   
   \              0x00000004   
     79          {
     80            PA_17_BUTTON0, PB_00_BUTTON1, PB_01_BUTTON2, PB_02_BUTTON3
     81          };
     82          
     83          /* Control array for all buttons in system initialized for ButtonInitialize().  Array values correspond to ButtonConfigType fields: 
     84               eActiveState       ePort                   */

   \                                 In section .data, align 4
     85          static ButtonConfigType Buttons_asArray[TOTAL_BUTTONS] = 
   \                     Buttons_asArray:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 128, 0, 128, 0, 128
   \              0x00 0x80    
   \              0x00 0x80    
   \              0x00 0x80    
     86          {{BUTTON_ACTIVE_LOW, BUTTON_PORTA}, /* BUTTON0  */
     87           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON1  */
     88           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON2  */
     89           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON3  */
     90          };   
     91          #endif /* EIE1 */
     92          
     93          #ifdef MPGL2
     94          static const u32 Button_au32ButtonPins[TOTAL_BUTTONS] = 
     95          {
     96            PA_17_BUTTON0, PB_00_BUTTON1
     97          };
     98          
     99          /* Control array for all buttons in system initialized for ButtonInitialize().  Array values correspond to ButtonConfigType fields: 
    100               eActiveState       ePort                   */
    101          static ButtonConfigType Buttons_asArray[TOTAL_BUTTONS] = 
    102          {{BUTTON_ACTIVE_LOW, BUTTON_PORTA}, /* BUTTON0  */
    103           {BUTTON_ACTIVE_LOW, BUTTON_PORTB} /* BUTTON1  */
    104          };   
    105          #endif /* MPGL2 */
    106          
    107          /************ EDIT BOARD-SPECIFIC GPIO DEFINITIONS ABOVE ***************/
    108          
    109          
    110          /***********************************************************************************************************************
    111          Function Definitions
    112          ***********************************************************************************************************************/
    113          /*--------------------------------------------------------------------------------------------------------------------*/
    114          /* Public Functions */
    115          /*--------------------------------------------------------------------------------------------------------------------*/
    116          
    117          /*----------------------------------------------------------------------------------------------------------------------
    118          Function: IsButtonPressed
    119          
    120          Description:
    121          Determine if a particular button is currently pressed at this moment in time.
    122          The button must still be pressed at the time of this inquiry for the function
    123          to return TRUE.
    124          
    125          Requires:
    126            - u32Button_ is a valid button index
    127            - Button_aeCurrentState[u32Button_] is a valid index
    128           
    129          Promises:
    130            - Returns TRUE if Button_aeCurrentState[u32Button_] is pressed; otherwise returns FALSE
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          bool IsButtonPressed(u32 u32Button_)
    133          {
   \                     IsButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    134            if( Button_aeCurrentState[u32Button_] == PRESSED)
   \   00000002   0x....             LDR.N    R0,??DataTable10_2
   \   00000004   0x5C40             LDRB     R0,[R0, R1]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??IsButtonPressed_0
    135            {
    136              return(TRUE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??IsButtonPressed_1
    137            }
    138            else
    139            {
    140              return(FALSE);
   \                     ??IsButtonPressed_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??IsButtonPressed_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    141            }
    142          
    143          } /* end IsButtonPressed() */
    144          
    145          
    146          /*----------------------------------------------------------------------------------------------------------------------
    147          Function: WasButtonPressed
    148          
    149          Description:
    150          Determines if a particular button was pressed since last time it was checked. 
    151          The button may or may not still be pressed when this inquiry is made.  Mulitple
    152          button presses are not tracked.  The user should call ButtonAcknowledge immediately
    153          following this function to clear the state.
    154          
    155          Requires:
    156            - u32 u32Button_ is a valid button index
    157            - Button_aeCurrentState[u32Button_] is valid
    158           
    159          Promises:
    160            - Returns TRUE if Button_abNewPress[u32Button_] is TRUE; other wise returns FALSE
    161          */

   \                                 In section .text, align 2, keep-with-next
    162          bool WasButtonPressed(u32 u32Button_)
    163          {
   \                     WasButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    164            if( Button_abNewPress[u32Button_] == TRUE)
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x5C40             LDRB     R0,[R0, R1]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??WasButtonPressed_0
    165            {
    166              return(TRUE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??WasButtonPressed_1
    167            }
    168            else
    169            {
    170              return(FALSE);
   \                     ??WasButtonPressed_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??WasButtonPressed_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    171            }
    172          
    173          } /* end WasButtonPressed() */
    174          
    175          
    176          /*----------------------------------------------------------------------------------------------------------------------
    177          Function: ButtonAcknowledge
    178          
    179          Description:
    180          Clears the New Press state of a button.
    181          
    182          Requires:
    183            - u32Button_ is a valid button index
    184           
    185          Promises:
    186            - The flag at Button_abNewPress[u32Button_] is set to FALSE
    187          */

   \                                 In section .text, align 2, keep-with-next
    188          void ButtonAcknowledge(u32 u32Button_)
    189          {
    190            Button_abNewPress[u32Button_] = FALSE;
   \                     ButtonAcknowledge: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable10_3
   \   00000004   0x5411             STRB     R1,[R2, R0]
    191          
    192          } /* end ButtonAcknowledge() */
   \   00000006   0x4770             BX       LR               ;; return
    193          
    194          
    195          /*----------------------------------------------------------------------------------------------------------------------
    196          Function: IsButtonHeld
    197          
    198          Description:
    199          Queries to see if a button has been held for a certain time.  The button
    200          must still be pressed when this function is called if it is to return TRUE.
    201          
    202          Requires:
    203            - u32Button_ is a valid button index
    204            - u32ButtonHeldTime is a time in ms 
    205           
    206          Promises:
    207            - Returns TRUE if eButton_ has been held longer than u32ButtonHeldTime_
    208          */

   \                                 In section .text, align 2, keep-with-next
    209          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
    210          {
   \                     IsButtonHeld: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    211           if( IsButtonPressed(u32Button_) && 
    212               IsTimeUp(&Button_au32HoldTimeStart[u32Button_], u32ButtonHeldTime_ ) )
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       IsButtonPressed
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??IsButtonHeld_0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x....             LDR.N    R0,??DataTable10_4
   \   00000014   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000018   0x.... 0x....      BL       IsTimeUp
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??IsButtonHeld_0
    213           {
    214             return(TRUE);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??IsButtonHeld_1
    215           }
    216           else
    217           {
    218             return(FALSE);
   \                     ??IsButtonHeld_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??IsButtonHeld_1: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    219           }
    220          
    221          } /* end IsButtonHeld() */
    222          
    223          
    224          /*--------------------------------------------------------------------------------------------------------------------*/
    225          /* Protected Functions */
    226          /*--------------------------------------------------------------------------------------------------------------------*/
    227          
    228          /*----------------------------------------------------------------------------------------------------------------------
    229          Function: ButtonInitialize
    230          
    231          Description:
    232          Configures the button system for the product including enabling button GPIO 
    233          interrupts. For all buttons, the default "Input Change Interrupt" is sufficient
    234          for providing the functionality needed.
    235          
    236          Requires:
    237            - GPIO configuration is already complete for all button inputs
    238            - Button interrupt initializations and handler functions are ready
    239           
    240          Promises:
    241            - G_abButtonDebounceActive, Button_aeCurrentState and Button_aeNewState 
    242              are initialized
    243            - The button state machine is initialized to Idle
    244          */

   \                                 In section .text, align 2, keep-with-next
    245          void ButtonInitialize(void)
    246          {
   \                     ButtonInitialize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    247            u32 u32PortAInterruptMask = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    248            u32 u32PortBInterruptMask = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    249            static u8 au8ButtonStartupMsg[] = "Button task ready\n\r";
    250            
    251            /* Setup default data for all of the buttons in the system */
    252            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000006   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_0: (+1)
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xDA0D             BGE.N    ??ButtonInitialize_1
    253            {
    254              G_abButtonDebounceActive[i] = FALSE;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x....             LDR.N    R2,??DataTable10_5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5411             STRB     R1,[R2, R0]
    255              Button_aeCurrentState[i]    = RELEASED;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x....             LDR.N    R2,??DataTable10_2
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x5411             STRB     R1,[R2, R0]
    256              Button_aeNewState[i]        = RELEASED;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x....             LDR.N    R2,??DataTable10_6
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x5411             STRB     R1,[R2, R0]
    257            }
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0xE7EE             B.N      ??ButtonInitialize_0
    258            
    259            /* Create masks based on any buttons in the system.  It's ok to have an empty mask. */
    260            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \                     ??ButtonInitialize_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_2: (+1)
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2804             CMP      R0,#+4
   \   00000030   0xDA1A             BGE.N    ??ButtonInitialize_3
    261            {
    262              if(Buttons_asArray[i].ePort == BUTTON_PORTA)
   \   00000032   0x....             LDR.N    R1,??DataTable10_7
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
   \   0000003A   0x7849             LDRB     R1,[R1, #+1]
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD105             BNE.N    ??ButtonInitialize_4
    263              {
    264                u32PortAInterruptMask |= Button_au32ButtonPins[i];
   \   00000040   0x....             LDR.N    R1,??DataTable10_8
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000048   0x430C             ORRS     R4,R1,R4
   \   0000004A   0xE00B             B.N      ??ButtonInitialize_5
    265              }
    266              else if(Buttons_asArray[i].ePort == BUTTON_PORTB)
   \                     ??ButtonInitialize_4: (+1)
   \   0000004C   0x....             LDR.N    R1,??DataTable10_7
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
   \   00000054   0x7849             LDRB     R1,[R1, #+1]
   \   00000056   0x2980             CMP      R1,#+128
   \   00000058   0xD104             BNE.N    ??ButtonInitialize_5
    267              {
    268                u32PortBInterruptMask |= Button_au32ButtonPins[i];
   \   0000005A   0x....             LDR.N    R1,??DataTable10_8
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000062   0x430D             ORRS     R5,R1,R5
    269              }
    270            }
   \                     ??ButtonInitialize_5: (+1)
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0xE7E1             B.N      ??ButtonInitialize_2
    271          
    272            /* Enable PIO interrupts */
    273            AT91C_BASE_PIOA->PIO_IER = u32PortAInterruptMask;
   \                     ??ButtonInitialize_3: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable10_9  ;; 0x400e0c40
   \   0000006A   0x6004             STR      R4,[R0, #+0]
    274            AT91C_BASE_PIOB->PIO_IER = u32PortBInterruptMask;
   \   0000006C   0x....             LDR.N    R0,??DataTable10_10  ;; 0x400e0e40
   \   0000006E   0x6005             STR      R5,[R0, #+0]
    275            
    276            /* Read the ISR register to clear all the current flags */
    277            u32PortAInterruptMask = AT91C_BASE_PIOA->PIO_ISR;
   \   00000070   0x....             LDR.N    R0,??DataTable10_11  ;; 0x400e0c4c
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0004             MOVS     R4,R0
    278            u32PortBInterruptMask = AT91C_BASE_PIOB->PIO_ISR;
   \   00000076   0x....             LDR.N    R0,??DataTable10_12  ;; 0x400e0e4c
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0005             MOVS     R5,R0
    279          
    280            /* Configure the NVIC to ensure the PIOA and PIOB interrupts are active */
    281            NVIC_ClearPendingIRQ(IRQn_PIOA);
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    282            NVIC_ClearPendingIRQ(IRQn_PIOB);
   \   00000082   0x200B             MOVS     R0,#+11
   \   00000084   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    283            NVIC_EnableIRQ(IRQn_PIOA);
   \   00000088   0x200A             MOVS     R0,#+10
   \   0000008A   0x.... 0x....      BL       NVIC_EnableIRQ
    284            NVIC_EnableIRQ(IRQn_PIOB);
   \   0000008E   0x200B             MOVS     R0,#+11
   \   00000090   0x.... 0x....      BL       NVIC_EnableIRQ
    285              
    286            /* Init complete: set function pointer and application flag */
    287            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000094   0x.... 0x....      ADR.W    R0,ButtonSM_Idle
   \   00000098   0x....             LDR.N    R1,??DataTable10_13
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    288            G_u32ApplicationFlags |= _APPLICATION_FLAGS_BUTTON;
   \   0000009C   0x....             LDR.N    R0,??DataTable10_14
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000A4   0x....             LDR.N    R1,??DataTable10_14
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    289            DebugPrintf(au8ButtonStartupMsg);
   \   000000A8   0x....             LDR.N    R0,??DataTable10_15
   \   000000AA   0x.... 0x....      BL       DebugPrintf
    290          
    291          } /* end ButtonInitialize() */
   \   000000AE   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     `ButtonInitialize::au8ButtonStartupMsg`:
   \   00000000   0x42 0x75          DC8 "Button task ready\012\015"
   \              0x74 0x74    
   \              0x6F 0x6E    
   \              0x20 0x74    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    292          
    293          
    294          /*----------------------------------------------------------------------------------------------------------------------
    295          Function ButtonRunActiveState()
    296          
    297          Description:
    298          Selects and runs one iteration of the current state in the state machine.
    299          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    300          may take 1ms / n to execute.
    301          
    302          Requires:
    303            - State machine function pointer points at current state
    304          
    305          Promises:
    306            - Calls the function to pointed by the state machine function pointer
    307          */

   \                                 In section .text, align 2, keep-with-next
    308          void ButtonRunActiveState(void)
    309          {
   \                     ButtonRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    310            Button_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable10_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    311          
    312          } /* end ButtonRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    313          
    314          
    315          /*----------------------------------------------------------------------------------------------------------------------
    316          Function: GetButtonBitLocation
    317          
    318          Description:
    319          Returns the location of the button within its port.  
    320          The GPIO interrupt requires access to this function.
    321          
    322          Requires:
    323            - u8Button_ is a valid ButtonNumberType.
    324            - ePort_ is the port where the button is located
    325          
    326          Promises:
    327            - Returns a value that has a bit set in the corresponding position of u32Button_ on the button's port
    328            - Returns 0 if no match
    329          */

   \                                 In section .text, align 2, keep-with-next
    330          u32 GetButtonBitLocation(u8 u8Button_, ButtonPortType ePort_)
    331          {
   \                     GetButtonBitLocation: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    332            /* Make sure the index is valid */
    333            if(u8Button_ < TOTAL_BUTTONS) 
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A04             CMP      R2,#+4
   \   00000006   0xDA0D             BGE.N    ??GetButtonBitLocation_0
    334            {
    335              /* Index is valid so check that the button exists on the port */
    336              if(Buttons_asArray[u8Button_].ePort == ePort_)
   \   00000008   0x....             LDR.N    R0,??DataTable10_7
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \   00000010   0x7840             LDRB     R0,[R0, #+1]
   \   00000012   0x000B             MOVS     R3,R1
   \   00000014   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000016   0x4298             CMP      R0,R3
   \   00000018   0xD104             BNE.N    ??GetButtonBitLocation_0
    337              {
    338                /* Return the button position if the index is the correct port */
    339                return(Button_au32ButtonPins[u8Button_]);
   \   0000001A   0x....             LDR.N    R0,??DataTable10_8
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000022   0xE000             B.N      ??GetButtonBitLocation_1
    340              }
    341            }
    342            
    343            /* Otherwise return 0 */
    344            return(0);
   \                     ??GetButtonBitLocation_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??GetButtonBitLocation_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    345            
    346          } /* end GetButtonBitLocation() */
    347          
    348          
    349          /*--------------------------------------------------------------------------------------------------------------------*/
    350          /* Private functions */
    351          /*--------------------------------------------------------------------------------------------------------------------*/
    352          
    353          
    354          /***********************************************************************************************************************
    355          State Machine Function Definitions
    356          
    357          The button state machine monitors button activity and manages debouncing and
    358          maintaining the global button states.
    359          ***********************************************************************************************************************/
    360          
    361          /*--------------------------------------------------------------------------------------------------------------------*/
    362          /* Do nothing but wait for a debounce time to start */

   \                                 In section .text, align 4, keep-with-next
    363          static void ButtonSM_Idle(void)                
    364          {
    365            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \                     ButtonSM_Idle: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??ButtonSM_Idle_0: (+1)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2804             CMP      R0,#+4
   \   00000006   0xDA0A             BGE.N    ??ButtonSM_Idle_1
    366            {
    367              if(G_abButtonDebounceActive[i])
   \   00000008   0x....             LDR.N    R1,??DataTable10_5
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x5C09             LDRB     R1,[R1, R0]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD003             BEQ.N    ??ButtonSM_Idle_2
    368              {
    369                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   00000012   0x.... 0x....      ADR.W    R1,ButtonSM_ButtonActive
   \   00000016   0x....             LDR.N    R2,??DataTable10_13
   \   00000018   0x6011             STR      R1,[R2, #+0]
    370              }
    371            }
   \                     ??ButtonSM_Idle_2: (+1)
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xE7F1             B.N      ??ButtonSM_Idle_0
    372            
    373          } /* end ButtonSM_Idle(void) */
   \                     ??ButtonSM_Idle_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    374          
    375          
    376          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    377          static void ButtonSM_ButtonActive(void)         
    378          {
   \                     ButtonSM_ButtonActive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    379            u32 *pu32PortAddress;
    380            u32 *pu32InterruptAddress;
    381          
    382            /* Start by resseting back to Idle in case no buttons are active */
    383            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable10_16
   \   00000004   0x....             LDR.N    R1,??DataTable10_13
   \   00000006   0x6008             STR      R0,[R1, #+0]
    384          
    385            /* Check for buttons that are debouncing */
    386            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000008   0x2600             MOVS     R6,#+0
   \                     ??ButtonSM_ButtonActive_0: (+1)
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x2E04             CMP      R6,#+4
   \   0000000E   0xDA74             BGE.N    ??ButtonSM_ButtonActive_1
    387            {
    388              /* Load address offsets for the current button */
    389              pu32PortAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_PDSR) + Buttons_asArray[i].ePort);
   \   00000010   0x....             LDR.N    R0,??DataTable10_17  ;; 0x400e0c3c
   \   00000012   0x....             LDR.N    R1,??DataTable10_7
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0xEB01 0x0146      ADD      R1,R1,R6, LSL #+1
   \   0000001A   0x7849             LDRB     R1,[R1, #+1]
   \   0000001C   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000020   0x0004             MOVS     R4,R0
    390              pu32InterruptAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_IER) + Buttons_asArray[i].ePort);
   \   00000022   0x....             LDR.N    R0,??DataTable10_9  ;; 0x400e0c40
   \   00000024   0x....             LDR.N    R1,??DataTable10_7
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0xEB01 0x0146      ADD      R1,R1,R6, LSL #+1
   \   0000002C   0x7849             LDRB     R1,[R1, #+1]
   \   0000002E   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000032   0x0005             MOVS     R5,R0
    391              
    392              if( G_abButtonDebounceActive[i] )
   \   00000034   0x....             LDR.N    R0,??DataTable10_5
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x5D80             LDRB     R0,[R0, R6]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD05B             BEQ.N    ??ButtonSM_ButtonActive_2
    393              {
    394                /* Still have an active button */
    395                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   0000003E   0x....             LDR.N    R0,??DataTable10_18
   \   00000040   0x....             LDR.N    R1,??DataTable10_13
   \   00000042   0x6008             STR      R0,[R1, #+0]
    396                
    397                if( IsTimeUp((u32*)&G_au32ButtonDebounceTimeStart[i], BUTTON_DEBOUNCE_TIME) )
   \   00000044   0x2119             MOVS     R1,#+25
   \   00000046   0x....             LDR.N    R0,??DataTable10_19
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000004E   0x.... 0x....      BL       IsTimeUp
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD04F             BEQ.N    ??ButtonSM_ButtonActive_2
    398                {
    399                  /* Active low: get current state of button */
    400                  if(Buttons_asArray[i].eActiveState == BUTTON_ACTIVE_LOW)
   \   00000056   0x....             LDR.N    R0,??DataTable10_7
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0xF810 0x0016      LDRB     R0,[R0, R6, LSL #+1]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD111             BNE.N    ??ButtonSM_ButtonActive_3
    401                  {
    402                    if( ~(*pu32PortAddress) & Button_au32ButtonPins[i] )
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x43C0             MVNS     R0,R0
   \   00000066   0x....             LDR.N    R1,??DataTable10_8
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   0000006E   0x4208             TST      R0,R1
   \   00000070   0xD004             BEQ.N    ??ButtonSM_ButtonActive_4
    403                    {          
    404                      Button_aeNewState[i] = PRESSED;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x....             LDR.N    R1,??DataTable10_6
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x5588             STRB     R0,[R1, R6]
   \   0000007A   0xE014             B.N      ??ButtonSM_ButtonActive_5
    405                    }
    406                    else
    407                    {
    408                      Button_aeNewState[i] = RELEASED;
   \                     ??ButtonSM_ButtonActive_4: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x....             LDR.N    R1,??DataTable10_6
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x5588             STRB     R0,[R1, R6]
   \   00000084   0xE00F             B.N      ??ButtonSM_ButtonActive_5
    409                    }
    410                  }
    411                  /* Active high */
    412                  else
    413                  {
    414                    if( *pu32PortAddress & Button_au32ButtonPins[i] )
   \                     ??ButtonSM_ButtonActive_3: (+1)
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x....             LDR.N    R1,??DataTable10_8
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   00000090   0x4208             TST      R0,R1
   \   00000092   0xD004             BEQ.N    ??ButtonSM_ButtonActive_6
    415                    {          
    416                      Button_aeNewState[i] = PRESSED;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x....             LDR.N    R1,??DataTable10_6
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x5588             STRB     R0,[R1, R6]
   \   0000009C   0xE003             B.N      ??ButtonSM_ButtonActive_5
    417                    }
    418                    else
    419                    {
    420                      Button_aeNewState[i] = RELEASED;
   \                     ??ButtonSM_ButtonActive_6: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x....             LDR.N    R1,??DataTable10_6
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x5588             STRB     R0,[R1, R6]
    421                    }
    422                  }
    423                  
    424                  /* Update if the button state has changed */
    425                  if( Button_aeNewState[i] != Button_aeCurrentState[i] )
   \                     ??ButtonSM_ButtonActive_5: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable10_6
   \   000000A8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AA   0x5D80             LDRB     R0,[R0, R6]
   \   000000AC   0x....             LDR.N    R1,??DataTable10_2
   \   000000AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B0   0x5D89             LDRB     R1,[R1, R6]
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD014             BEQ.N    ??ButtonSM_ButtonActive_7
    426                  {
    427                    Button_aeCurrentState[i] = Button_aeNewState[i];
   \   000000B6   0x....             LDR.N    R0,??DataTable10_6
   \   000000B8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BA   0x5D80             LDRB     R0,[R0, R6]
   \   000000BC   0x....             LDR.N    R1,??DataTable10_2
   \   000000BE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C0   0x5588             STRB     R0,[R1, R6]
    428                    if(Button_aeCurrentState[i] == PRESSED)
   \   000000C2   0x....             LDR.N    R0,??DataTable10_2
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0x5D80             LDRB     R0,[R0, R6]
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD109             BNE.N    ??ButtonSM_ButtonActive_7
    429                    {
    430                      Button_abNewPress[i] = TRUE;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x....             LDR.N    R1,??DataTable10_3
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x5588             STRB     R0,[R1, R6]
    431                      Button_au32HoldTimeStart[i] = G_u32SystemTime1ms;
   \   000000D4   0x....             LDR.N    R0,??DataTable10_20
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x....             LDR.N    R1,??DataTable10_4
   \   000000DA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DC   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
    432                    }
    433                  }
    434          
    435                  /* Regardless of a good press or not, clear the debounce active flag and re-enable the interrupts */
    436                  G_abButtonDebounceActive[i] = FALSE;
   \                     ??ButtonSM_ButtonActive_7: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x....             LDR.N    R1,??DataTable10_5
   \   000000E4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E6   0x5588             STRB     R0,[R1, R6]
    437                  *pu32InterruptAddress |= Button_au32ButtonPins[i];
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x....             LDR.N    R1,??DataTable10_8
   \   000000EC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EE   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   000000F2   0x4308             ORRS     R0,R1,R0
   \   000000F4   0x6028             STR      R0,[R5, #+0]
    438                  
    439                } /* end if( IsTimeUp...) */
    440              } /* end if(G_abButtonDebounceActive[index]) */
    441            } /* end for i */
   \                     ??ButtonSM_ButtonActive_2: (+1)
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
   \   000000F8   0xE787             B.N      ??ButtonSM_ButtonActive_0
    442            
    443          } /* end ButtonSM_ButtonActive() */
   \                     ??ButtonSM_ButtonActive_1: (+1)
   \   000000FA   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Button_aeCurrentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Button_abNewPress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     Button_au32HoldTimeStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     G_abButtonDebounceActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     Button_aeNewState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     Buttons_asArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     Button_au32ButtonPins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x400E0C40         DC32     0x400e0c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x400E0E40         DC32     0x400e0e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x400E0C4C         DC32     0x400e0c4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x400E0E4C         DC32     0x400e0e4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     Button_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     `ButtonInitialize::au8ButtonStartupMsg`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     ButtonSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x400E0C3C         DC32     0x400e0c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x........         DC32     ButtonSM_ButtonActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x........         DC32     G_au32ButtonDebounceTimeStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x........         DC32     G_u32SystemTime1ms
    444          
    445          
    446          
    447          /*--------------------------------------------------------------------------------------------------------------------*/
    448          /* End of File */
    449          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ButtonAcknowledge
      16   ButtonInitialize
        16   -> DebugPrintf
        16   -> NVIC_ClearPendingIRQ
        16   -> NVIC_EnableIRQ
       8   ButtonRunActiveState
         8   -- Indirect call
      16   ButtonSM_ButtonActive
        16   -> IsTimeUp
       0   ButtonSM_Idle
       0   GetButtonBitLocation
      16   IsButtonHeld
        16   -> IsButtonPressed
        16   -> IsTimeUp
       0   IsButtonPressed
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
       0   WasButtonPressed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       8  ButtonAcknowledge
     176  ButtonInitialize
      10  ButtonRunActiveState
     252  ButtonSM_ButtonActive
      32  ButtonSM_Idle
       4  Button_abNewPress
       4  Button_aeCurrentState
       4  Button_aeNewState
      16  Button_au32ButtonPins
      16  Button_au32HoldTimeStart
       4  Button_pfnStateMachine
       8  Buttons_asArray
       4  G_abButtonDebounceActive
      16  G_au32ButtonDebounceTimeStart
      40  GetButtonBitLocation
      40  IsButtonHeld
      18  IsButtonPressed
      20  NVIC_ClearPendingIRQ
      20  NVIC_EnableIRQ
      18  WasButtonPressed
      20  au8ButtonStartupMsg

 
  52 bytes in section .bss
  28 bytes in section .data
  16 bytes in section .rodata
 718 bytes in section .text
 
 718 bytes of CODE  memory
  16 bytes of CONST memory
  80 bytes of DATA  memory

Errors: none
Warnings: none
