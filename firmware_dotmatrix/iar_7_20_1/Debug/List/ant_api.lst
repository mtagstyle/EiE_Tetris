###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       22/Mar/2018  01:24:48
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\ant_api.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\ant_api.c" -D
#        MPGL2 -D MPG2 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -o "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\bsp\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\tetris\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List\ant_api.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj\ant_api.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\ant_api.c
      1          /***********************************************************************************************************************
      2          File: ant_api.c                                                               
      3          
      4          Description:
      5          ANT user interface.  No initialization or state machine required.  This file exposes the source code
      6          for all public functions that work with ant.c.  Seperating it keep sit a little more manageable.
      7          
      8          Once the ANT radio has been configured, all messaging from the ANT device is handled through 
      9          the incoming queue G_sAntApplicationMsgList.  The application is responsible for checking this
     10          queue for messages that belong to it and must manage timing and handle appropriate updates per 
     11          the ANT messaging protocol.  This should be no problem on the regular 1ms loop timing of the main 
     12          system (assuming ANT message rate is less than 1kHz).  Faster systems or burst messaging will need 
     13          to be handled seperately as an add-on to this API.
     14          
     15          
     16          ------------------------------------------------------------------------------------------------------------------------
     17          API:
     18          
     19          GLOBALS
     20          Three global variables give access to the latest ANT message data.
     21          Copy the following definitions to your client task:
     22          
     23          // Globals for passing data from the ANT application to the API 
     24          extern u32 G_u32AntApiCurrentMessageTimeStamp;                            // From ant_api.c
     25          extern AntApplicationMessageType G_eAntApiCurrentMessageClass;            // From ant_api.c
     26          extern u8 G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES];  // From ant_api.c
     27          extern AntExtendedDataType G_sAntApiCurrentMessageExtData;                // From ant_api.c
     28          
     29          TYPES
     30          Defined in ant.h but used throughout ant_api.c
     31          
     32          AntChannelNumberType (allowed to be indexed and type cast to sequentially access channels)
     33          {ANT_CHANNEL_0 = 0, ANT_CHANNEL_1, ANT_CHANNEL_2, ANT_CHANNEL_3,
     34          ANT_CHANNEL_4, ANT_CHANNEL_5, ANT_CHANNEL_6, ANT_CHANNEL_7,
     35          ANT_CHANNEL_SCANNING = 0}
     36          
     37          AntChannelStatusType
     38          {ANT_UNCONFIGURED, ANT_CONFIGURED, ANT_OPENING, ANT_OPEN, ANT_CLOSING, ANT_CLOSED}
     39          
     40          AntApplicationMessageType
     41          {ANT_EMPTY, ANT_DATA, ANT_TICK}
     42          
     43          AntApplicationGenericMsgStatus
     44          {ANT_GENERIC_MSG_READY, ANT_GENERIC_MSG_BUSY, ANT_GENERIC_MSG_OK, ANT_GENERIC_MSG_FAIL}
     45          
     46          Structs
     47          AntExtendedDataType
     48          AntApplicationMsgListType
     49          AntAssignChannelInfoType
     50          
     51          *** ANT CONFIGURATION / STATUS FUNCTIONS ***
     52          
     53          AntChannelStatusType AntRadioStatusChannel(AntChannelNumberType eChannel_)
     54          Query the status of the specified channel.  
     55          Returns ANT_UNCONFIGURED, ANT_CONFIGURED, ANT_OPENING, ANT_OPEN, ANT_CLOSING, ANT_CLOSED
     56          ANT_CONFIGURED and ANT_CLOSED are actually the same state.
     57          e.g.
     58          AntChannelStatus eAntCurrentStatus;
     59          
     60          // Get the status of Channel 1
     61          eAntCurrentStatus = AntRadioStatusChannel(ANT_CHANNEL_1);
     62          
     63          
     64          bool AntAssignChannel(AntAssignChannelInfoType* psAntSetupInfo_)
     65          Updates all configuration messages to completely configure an ANT channel with an application's 
     66          required parameters for communication.  The application should monitor AntRadioStatusChannel()
     67          to see if all of the configuration messages are sent and the channel is configured properly.
     68          e.g.
     69            AntAssignChannelInfoType sChannelInfo;
     70          
     71            if(AntRadioStatusChannel(ANT_CHANNEL_0) == ANT_UNCONFIGURED)
     72            {
     73              sChannelInfo.AntChannel = ANT_CHANNEL_0;
     74              sChannelInfo.AntChannelType = CHANNEL_TYPE_MASTER;
     75              sChannelInfo.AntChannelPeriodHi = ANT_CHANNEL_PERIOD_HI_DEFAULT;
     76              sChannelInfo.AntChannelPeriodLo = ANT_CHANNEL_PERIOD_LO_DEFAULT;
     77              
     78              sChannelInfo.AntDeviceIdHi = 0x00;
     79              sChannelInfo.AntDeviceIdLo = 0x01;
     80              sChannelInfo.AntDeviceType = ANT_DEVICE_TYPE_DEFAULT;
     81              sChannelInfo.AntTransmissionType = ANT_TRANSMISSION_TYPE_DEFAULT;
     82              
     83              sChannelInfo.AntFrequency = ANT_FREQUENCY_DEFAULT;
     84              sChannelInfo.AntTxPower = ANT_TX_POWER_DEFAULT;
     85              
     86              sChannelInfo.AntNetwork = ANT_NETWORK_DEFAULT;
     87              for(u8 i = 0; i < ANT_NETWORK_NUMBER_BYTES; i++)
     88              {
     89                sChannelInfo.AntNetworkKey[i] = ANT_DEFAULT_NETWORK_KEY;
     90              }
     91              
     92              AntAssignChannel(&sChannelInfo);
     93            }
     94          
     95            // Go to a wait state that exits when AntRadioStatusChannel(ANT_CHANNEL_0) no longer returns ANT_UNCONFIGURED)
     96          
     97          
     98          bool AntUnassignChannelNumber(AntChannelNumberType eChannel_)
     99          Queues message to unassign the specified ANT channel so it can be reconfigured.
    100          e.g.
    101          AntUnassignChannelNumber(ANT_CHANNEL_1)
    102          // Go to wait state that exists when AntRadioStatusChannel(ANT_CHANNEL_1) returns ANT_UNCONFIGURED
    103          
    104          
    105          bool AntOpenChannelNumber(AntChannelNumberType eAntChannelToOpen)
    106          Queues a request to open the specified channel.
    107          Returns TRUE if the channel is configured and the message is successfully queued - this can be ignored or checked.  
    108          Application should monitor AntRadioStatusChannel() for actual channel status.
    109          e.g.
    110          AntChannelStatusType eAntCurrentState;
    111          
    112          // Request to open channel only on an already closed channel.
    113          eAntCurrentState = AntChannelStatus(ANT_CHANNEL_1);
    114          
    115          if(eAntCurrentState == ANT_CLOSED )
    116          {
    117             AntOpenChannelNumber(ANT_CHANNEL_1);
    118          }
    119          
    120          
    121          bool AntCloseChannelNumber(AntChannelNumberType eAntChannelToOpen)
    122          Queues a request to close the specified channel.
    123          Returns TRUE if the message is successfully queued - this can be ignored or checked.  
    124          Application should monitor AntRadioStatusChannel() for actual channel status.
    125          e.g.
    126          AntChannelStatusType eAntCurrentState;
    127          
    128          // Request to close channel only on an open channel.
    129          if(AntRadioStatusChannel(ANT_CHANNEL_1) == ANT_OPEN )
    130          {
    131             AntCloseChannelNumber(ANT_CHANNEL_1);
    132          }
    133          
    134          bool AntOpenScanningChannel(void)
    135          Queues a request to open a scanning channel. Channel 0 setup parameters are used,
    136          but note that all channel resources are used by a scanning channel.  Trying to
    137          open a scanning channel if any other channel is open will fail.
    138          
    139          Returns TRUE if message is successfully queued - this can be ignored or checked.  
    140          Application should monitor AntRadioStatusChannel() for actual channel status.
    141          e.g.
    142          AntChannelStatusType eAntCurrentState;
    143          
    144          // Request to open channel only on an already closed channel.
    145          if(AntRadioStatusChannel(ANT_CHANNEL_SCANNING) == ANT_CLOSED )
    146          {
    147             AntOpenScanningChannel();
    148          }
    149          
    150          
    151          bool AntSendGenericMessage()
    152          Queues a generic message to be sent to ANT.  Any of the ANT message codes can be sent.
    153          The entire message string except the checksum must be provided.
    154          Returns TRUE if a message can be sent to ANT.
    155          Returns FALSE if the system is not available to send to ANT (i.e. a message is currently being sent)
    156          Application must then monitor AntCheckGenericMessageStatus() to determine when 
    157          
    158          e.g.
    159          AntChannelStatusType eAntCurrentState;
    160          
    161          
    162          ***ANT DATA FUNCTIONS***
    163          bool AntQueueBroadcastMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    164          Queue a broadcast data message.
    165          e.g.
    166          u8 u8DataToSend[ANT_DATA_BYTES] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    167          AntQueueBroadcastMessage(ANT_CHANNEL_1, &u8DataToSend[0]);
    168          
    169          
    170          bool AntQueueAcknowledgedMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    171          Queue an acknowledged data message.
    172          e.g.
    173          u8 u8DataToSend[ANT_DATA_BYTES] = {0x07, 0x06, 0x05, 0x04, 0x03, 0xdd, 0xee, 0xff};
    174          AntQueueAcknowledgedMessage(ANT_CHANNEL_1, u8DataToSend);
    175          
    176          
    177          bool AntReadAppMessageBuffer(void)
    178          Check the incoming message buffer for any message from the ANT system (either ANT_TICK or ANT_DATA).  
    179          If no messages are present, returns FALSE.  If a message is there, returns TRUE and application can read:
    180          - G_u32AntApiCurrentMessageTimeStamp to see the system time stamp when the message arrived
    181          - G_eAntApiCurrentMessageClass to see what kind of message is present
    182          - G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES] to see the message bytes.
    183          - G_sAntApiCurrentMessageExtData to see an available extended data (on incoming messages)
    184          
    185          e.g.
    186          u32 u32CurrentMessageTimeStamp;
    187          u8 u8CurrentTickEventCode;
    188          u8 u8CurrentMessageContents[ANT_APPLICATION_MESSAGE_BYTES];
    189          
    190          if(AntReadAppMessageBuffer())
    191          {
    192            // Report the time a message was received
    193            DebugPrintNumber(u32CurrentMessageTimeStamp);
    194            DebugPrintf(": message received\n\t");
    195          
    196            // Check the message class to determine how to process the message
    197            if(G_eAntApiCurrentMessageClass == ANT_TICK)
    198            {
    199              // Get the EVENT code from the ANT_TICK message 
    200              u8CurrentTickEventCode = G_au8AntApiCurrentMessageBytes[ANT_TICK_MSG_EVENT_CODE_INDEX];
    201            }
    202          
    203            if(G_eAntApiCurrentMessageClass == ANT_DATA)
    204            {
    205              // Copy the message data locally
    206              for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
    207              {
    208                u8CurrentMessageContents[i] = G_au8AntApiCurrentMessageBytes[i];
    209              }
    210            }
    211          }
    212          
    213          
    214          ***********************************************************************************************************************/
    215          
    216          #include "configuration.h"
    217          
    218          
    219          /***********************************************************************************************************************
    220          Global variable definitions with scope across entire project.
    221          All Global variable names shall start with "G_<type>AntApi"
    222          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    223          volatile u32 G_u32AntApiFlags;                                          /* Global state flags */
   \                     G_u32AntApiFlags:
   \   00000000                      DS8 4
    224          

   \                                 In section .bss, align 4
    225          u32 G_u32AntApiCurrentMessageTimeStamp = 0;                             /* Current read message's G_u32SystemTime1ms */
   \                     G_u32AntApiCurrentMessageTimeStamp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    226          AntApplicationMessageType G_eAntApiCurrentMessageClass = ANT_EMPTY;     /* Type of data */
   \                     G_eAntApiCurrentMessageClass:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    227          u8 G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES];       /* Array for message payload data */
   \                     G_au8AntApiCurrentMessageBytes:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    228          AntExtendedDataType G_sAntApiCurrentMessageExtData;                     /* Extended data struct for the current message */
   \                     G_sAntApiCurrentMessageExtData:
   \   00000000                      DS8 8
    229          
    230          
    231          /*----------------------------------------------------------------------------*/
    232          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
    233          and indicate what file the variable is defined in. */
    234          extern u32 G_u32SystemFlags;                                  /* From main.c */
    235          extern u32 G_u32ApplicationFlags;                             /* From main.c */
    236          
    237          extern volatile u32 G_u32SystemTime1ms;                       /* From board-specific source file */
    238          extern volatile u32 G_u32SystemTime1s;                        /* From board-specific source file */
    239          
    240          extern u32 G_u32AntFlags;                                     /* From ant.c */
    241          extern AntApplicationMsgListType *G_sAntApplicationMsgList;   /* From ant.c */
    242          extern AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]; /* From ant.c */
    243          extern AntMessageResponseType G_stMessageResponse;            /* From ant.c */
    244          
    245          extern u8 G_au8AntMessageOk[];                                /* From ant.c */
    246          extern u8 G_au8AntMessageFail[];                              /* From ant.c */
    247          extern u8 G_au8AntMessageAssign[];                            /* From ant.c */
    248          extern u8 G_au8AntMessageUnassign[];                          /* From ant.c */
    249          extern u8 G_au8AntMessageUnhandled[];                         /* From ant.c */
    250          extern u8 G_au8AntMessageSetup[];                             /* From ant.c */
    251          extern u8 G_au8AntMessageClose[];                             /* From ant.c */
    252          extern u8 G_au8AntMessageOpen[];                              /* From ant.c */
    253          extern u8 G_au8AntMessageInit[];                              /* From ant.c */
    254          extern u8 G_au8AntMessageInitFail[];                          /* From ant.c */
    255          extern u8 G_au8AntMessageNoAnt[];                             /* From ant.c */
    256          
    257          extern u8 G_au8AntSetNetworkKey[];                            /* From ant.c */
    258          extern u8 G_au8AntAssignChannel[];                            /* From ant.c */
    259          extern u8 G_au8AntSetChannelID[];                             /* From ant.c */
    260          extern u8 G_au8AntSetChannelPeriod[];                         /* From ant.c */
    261          extern u8 G_au8AntSetChannelRFFreq[];                         /* From ant.c */
    262          extern u8 G_au8AntSetChannelPower[];                          /* From ant.c */
    263          extern u8 G_au8AntLibConfig[];                                /* From ant.c */
    264          
    265          extern u8 G_au8AntBroadcastDataMessage[];                     /* From ant.c */
    266          extern u8 G_au8AntAckDataMessage[];                           /* From ant.c */
    267          
    268          
    269          /***********************************************************************************************************************
    270          Global variable definitions with scope limited to this local application.
    271          Variable names shall start with "AntApi_<type>Name" and be declared as static.
    272          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    273          static fnCode_type AntApi_StateMachine;             /* The state machine function pointer */
   \                     AntApi_StateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    274          static u32 AntApi_u32Timeout;                       /* Timeout counter used across states */
   \                     AntApi_u32Timeout:
   \   00000000                      DS8 4
    275          
    276          /* Message for channel assignment.  Set ANT_ASSIGN_MESSAGES for number of messages. */

   \                                 In section .data, align 4
    277          static u8* AntApi_apu8AntAssignChannel[] = {G_au8AntSetNetworkKey, G_au8AntLibConfig, G_au8AntAssignChannel, G_au8AntSetChannelID, 
   \                     AntApi_apu8AntAssignChannel:
   \   00000000   0x........         DC32 G_au8AntSetNetworkKey, G_au8AntLibConfig, G_au8AntAssignChannel
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 G_au8AntSetChannelID, G_au8AntSetChannelPeriod
   \              0x........   
   \   00000014   0x........         DC32 G_au8AntSetChannelRFFreq, G_au8AntSetChannelPower
   \              0x........   
    278                                                      G_au8AntSetChannelPeriod, G_au8AntSetChannelRFFreq, G_au8AntSetChannelPower 
    279                                                     }; 
    280          
    281          /***********************************************************************************************************************
    282          Function Definitions
    283          ***********************************************************************************************************************/
    284          
    285          /*--------------------------------------------------------------------------------------------------------------------*/
    286          /* Public functions                                                                                                   */
    287          /*--------------------------------------------------------------------------------------------------------------------*/
    288          
    289          /*------------------------------------------------------------------------------
    290          Function: AntAssignChannel
    291          Description:
    292          Updates all configuration messages to completely configure an ANT channel with an application's 
    293          required parameters for communication.  The ANT API state machine then sends and monitors the commands
    294          to ensure the requested channel is setup properly.  The application should monitor AntRadioStatusChannel()
    295          to see if the channel is configured properly.
    296          
    297          Requires:
    298            - psAntSetupInfo_ points to a complete AntAssignChannelInfoType with all the required channel information.
    299            - The ANT channel should not be currently assigned.
    300          
    301          Promises:
    302            - Channel, Channel ID, message period, radio frequency and radio power are configured.
    303            - Returns TRUE if the channel is ready to be set up; all global setup messages are updated with the values
    304              from psAntSetupInfo; 
    305            - Returns FALSE if the channel is already configured
    306          */

   \                                 In section .text, align 2, keep-with-next
    307          bool AntAssignChannel(AntAssignChannelInfoType* psAntSetupInfo_)
    308          {
   \                     AntAssignChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    309            /* Check to ensure the selected channel is available */
    310            if(AntRadioStatusChannel(psAntSetupInfo_->AntChannel) != ANT_UNCONFIGURED)
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       AntRadioStatusChannel
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD005             BEQ.N    ??AntAssignChannel_0
    311            {
    312              DebugPrintf("AntAssignChannel error: channel is not unconfigured\n\r");
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000012   0x.... 0x....      BL       DebugPrintf
    313              return FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE0E8             B.N      ??AntAssignChannel_1
    314            }
    315            
    316            /* Setup the library config message (for extended data) - use defaults for now */
    317            G_au8AntLibConfig[4] = AntCalculateTxChecksum(G_au8AntLibConfig);
   \                     ??AntAssignChannel_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000001E   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000026   0x7108             STRB     R0,[R1, #+4]
    318          
    319            /* Set Network key message */
    320            G_au8AntSetNetworkKey[2] = psAntSetupInfo_->AntNetwork;
   \   00000028   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
    321            for(u8 i = 0; i < ANT_NETWORK_NUMBER_BYTES; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??AntAssignChannel_2: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xDA17             BGE.N    ??AntAssignChannel_3
    322            {
    323              G_au8AntSetNetworkKey[i + 3] = psAntSetupInfo_->AntNetworkKey[i];
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xEB04 0x0100      ADD      R1,R4,R0
   \   0000003E   0x78C9             LDRB     R1,[R1, #+3]
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x4402             ADD      R2,R2,R0
   \   00000048   0x70D1             STRB     R1,[R2, #+3]
    324              G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntNetworkKey[i] = psAntSetupInfo_->AntNetworkKey[i];
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000004E   0x7822             LDRB     R2,[R4, #+0]
   \   00000050   0x2314             MOVS     R3,#+20
   \   00000052   0x435A             MULS     R2,R3,R2
   \   00000054   0x4411             ADD      R1,R1,R2
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x4401             ADD      R1,R1,R0
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0xEB04 0x0200      ADD      R2,R4,R0
   \   00000060   0x78D2             LDRB     R2,[R2, #+3]
   \   00000062   0x70CA             STRB     R2,[R1, #+3]
    325            }
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0xE7E4             B.N      ??AntAssignChannel_2
    326            G_au8AntSetNetworkKey[11] = AntCalculateTxChecksum(G_au8AntSetNetworkKey);
   \                     ??AntAssignChannel_3: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000006C   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000074   0x72C8             STRB     R0,[R1, #+11]
    327              
    328            /* Setup the channel message */
    329            G_au8AntAssignChannel[2] = psAntSetupInfo_->AntChannel;
   \   00000076   0x7820             LDRB     R0,[R4, #+0]
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   0000007C   0x7088             STRB     R0,[R1, #+2]
    330            G_au8AntAssignChannel[3] = psAntSetupInfo_->AntChannelType;
   \   0000007E   0x7860             LDRB     R0,[R4, #+1]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000084   0x70C8             STRB     R0,[R1, #+3]
    331            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelType = psAntSetupInfo_->AntChannelType;
   \   00000086   0x7860             LDRB     R0,[R4, #+1]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000008C   0x7822             LDRB     R2,[R4, #+0]
   \   0000008E   0x2314             MOVS     R3,#+20
   \   00000090   0x435A             MULS     R2,R3,R2
   \   00000092   0x4411             ADD      R1,R1,R2
   \   00000094   0x7048             STRB     R0,[R1, #+1]
    332          
    333            G_au8AntAssignChannel[4] = psAntSetupInfo_->AntNetwork;
   \   00000096   0x78A0             LDRB     R0,[R4, #+2]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   0000009C   0x7108             STRB     R0,[R1, #+4]
    334            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntNetwork = psAntSetupInfo_->AntNetwork;
   \   0000009E   0x78A0             LDRB     R0,[R4, #+2]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000A4   0x7822             LDRB     R2,[R4, #+0]
   \   000000A6   0x2314             MOVS     R3,#+20
   \   000000A8   0x435A             MULS     R2,R3,R2
   \   000000AA   0x4411             ADD      R1,R1,R2
   \   000000AC   0x7088             STRB     R0,[R1, #+2]
    335          
    336            G_au8AntAssignChannel[5] = AntCalculateTxChecksum(G_au8AntAssignChannel);
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \   000000B2   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   000000BA   0x7148             STRB     R0,[R1, #+5]
    337          
    338            /* Setup the channel ID message */
    339            G_au8AntSetChannelID[2] = psAntSetupInfo_->AntChannel;
   \   000000BC   0x7820             LDRB     R0,[R4, #+0]
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000C2   0x7088             STRB     R0,[R1, #+2]
    340            G_au8AntSetChannelID[3] = psAntSetupInfo_->AntDeviceIdLo;
   \   000000C4   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000CA   0x70C8             STRB     R0,[R1, #+3]
    341            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceIdLo = psAntSetupInfo_->AntDeviceIdLo;
   \   000000CC   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000D2   0x7822             LDRB     R2,[R4, #+0]
   \   000000D4   0x2314             MOVS     R3,#+20
   \   000000D6   0x435A             MULS     R2,R3,R2
   \   000000D8   0x4411             ADD      R1,R1,R2
   \   000000DA   0x72C8             STRB     R0,[R1, #+11]
    342          
    343            G_au8AntSetChannelID[4] = psAntSetupInfo_->AntDeviceIdHi;
   \   000000DC   0x7B20             LDRB     R0,[R4, #+12]
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000E2   0x7108             STRB     R0,[R1, #+4]
    344            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceIdHi = psAntSetupInfo_->AntDeviceIdHi;
   \   000000E4   0x7B20             LDRB     R0,[R4, #+12]
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000EA   0x7822             LDRB     R2,[R4, #+0]
   \   000000EC   0x2314             MOVS     R3,#+20
   \   000000EE   0x435A             MULS     R2,R3,R2
   \   000000F0   0x4411             ADD      R1,R1,R2
   \   000000F2   0x7308             STRB     R0,[R1, #+12]
    345          
    346            G_au8AntSetChannelID[5] = psAntSetupInfo_->AntDeviceType;
   \   000000F4   0x7B60             LDRB     R0,[R4, #+13]
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000FA   0x7148             STRB     R0,[R1, #+5]
    347            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceType = psAntSetupInfo_->AntDeviceType;
   \   000000FC   0x7B60             LDRB     R0,[R4, #+13]
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000102   0x7822             LDRB     R2,[R4, #+0]
   \   00000104   0x2314             MOVS     R3,#+20
   \   00000106   0x435A             MULS     R2,R3,R2
   \   00000108   0x4411             ADD      R1,R1,R2
   \   0000010A   0x7348             STRB     R0,[R1, #+13]
    348          
    349            G_au8AntSetChannelID[6] = psAntSetupInfo_->AntTransmissionType;
   \   0000010C   0x7BA0             LDRB     R0,[R4, #+14]
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   00000112   0x7188             STRB     R0,[R1, #+6]
    350            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntTransmissionType = psAntSetupInfo_->AntTransmissionType;
   \   00000114   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000011A   0x7822             LDRB     R2,[R4, #+0]
   \   0000011C   0x2314             MOVS     R3,#+20
   \   0000011E   0x435A             MULS     R2,R3,R2
   \   00000120   0x4411             ADD      R1,R1,R2
   \   00000122   0x7388             STRB     R0,[R1, #+14]
    351          
    352            G_au8AntSetChannelID[7] = AntCalculateTxChecksum(G_au8AntSetChannelID);
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000128   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   00000130   0x71C8             STRB     R0,[R1, #+7]
    353              
    354            /* Setup the channel period message */
    355            G_au8AntSetChannelPeriod[2] = psAntSetupInfo_->AntChannel;
   \   00000132   0x7820             LDRB     R0,[R4, #+0]
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000138   0x7088             STRB     R0,[R1, #+2]
    356            G_au8AntSetChannelPeriod[3] = psAntSetupInfo_->AntChannelPeriodLo;
   \   0000013A   0x7BE0             LDRB     R0,[R4, #+15]
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000140   0x70C8             STRB     R0,[R1, #+3]
    357            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelPeriodLo = psAntSetupInfo_->AntChannelPeriodLo;
   \   00000142   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000148   0x7822             LDRB     R2,[R4, #+0]
   \   0000014A   0x2314             MOVS     R3,#+20
   \   0000014C   0x435A             MULS     R2,R3,R2
   \   0000014E   0x4411             ADD      R1,R1,R2
   \   00000150   0x73C8             STRB     R0,[R1, #+15]
    358          
    359            G_au8AntSetChannelPeriod[4] = psAntSetupInfo_->AntChannelPeriodHi;
   \   00000152   0x7C20             LDRB     R0,[R4, #+16]
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000158   0x7108             STRB     R0,[R1, #+4]
    360            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelPeriodHi = psAntSetupInfo_->AntChannelPeriodHi;
   \   0000015A   0x7C20             LDRB     R0,[R4, #+16]
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000160   0x7822             LDRB     R2,[R4, #+0]
   \   00000162   0x2314             MOVS     R3,#+20
   \   00000164   0x435A             MULS     R2,R3,R2
   \   00000166   0x4411             ADD      R1,R1,R2
   \   00000168   0x7408             STRB     R0,[R1, #+16]
    361          
    362            G_au8AntSetChannelPeriod[5] = AntCalculateTxChecksum(G_au8AntSetChannelPeriod);
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable11_6
   \   0000016E   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000176   0x7148             STRB     R0,[R1, #+5]
    363              
    364            /* Setup the channel frequency message */
    365            G_au8AntSetChannelRFFreq[2] = psAntSetupInfo_->AntChannel;
   \   00000178   0x7820             LDRB     R0,[R4, #+0]
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   0000017E   0x7088             STRB     R0,[R1, #+2]
    366            G_au8AntSetChannelRFFreq[3] = psAntSetupInfo_->AntFrequency;
   \   00000180   0x7C60             LDRB     R0,[R4, #+17]
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   00000186   0x70C8             STRB     R0,[R1, #+3]
    367            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntFrequency = psAntSetupInfo_->AntFrequency;
   \   00000188   0x7C60             LDRB     R0,[R4, #+17]
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000018E   0x7822             LDRB     R2,[R4, #+0]
   \   00000190   0x2314             MOVS     R3,#+20
   \   00000192   0x435A             MULS     R2,R3,R2
   \   00000194   0x4411             ADD      R1,R1,R2
   \   00000196   0x7448             STRB     R0,[R1, #+17]
    368          
    369            G_au8AntSetChannelRFFreq[4] = AntCalculateTxChecksum(G_au8AntSetChannelRFFreq);
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   0000019C   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   000001A4   0x7108             STRB     R0,[R1, #+4]
    370          
    371            /* Setup the channel power message */
    372            G_au8AntSetChannelPower[2] = psAntSetupInfo_->AntChannel;
   \   000001A6   0x7820             LDRB     R0,[R4, #+0]
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001AC   0x7088             STRB     R0,[R1, #+2]
    373            G_au8AntSetChannelPower[3] = psAntSetupInfo_->AntTxPower;
   \   000001AE   0x7CA0             LDRB     R0,[R4, #+18]
   \   000001B0   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001B4   0x70C8             STRB     R0,[R1, #+3]
    374            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntTxPower = psAntSetupInfo_->AntTxPower;
   \   000001B6   0x7CA0             LDRB     R0,[R4, #+18]
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000001BC   0x7822             LDRB     R2,[R4, #+0]
   \   000001BE   0x2314             MOVS     R3,#+20
   \   000001C0   0x435A             MULS     R2,R3,R2
   \   000001C2   0x4411             ADD      R1,R1,R2
   \   000001C4   0x7488             STRB     R0,[R1, #+18]
    375          
    376            G_au8AntSetChannelPower[4] = AntCalculateTxChecksum(G_au8AntSetChannelPower);
   \   000001C6   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   000001CA   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001D2   0x7108             STRB     R0,[R1, #+4]
    377               
    378            /* Set the next state to begin transferring */
    379            AntApi_u32Timeout = G_u32SystemTime1ms;
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable11_9
   \   000001D8   0x6800             LDR      R0,[R0, #+0]
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \   000001DE   0x6008             STR      R0,[R1, #+0]
    380            AntApi_StateMachine = AntApiSM_AssignChannel;
   \   000001E0   0x.... 0x....      ADR.W    R0,AntApiSM_AssignChannel
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \   000001E8   0x6008             STR      R0,[R1, #+0]
    381            return TRUE;
   \   000001EA   0x2001             MOVS     R0,#+1
   \                     ??AntAssignChannel_1: (+1)
   \   000001EC   0xBD10             POP      {R4,PC}          ;; return
    382          
    383          } /* end AntAssignChannel() */
    384          
    385          
    386          /*------------------------------------------------------------------------------
    387          Function: AntUnassignChannelNumber
    388          
    389          Description:
    390          Queues message to unassigns the specified ANT channel so it can be reconfigured.
    391            
    392          Requires:
    393            - ANT channel is closed
    394          
    395          Promises:
    396            - ANT channel unassign message is queued; application should monitor AntRadioStatus()
    397          */

   \                                 In section .text, align 2, keep-with-next
    398          bool AntUnassignChannelNumber(AntChannelNumberType eChannel_)
    399          {
   \                     AntUnassignChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    400            u8 au8AntUnassignChannel[] = {MESG_UNASSIGN_CHANNEL_SIZE, MESG_UNASSIGN_CHANNEL_ID, 0, CS};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable11_12
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    401          
    402            /* Update the channel number */
    403             au8AntUnassignChannel[2] = eChannel_;
   \   00000010   0xF88D 0x4002      STRB     R4,[SP, #+2]
    404          
    405            /* Update checksum and queue the unassign channel message */
    406            au8AntUnassignChannel[3] = AntCalculateTxChecksum(au8AntUnassignChannel);
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000001A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    407            G_asAntChannelConfiguration[eChannel_].AntFlags &= ~_ANT_FLAGS_CHANNEL_CONFIGURED;
   \   0000001E   0x....             LDR.N    R0,??DataTable11_3
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2114             MOVS     R1,#+20
   \   00000024   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000028   0x4408             ADD      R0,R0,R1
   \   0000002A   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000002C   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000030   0x....             LDR.N    R1,??DataTable11_3
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2214             MOVS     R2,#+20
   \   00000036   0xFB02 0xF204      MUL      R2,R2,R4
   \   0000003A   0x4411             ADD      R1,R1,R2
   \   0000003C   0x74C8             STRB     R0,[R1, #+19]
    408            return( AntQueueOutgoingMessage(au8AntUnassignChannel) );
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000044   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    409          
    410          } /* end AntUnassignChannelNumber() */
    411          
    412          
    413          /*------------------------------------------------------------------------------
    414          Function: AntOpenChannelNumber
    415          
    416          Description:
    417          Queues the Open Channel message on the configured ANT channel.  This does not actually indicate
    418          that the channel has been opened successfully -- the calling task must monitor _ANT_FLAGS_CHANNEL_OPEN
    419          to determine if channel opens successfully.
    420            
    421          Requires:
    422            - eChannel_ is ANT_CHANNEL_0, ..., ANT_CHANNEL_7, ANT_CHANNEL_SCANNING
    423            - ANT channel to open should be correctly configured.
    424          
    425          Promises:
    426            - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    427            - Otherwise returns FALSE
    428           
    429          */

   \                                 In section .text, align 2, keep-with-next
    430          bool AntOpenChannelNumber(AntChannelNumberType eChannel_)
    431          {
   \                     AntOpenChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    432            u8 au8AntOpenChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_CHANNEL_ID, 0, CS};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x....             LDR.N    R1,??DataTable11_13
   \   0000000A   0x680A             LDR      R2,[R1, #0]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    433            
    434            /* Update the channel number in the message for a regular channel */
    435            if(eChannel_ != ANT_CHANNEL_SCANNING)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD001             BEQ.N    ??AntOpenChannelNumber_0
    436            {
    437              au8AntOpenChannel[2] = eChannel_;
   \   00000014   0xF88D 0x4002      STRB     R4,[SP, #+2]
    438            }
    439          
    440            /* Update the checksum value and queue the open channel message */
    441            au8AntOpenChannel[3] = AntCalculateTxChecksum(au8AntOpenChannel);
   \                     ??AntOpenChannelNumber_0: (+1)
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    442            G_asAntChannelConfiguration[eChannel_].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   00000022   0x....             LDR.N    R0,??DataTable11_3
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2114             MOVS     R1,#+20
   \   00000028   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000002C   0x4408             ADD      R0,R0,R1
   \   0000002E   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000030   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000034   0x....             LDR.N    R1,??DataTable11_3
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2214             MOVS     R2,#+20
   \   0000003A   0xFB02 0xF204      MUL      R2,R2,R4
   \   0000003E   0x4411             ADD      R1,R1,R2
   \   00000040   0x74C8             STRB     R0,[R1, #+19]
    443           
    444            return( AntQueueOutgoingMessage(au8AntOpenChannel) );
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000048   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    445            
    446          } /* end AntOpenChannelNumber() */
    447          
    448          
    449          /*------------------------------------------------------------------------------
    450          Function: AntOpenChannelNumber
    451          
    452          Description:
    453          Queues the Open Scan Channel message.  Scanning channels must use Channel 0
    454          and actually take all channel resources.  It is up to the user to ensure
    455          that the device is configured properly.  Attempting to open a scanning channel
    456          when other channels are already open will result in a failure.
    457          
    458          The return value does not actually indicate that the channel has been 
    459          opened successfully -- the calling task must monitor _ANT_FLAGS_CHANNEL_OPEN
    460          to determine if channel opens successfully.
    461            
    462          Requires:
    463            - ANT channel 0 should be correctly configured as a SLAVE.
    464          
    465          Promises:
    466            - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    467            - Otherwise returns FALSE
    468           
    469          */

   \                                 In section .text, align 2, keep-with-next
    470          bool AntOpenScanningChannel(void)
    471          {
   \                     AntOpenScanningChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    472            u8 au8AntOpenScanChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_SCAN_CHANNEL_ID, 0, CS};
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x....             LDR.N    R1,??DataTable11_14
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
    473            
    474            /* Update the checksum value and queue the open channel message */
    475            au8AntOpenScanChannel[3] = AntCalculateTxChecksum(au8AntOpenScanChannel);
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000010   0xF88D 0x0003      STRB     R0,[SP, #+3]
    476            G_asAntChannelConfiguration[0].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   00000014   0x....             LDR.N    R0,??DataTable11_3
   \   00000016   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000018   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001C   0x....             LDR.N    R1,??DataTable11_3
   \   0000001E   0x74C8             STRB     R0,[R1, #+19]
    477           
    478            return( AntQueueOutgoingMessage(au8AntOpenScanChannel) );
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    479            
    480          } /* end AntOpenScanningChannelNumber() */
    481          
    482          
    483          
    484          /*------------------------------------------------------------------------------
    485          Function: AntCloseChannelNumber
    486          
    487          Description:
    488          Requests that an ANT channel is closed.  Issuing MESG_CLOSE_CHANNEL_ID does not
    489          guarantee that the channel closes, and ANT response to this message does not
    490          indicate that the channel is closed (a seperate message will be sent when the 
    491          channel actually closes which usually happens on the next ANT message period).
    492            
    493          Requires:
    494            - eChannel_ is ANT_CHANNEL_0, ..., ANT_CHANNEL_7, ANT_CHANNEL_SCANNING
    495            - ANT channel is correctly configured and should be open.
    496          
    497          Promises:
    498            - If channel close message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    499            - Otherwise returns FALSE
    500          */

   \                                 In section .text, align 2, keep-with-next
    501          bool AntCloseChannelNumber(AntChannelNumberType eChannel_)
    502          {
   \                     AntCloseChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    503            u8 au8AntCloseChannel[] = {MESG_CLOSE_CHANNEL_SIZE, MESG_CLOSE_CHANNEL_ID, 0, CS};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x....             LDR.N    R1,??DataTable11_15
   \   0000000A   0x680A             LDR      R2,[R1, #0]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    504            
    505            /* Update the channel number */
    506            au8AntCloseChannel[2] = eChannel_;
   \   0000000E   0xF88D 0x4002      STRB     R4,[SP, #+2]
    507          
    508            /* Update the checksum value and queue the close channel message*/
    509            au8AntCloseChannel[3] = AntCalculateTxChecksum(au8AntCloseChannel);
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    510            G_asAntChannelConfiguration[eChannel_].AntFlags |= _ANT_FLAGS_CHANNEL_CLOSE_PENDING;
   \   0000001C   0x....             LDR.N    R0,??DataTable11_3
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2114             MOVS     R1,#+20
   \   00000022   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000026   0x4408             ADD      R0,R0,R1
   \   00000028   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000002A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000002E   0x....             LDR.N    R1,??DataTable11_3
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2214             MOVS     R2,#+20
   \   00000034   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000038   0x4411             ADD      R1,R1,R2
   \   0000003A   0x74C8             STRB     R0,[R1, #+19]
    511            
    512            return( AntQueueOutgoingMessage(au8AntCloseChannel) );
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000042   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    513          
    514          } /* end AntCloseChannelNumber() */
    515          
    516          
    517          
    518          
    519          /*------------------------------------------------------------------------------
    520          Function: AntRadioStatusChannel
    521          
    522          Description:
    523          Returns the current radio status of the specified channel to the application.
    524            
    525          Requires:
    526            - G_u32AntFlags are up to date
    527          
    528          Promises:
    529            - Returns one of {ANT_UNCONFIGURED, ANT_CONFIGURED (ANT_CLOSED), ANT_CLOSING, ANT_OPEN, ANT_CLOSED}
    530          
    531          */

   \                                 In section .text, align 2, keep-with-next
    532          AntChannelStatusType AntRadioStatusChannel(AntChannelNumberType eChannel_)
    533          {
   \                     AntRadioStatusChannel: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    534            if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_CONFIGURED)
   \   00000002   0x....             LDR.N    R0,??DataTable11_3
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2214             MOVS     R2,#+20
   \   00000008   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000000C   0x4410             ADD      R0,R0,R2
   \   0000000E   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000010   0x07C0             LSLS     R0,R0,#+31
   \   00000012   0xD517             BPL.N    ??AntRadioStatusChannel_0
    535            {
    536              if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_CLOSE_PENDING)
   \   00000014   0x....             LDR.N    R0,??DataTable11_3
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x2214             MOVS     R2,#+20
   \   0000001A   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000001E   0x4410             ADD      R0,R0,R2
   \   00000020   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000022   0x0700             LSLS     R0,R0,#+28
   \   00000024   0xD501             BPL.N    ??AntRadioStatusChannel_1
    537              {
    538                return ANT_CLOSING;
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0xE00D             B.N      ??AntRadioStatusChannel_2
    539              }
    540              else if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_OPEN)
   \                     ??AntRadioStatusChannel_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable11_3
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x2214             MOVS     R2,#+20
   \   00000030   0xFB02 0xF201      MUL      R2,R2,R1
   \   00000034   0x4410             ADD      R0,R0,R2
   \   00000036   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000038   0x0740             LSLS     R0,R0,#+29
   \   0000003A   0xD501             BPL.N    ??AntRadioStatusChannel_3
    541              {
    542                return ANT_OPEN;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xE002             B.N      ??AntRadioStatusChannel_2
    543              }
    544              else
    545              {
    546                return ANT_CLOSED;
   \                     ??AntRadioStatusChannel_3: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??AntRadioStatusChannel_2
    547              }
    548            }
    549            else
    550            {
    551              return ANT_UNCONFIGURED;
   \                     ??AntRadioStatusChannel_0: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??AntRadioStatusChannel_2: (+1)
   \   00000046   0x4770             BX       LR               ;; return
    552            }
    553             
    554          } /* end AntRadioStatusChannel () */
    555          
    556          
    557          /***ANT DATA FUNCTIONS***/
    558          
    559          /*-----------------------------------------------------------------------------/
    560          Function: AntQueueBroadcastMessage
    561          
    562          Description:
    563          Adds an ANT broadcast message to the outgoing messages list.  
    564          
    565          Requires:
    566            - eChannel_ is the channel number on which to broadcast
    567            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    568          
    569          Promises:
    570            - Returns TRUE if the entry is added successfully.
    571          */

   \                                 In section .text, align 2, keep-with-next
    572          bool AntQueueBroadcastMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    573          {
   \                     AntQueueBroadcastMessage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    574            /* Update the dynamic message data */
    575            G_au8AntBroadcastDataMessage[2] = eChannel_;
   \   00000006   0x....             LDR.N    R0,??DataTable11_16
   \   00000008   0x7084             STRB     R4,[R0, #+2]
    576            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??AntQueueBroadcastMessage_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xDA07             BGE.N    ??AntQueueBroadcastMessage_1
    577            {
    578              G_au8AntBroadcastDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5C29             LDRB     R1,[R5, R0]
   \   00000016   0x....             LDR.N    R2,??DataTable11_16
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4402             ADD      R2,R2,R0
   \   0000001C   0x70D1             STRB     R1,[R2, #+3]
    579            }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xE7F4             B.N      ??AntQueueBroadcastMessage_0
    580           
    581            G_au8AntBroadcastDataMessage[11] = AntCalculateTxChecksum(G_au8AntBroadcastDataMessage);
   \                     ??AntQueueBroadcastMessage_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable11_16
   \   00000024   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000028   0x....             LDR.N    R1,??DataTable11_16
   \   0000002A   0x72C8             STRB     R0,[R1, #+11]
    582            
    583            return( AntQueueOutgoingMessage(G_au8AntBroadcastDataMessage) );
   \   0000002C   0x....             LDR.N    R0,??DataTable11_16
   \   0000002E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    584          
    585          } /* end AntQueueBroadcastMessage */
    586          
    587          
    588          /*-----------------------------------------------------------------------------/
    589          Function: AntQueueAcknowledgedMessage
    590          
    591          Description:
    592          Adds an ANT Acknowledged message to the outgoing messages list.  
    593          
    594          Requires:
    595            - eChannel_ is the channel number on which to broadcast
    596            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    597          
    598          Promises:
    599            - Returns TRUE if the entry is added successfully.
    600          */

   \                                 In section .text, align 2, keep-with-next
    601          bool AntQueueAcknowledgedMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    602          {
   \                     AntQueueAcknowledgedMessage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    603            /* Update the dynamic message data */
    604            G_au8AntAckDataMessage[2] = eChannel_;
   \   00000006   0x....             LDR.N    R0,??DataTable11_17
   \   00000008   0x7084             STRB     R4,[R0, #+2]
    605            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??AntQueueAcknowledgedMessage_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xDA07             BGE.N    ??AntQueueAcknowledgedMessage_1
    606            {
    607              G_au8AntAckDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5C29             LDRB     R1,[R5, R0]
   \   00000016   0x....             LDR.N    R2,??DataTable11_17
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4402             ADD      R2,R2,R0
   \   0000001C   0x70D1             STRB     R1,[R2, #+3]
    608            }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xE7F4             B.N      ??AntQueueAcknowledgedMessage_0
    609           
    610            G_au8AntAckDataMessage[11] = AntCalculateTxChecksum(G_au8AntAckDataMessage);
   \                     ??AntQueueAcknowledgedMessage_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable11_17
   \   00000024   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000028   0x....             LDR.N    R1,??DataTable11_17
   \   0000002A   0x72C8             STRB     R0,[R1, #+11]
    611            return( AntQueueOutgoingMessage(G_au8AntAckDataMessage) );
   \   0000002C   0x....             LDR.N    R0,??DataTable11_17
   \   0000002E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    612           
    613          } /* end AntQueueAcknowledgedMessage */
    614          
    615          
    616          /*-----------------------------------------------------------------------------/
    617          Function: AntReadAppMessageBuffer
    618          
    619          Description:
    620          Checks for any new messages from ANT.  New messages are buffered by ant.c and 
    621          made available to the application on a FIFO basis.  Whenever this function
    622          is called, the global parameters are updated:
    623          G_u32AntApiCurrentMessageTimeStamp
    624          G_eAntApiCurrentMessageClass
    625          G_au8AntApiCurrentMessageBytes
    626          G_sAntApiCurrentMessageExtData
    627          
    628          The application should check G_eAntApiCurrentMessageClass to determine if the message
    629          is ANT_DATA or ANT_TICK and then use G_au8AntApiCurrentMessageBytes and
    630          G_sAntApiCurrentMessageExtData accordingly.
    631          
    632          Requires:
    633            - 
    634          
    635          Promises:
    636            - Returns TRUE if there is new data; 
    637              G_u32AntApiCurrentMessageTimeStamp
    638              G_eAntApiCurrentMessageClass
    639              G_au8AntApiCurrentMessageBytes
    640              G_sAntApiCurrentMessageExtData
    641              are all updated with the oldest data from G_sAntApplicationMsgList and the message
    642              is removed from the buffer.
    643            - Returns FALSE if no new data is present (all variables unchanged)
    644          */

   \                                 In section .text, align 2, keep-with-next
    645          bool AntReadAppMessageBuffer(void)
    646          {
   \                     AntReadAppMessageBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    647            u8 *pu8Parser;
    648            
    649            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable11_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD03A             BEQ.N    ??AntReadAppMessageBuffer_0
    650            {
    651              /* Grab the single bytes */
    652              G_u32AntApiCurrentMessageTimeStamp = G_sAntApplicationMsgList->u32TimeStamp;
   \   0000000A   0x....             LDR.N    R0,??DataTable11_18
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable11_19
   \   00000012   0x6008             STR      R0,[R1, #+0]
    653              G_eAntApiCurrentMessageClass = G_sAntApplicationMsgList->eMessageType;
   \   00000014   0x....             LDR.N    R0,??DataTable11_18
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7900             LDRB     R0,[R0, #+4]
   \   0000001A   0x....             LDR.N    R1,??DataTable11_20
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    654              
    655              /* Copy over all the payload data */
    656              pu8Parser = &(G_sAntApplicationMsgList->au8MessageData[0]);
   \   0000001E   0x....             LDR.N    R0,??DataTable11_18
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x1D80             ADDS     R0,R0,#+6
   \   00000024   0x0004             MOVS     R4,R0
    657              for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??AntReadAppMessageBuffer_1: (+1)
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xDA06             BGE.N    ??AntReadAppMessageBuffer_2
    658              {
    659                G_au8AntApiCurrentMessageBytes[i] = *(pu8Parser + i);
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x5C21             LDRB     R1,[R4, R0]
   \   00000032   0x....             LDR.N    R2,??DataTable11_21
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x5411             STRB     R1,[R2, R0]
    660              }
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0xE7F5             B.N      ??AntReadAppMessageBuffer_1
    661              
    662              /* Copy over the extended data */
    663              G_sAntApiCurrentMessageExtData.u8Channel    = G_sAntApplicationMsgList->sExtendedData.u8Channel;
   \                     ??AntReadAppMessageBuffer_2: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable11_18
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x7B80             LDRB     R0,[R0, #+14]
   \   00000042   0x....             LDR.N    R1,??DataTable11_22
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    664              G_sAntApiCurrentMessageExtData.u8Flags      = G_sAntApplicationMsgList->sExtendedData.u8Flags;
   \   00000046   0x....             LDR.N    R0,??DataTable11_18
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000004C   0x....             LDR.N    R1,??DataTable11_22
   \   0000004E   0x7048             STRB     R0,[R1, #+1]
    665              G_sAntApiCurrentMessageExtData.u16DeviceID  = G_sAntApplicationMsgList->sExtendedData.u16DeviceID;
   \   00000050   0x....             LDR.N    R0,??DataTable11_18
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x8A00             LDRH     R0,[R0, #+16]
   \   00000056   0x....             LDR.N    R1,??DataTable11_22
   \   00000058   0x8048             STRH     R0,[R1, #+2]
    666              G_sAntApiCurrentMessageExtData.u8DeviceType = G_sAntApplicationMsgList->sExtendedData.u8DeviceType;
   \   0000005A   0x....             LDR.N    R0,??DataTable11_18
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x7C80             LDRB     R0,[R0, #+18]
   \   00000060   0x....             LDR.N    R1,??DataTable11_22
   \   00000062   0x7108             STRB     R0,[R1, #+4]
    667              G_sAntApiCurrentMessageExtData.u8TransType  = G_sAntApplicationMsgList->sExtendedData.u8TransType;
   \   00000064   0x....             LDR.N    R0,??DataTable11_18
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000006A   0x....             LDR.N    R1,??DataTable11_22
   \   0000006C   0x7148             STRB     R0,[R1, #+5]
    668              G_sAntApiCurrentMessageExtData.s8RSSI       = G_sAntApplicationMsgList->sExtendedData.s8RSSI;
   \   0000006E   0x....             LDR.N    R0,??DataTable11_18
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x7D00             LDRB     R0,[R0, #+20]
   \   00000074   0x....             LDR.N    R1,??DataTable11_22
   \   00000076   0x7188             STRB     R0,[R1, #+6]
    669              
    670              /* Done, so message can be removed from the buffer */
    671              AntDeQueueApplicationMessage();    
   \   00000078   0x.... 0x....      BL       AntDeQueueApplicationMessage
    672              return TRUE;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE000             B.N      ??AntReadAppMessageBuffer_3
    673            }
    674            
    675            /* Otherwise return FALSE and do not touch the current data array */
    676            return FALSE;
   \                     ??AntReadAppMessageBuffer_0: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??AntReadAppMessageBuffer_3: (+1)
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    677            
    678          } /* end AntReadAppMessageBuffer() */
    679          
    680          
    681          /*--------------------------------------------------------------------------------------------------------------------*/
    682          /* Protected functions                                                                                                */
    683          /*--------------------------------------------------------------------------------------------------------------------*/
    684          
    685          /*-----------------------------------------------------------------------------/
    686          Function: AntApiInitialize
    687          
    688          Description:
    689          Configures the Ant API task.
    690          
    691          Requires:
    692            - 
    693          
    694          Promises:
    695            - 
    696          */

   \                                 In section .text, align 2, keep-with-next
    697          void AntApiInitialize(void)
    698          {
   \                     AntApiInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    699            /* If good initialization, set state to Idle */
    700            if( 1 )
    701            {
    702              DebugPrintf("ANT API ready\n\r");
   \   00000002   0x....             LDR.N    R0,??DataTable11_23
   \   00000004   0x.... 0x....      BL       DebugPrintf
    703              AntApi_StateMachine = AntApiSM_Idle;
   \   00000008   0x.... 0x....      ADR.W    R0,AntApiSM_Idle
   \   0000000C   0x....             LDR.N    R1,??DataTable11_11
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    704            }
    705            else
    706            {
    707              /* The task isn't properly initialized, so shut it down and don't run */
    708              AntApi_StateMachine = AntApiSM_FailedInit;
    709            }
    710          
    711          } /* end AntApiInitialize() */
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    712          
    713          
    714          /*----------------------------------------------------------------------------------------------------------------------
    715          Function UserAppRunActiveState()
    716          
    717          Description:
    718          Selects and runs one iteration of the current state in the state machine.
    719          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    720          may take 1ms / n to execute.
    721          
    722          Requires:
    723            - State machine function pointer points at current state
    724          
    725          Promises:
    726            - Calls the function to pointed by the state machine function pointer
    727          */

   \                                 In section .text, align 2, keep-with-next
    728          void AntApiRunActiveState(void)
    729          {
   \                     AntApiRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    730            AntApi_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable11_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    731          
    732          } /* end AntApiRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    733          
    734          
    735          /**********************************************************************************************************************
    736          State Machine Function Definitions
    737          **********************************************************************************************************************/
    738          
    739          /*-------------------------------------------------------------------------------------------------------------------*/
    740          /* Wait for a message to be queued */

   \                                 In section .text, align 4, keep-with-next
    741          static void AntApiSM_Idle(void)
    742          {
    743            /* Monitor requests to send generic ANT messages */
    744            
    745          } /* end AntApiSM_Idle() */
   \                     AntApiSM_Idle: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    746               
    747          
    748          /*-------------------------------------------------------------------------------------------------------------------*/
    749          /* Send all configuration messages to ANT to fully assign the channel.
    750          The selected channel has already been verified unconfigured, and all required setup
    751          messages are ready to go.  */

   \                                 In section .text, align 4, keep-with-next
    752          static void  AntApiSM_AssignChannel(void)          
    753          {
   \                     AntApiSM_AssignChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    754            static u8 u8CurrentMessageToSend = 0;
    755            static u8 u8CurrentMesssageId = 0;
    756            static bool bMessageInProgress = FALSE;
    757            
    758            /* Queue the next message if it's time */
    759            if(bMessageInProgress == FALSE)
   \   00000002   0x....             LDR.N    R0,??DataTable11_24
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD111             BNE.N    ??AntApiSM_AssignChannel_0
    760            {
    761              u8CurrentMesssageId = *(AntApi_apu8AntAssignChannel[u8CurrentMessageToSend] + BUFFER_INDEX_MESG_ID); 
   \   0000000A   0x....             LDR.N    R0,??DataTable11_25
   \   0000000C   0x....             LDR.N    R1,??DataTable11_26
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x....             LDR.N    R1,??DataTable11_27
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    762              AntQueueOutgoingMessage(AntApi_apu8AntAssignChannel[u8CurrentMessageToSend]);
   \   0000001A   0x....             LDR.N    R0,??DataTable11_25
   \   0000001C   0x....             LDR.N    R1,??DataTable11_26
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000024   0x.... 0x....      BL       AntQueueOutgoingMessage
    763              bMessageInProgress = TRUE;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable11_24
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    764            }
    765            
    766            /* Check message status */
    767            if( u8CurrentMesssageId == G_stMessageResponse.u8MessageNumber )
   \                     ??AntApiSM_AssignChannel_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable11_27
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable11_28
   \   00000034   0x7849             LDRB     R1,[R1, #+1]
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD139             BNE.N    ??AntApiSM_AssignChannel_1
    768            { 
    769              if(G_stMessageResponse.u8ResponseCode == RESPONSE_NO_ERROR)
   \   0000003A   0x....             LDR.N    R0,??DataTable11_28
   \   0000003C   0x7880             LDRB     R0,[R0, #+2]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD129             BNE.N    ??AntApiSM_AssignChannel_2
    770              {
    771                /* Increment message pointer and check if complete */
    772                u8CurrentMessageToSend++;
   \   00000042   0x....             LDR.N    R0,??DataTable11_26
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable11_26
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    773                if(u8CurrentMessageToSend == ANT_ASSIGN_MESSAGES)
   \   0000004C   0x....             LDR.N    R0,??DataTable11_26
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2807             CMP      R0,#+7
   \   00000052   0xD129             BNE.N    ??AntApiSM_AssignChannel_3
    774                {
    775                  /* Print OK message and update the channel flags */
    776                  G_au8AntMessageAssign[12] = G_stMessageResponse.u8Channel;
   \   00000054   0x....             LDR.N    R0,??DataTable11_28
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x....             LDR.N    R1,??DataTable11_29
   \   0000005A   0x7308             STRB     R0,[R1, #+12]
    777                  DebugPrintf(G_au8AntMessageAssign);
   \   0000005C   0x....             LDR.N    R0,??DataTable11_29
   \   0000005E   0x.... 0x....      BL       DebugPrintf
    778                  DebugPrintf(G_au8AntMessageOk);
   \   00000062   0x....             LDR.N    R0,??DataTable11_30
   \   00000064   0x.... 0x....      BL       DebugPrintf
    779                  G_asAntChannelConfiguration[G_stMessageResponse.u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_CONFIGURED;
   \   00000068   0x....             LDR.N    R0,??DataTable11_3
   \   0000006A   0x....             LDR.N    R1,??DataTable11_28
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0x2214             MOVS     R2,#+20
   \   00000070   0x4351             MULS     R1,R2,R1
   \   00000072   0x4408             ADD      R0,R0,R1
   \   00000074   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000076   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000007A   0x....             LDR.N    R1,??DataTable11_3
   \   0000007C   0x....             LDR.N    R2,??DataTable11_28
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
   \   00000080   0x2314             MOVS     R3,#+20
   \   00000082   0x435A             MULS     R2,R3,R2
   \   00000084   0x4411             ADD      R1,R1,R2
   \   00000086   0x74C8             STRB     R0,[R1, #+19]
    780          
    781                  /* Clean up and exit this state */
    782                  u8CurrentMessageToSend = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x....             LDR.N    R1,??DataTable11_26
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    783                  AntApi_StateMachine = AntApiSM_Idle;
   \   0000008E   0x....             LDR.N    R0,??DataTable11_31
   \   00000090   0x....             LDR.N    R1,??DataTable11_11
   \   00000092   0x6008             STR      R0,[R1, #+0]
   \   00000094   0xE008             B.N      ??AntApiSM_AssignChannel_3
    784                }
    785              } 
    786              else
    787              {
    788                /* Report the error and return.  Channel flags will remain clear for application to check. */
    789                DebugPrintf(G_au8AntMessageAssign);
   \                     ??AntApiSM_AssignChannel_2: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable11_29
   \   00000098   0x.... 0x....      BL       DebugPrintf
    790                DebugPrintf(G_au8AntMessageFail);
   \   0000009C   0x....             LDR.N    R0,??DataTable11_32
   \   0000009E   0x.... 0x....      BL       DebugPrintf
    791                AntApi_StateMachine = AntApiSM_Idle;
   \   000000A2   0x....             LDR.N    R0,??DataTable11_31
   \   000000A4   0x....             LDR.N    R1,??DataTable11_11
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    792              }
    793          
    794              /* In either case, clean up the following: */
    795              bMessageInProgress = FALSE;
   \                     ??AntApiSM_AssignChannel_3: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x....             LDR.N    R1,??DataTable11_24
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    796          
    797            } /* end if( u8CurrentMesssageId == G_stMessageResponse.u8MessageNumber ) */
    798            
    799            /* Check for timeout */
    800            if(IsTimeUp(&AntApi_u32Timeout, ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntApiSM_AssignChannel_1: (+1)
   \   000000AE   0xF242 0x7110      MOVW     R1,#+10000
   \   000000B2   0x....             LDR.N    R0,??DataTable11_10
   \   000000B4   0x.... 0x....      BL       IsTimeUp
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD008             BEQ.N    ??AntApiSM_AssignChannel_4
    801            {
    802              /* Report the error and return.  Channel flags will remain clear for application to check. */
    803              DebugPrintf(G_au8AntMessageAssign);
   \   000000BC   0x....             LDR.N    R0,??DataTable11_29
   \   000000BE   0x.... 0x....      BL       DebugPrintf
    804              DebugPrintf(G_au8AntMessageFail);
   \   000000C2   0x....             LDR.N    R0,??DataTable11_32
   \   000000C4   0x.... 0x....      BL       DebugPrintf
    805              AntApi_StateMachine = AntApiSM_Idle;
   \   000000C8   0x....             LDR.N    R0,??DataTable11_31
   \   000000CA   0x....             LDR.N    R1,??DataTable11_11
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    806            }
    807            
    808          } /* end AntApiSM_AssignChannel() */
   \                     ??AntApiSM_AssignChannel_4: (+1)
   \   000000CE   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 1
   \                     `AntApiSM_AssignChannel::u8CurrentMessageToSend`:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     `AntApiSM_AssignChannel::u8CurrentMesssageId`:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     `AntApiSM_AssignChannel::bMessageInProgress`:
   \   00000000                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     G_au8AntLibConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     G_au8AntSetNetworkKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     G_asAntChannelConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     G_au8AntAssignChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     G_au8AntSetChannelID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     G_au8AntSetChannelPeriod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     G_au8AntSetChannelRFFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     G_au8AntSetChannelPower

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     AntApi_u32Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     AntApi_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x........         DC32     G_au8AntBroadcastDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x........         DC32     G_au8AntAckDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0x........         DC32     G_u32AntApiCurrentMessageTimeStamp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x........         DC32     G_eAntApiCurrentMessageClass

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   0x........         DC32     G_au8AntApiCurrentMessageBytes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   0x........         DC32     G_sAntApiCurrentMessageExtData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   0x........         DC32     `AntApiSM_AssignChannel::bMessageInProgress`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \   00000000   0x........         DC32     AntApi_apu8AntAssignChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \   00000000   0x........         DC32     `AntApiSM_AssignChannel::u8CurrentMessageToSend`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \   00000000   0x........         DC32     `AntApiSM_AssignChannel::u8CurrentMesssageId`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \   00000000   0x........         DC32     G_stMessageResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_29:
   \   00000000   0x........         DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_30:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_31:
   \   00000000   0x........         DC32     AntApiSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_32:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x6E          DC8 41H, 6EH, 74H, 41H, 73H, 73H, 69H, 67H
   \              0x74 0x41    
   \              0x73 0x73    
   \              0x69 0x67    
   \   00000008   0x6E 0x43          DC8 6EH, 43H, 68H, 61H, 6EH, 6EH, 65H, 6CH
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \   00000010   0x20 0x65          DC8 20H, 65H, 72H, 72H, 6FH, 72H, 3AH, 20H
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \   00000018   0x63 0x68          DC8 63H, 68H, 61H, 6EH, 6EH, 65H, 6CH, 20H
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \   00000020   0x69 0x73          DC8 69H, 73H, 20H, 6EH, 6FH, 74H, 20H, 75H
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x75    
   \   00000028   0x6E 0x63          DC8 6EH, 63H, 6FH, 6EH, 66H, 69H, 67H, 75H
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \   00000030   0x72 0x65          DC8 72H, 65H, 64H, 0AH, 0DH, 0
   \              0x64 0x0A    
   \              0x0D 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x01 0x41          DC8 1, 65, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x01 0x4B          DC8 1, 75, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x01 0x5B          DC8 1, 91, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x01 0x4C          DC8 1, 76, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x41 0x4E          DC8 "ANT API ready\012\015"
   \              0x54 0x20    
   \              0x41 0x50    
   \              0x49 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    809          
    810          
    811          #if 0
    812          /*-------------------------------------------------------------------------------------------------------------------*/
    813          /* Handle an error */
    814          static void  AntApiSM_Error(void)          
    815          {
    816            
    817          } /* end AntApiSM_Error() */
    818          #endif
    819          
    820          
    821          /*-------------------------------------------------------------------------------------------------------------------*/
    822          /* State to sit in if init failed */
    823          static void  AntApiSM_FailedInit(void)          
    824          {
    825              
    826          } /* end AntApiSM_FailedInit() */
    827          
    828          
    829          /*--------------------------------------------------------------------------------------------------------------------*/
    830          /* End of File                                                                                                        */
    831          /*--------------------------------------------------------------------------------------------------------------------*/
    832          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AntApiInitialize
         8   -> DebugPrintf
       8   AntApiRunActiveState
         8   -- Indirect call
       8   AntApiSM_AssignChannel
         8   -> AntQueueOutgoingMessage
         8   -> DebugPrintf
         8   -> IsTimeUp
       0   AntApiSM_Idle
       8   AntAssignChannel
         8   -> AntCalculateTxChecksum
         8   -> AntRadioStatusChannel
         8   -> DebugPrintf
      16   AntCloseChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
      16   AntOpenChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
       8   AntOpenScanningChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
      16   AntQueueAcknowledgedMessage
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
      16   AntQueueBroadcastMessage
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
       0   AntRadioStatusChannel
       8   AntReadAppMessageBuffer
         8   -> AntDeQueueApplicationMessage
      16   AntUnassignChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      56  ?_0
       4  ?_1
       4  ?_2
       4  ?_3
       4  ?_4
      16  ?_5
      18  AntApiInitialize
      10  AntApiRunActiveState
     208  AntApiSM_AssignChannel
       2  AntApiSM_Idle
       4  AntApi_StateMachine
      28  AntApi_apu8AntAssignChannel
       4  AntApi_u32Timeout
     494  AntAssignChannel
      68  AntCloseChannelNumber
      74  AntOpenChannelNumber
      40  AntOpenScanningChannel
      52  AntQueueAcknowledgedMessage
      52  AntQueueBroadcastMessage
      72  AntRadioStatusChannel
     132  AntReadAppMessageBuffer
      70  AntUnassignChannelNumber
       8  G_au8AntApiCurrentMessageBytes
       1  G_eAntApiCurrentMessageClass
       8  G_sAntApiCurrentMessageExtData
       4  G_u32AntApiCurrentMessageTimeStamp
       4  G_u32AntApiFlags
       1  bMessageInProgress
       1  u8CurrentMessageToSend
       1  u8CurrentMesssageId

 
    36 bytes in section .bss
    28 bytes in section .data
    88 bytes in section .rodata
 1 424 bytes in section .text
 
 1 424 bytes of CODE  memory
    88 bytes of CONST memory
    64 bytes of DATA  memory

Errors: none
Warnings: none
