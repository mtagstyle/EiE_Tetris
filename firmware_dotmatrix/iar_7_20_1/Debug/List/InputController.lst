###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       22/Mar/2018  01:39:05
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\InputController.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\InputController.c"
#        -D MPGL2 -D MPG2 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -o "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\bsp\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\tetris\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List\InputController.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj\InputController.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\InputController.c
      1          #include "Configuration.h"
      2          #include "InputController.h"

  #define DEBUG_MODE 0
          ^
"C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\Defs.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "DEBUG_MODE" (declared at line 27)
      3          #include "Commands.h"
      4          

   \                                 In section .bss, align 4
      5          static InputMap buttonA, buttonB, sliderUp, sliderDown, sliderLeft, sliderRight;
   \                     buttonA:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
   \                     buttonB:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
   \                     sliderUp:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
   \                     sliderDown:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
   \                     sliderLeft:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
   \                     sliderRight:
   \   00000000                      DS8 16
      6          

   \                                 In section .bss, align 4
      7          InputMap* mappings[MAX_MAPPINGS];
   \                     mappings:
   \   00000000                      DS8 24
      8          

   \                                 In section .text, align 2, keep-with-next
      9          bool check_button_trigger(PhysicalDevice* device)
     10          {
   \                     check_button_trigger: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     11              //Here, we check for only when the user lets go of the button, then we trigger a send
     12              if(device != NULL && device->physical_type == BUTTON)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD019             BEQ.N    ??check_button_trigger_0
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD116             BNE.N    ??check_button_trigger_0
     13              {
     14                  //Button can be in pressed or unpressed state
     15                  switch(device->data)
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??check_button_trigger_1
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD00A             BEQ.N    ??check_button_trigger_2
   \   00000018   0xE010             B.N      ??check_button_trigger_0
     16                  {
     17                      case BUTTON_STATE_UNPRESSED:
     18                          if(IsButtonPressed(device->dev_address) == true)
   \                     ??check_button_trigger_1: (+1)
   \   0000001A   0x8860             LDRH     R0,[R4, #+2]
   \   0000001C   0x.... 0x....      BL       IsButtonPressed
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD103             BNE.N    ??check_button_trigger_3
     19                          {
     20                              device->data = BUTTON_STATE_PRESSED;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x60A0             STR      R0,[R4, #+8]
     21                              return true;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE008             B.N      ??check_button_trigger_4
     22                          }
     23                      break;
   \                     ??check_button_trigger_3: (+1)
   \   0000002C   0xE006             B.N      ??check_button_trigger_0
     24          
     25                      case BUTTON_STATE_PRESSED:
     26                          if(IsButtonPressed(device->dev_address) == false)
   \                     ??check_button_trigger_2: (+1)
   \   0000002E   0x8860             LDRH     R0,[R4, #+2]
   \   00000030   0x.... 0x....      BL       IsButtonPressed
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??check_button_trigger_5
     27                          {
     28                              device->data = BUTTON_STATE_UNPRESSED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x60A0             STR      R0,[R4, #+8]
     29                          }
     30                      break;
     31                  }
     32              }
     33          
     34              return false;
   \                     ??check_button_trigger_5: (+1)
   \                     ??check_button_trigger_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??check_button_trigger_4: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
     35          }
     36          

   \                                 In section .text, align 2, keep-with-next
     37          uint8_t read_slider(uint8_t horz_or_vertical)
     38          {
   \                     read_slider: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     39              if(horz_or_vertical == H_SLIDER)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C02             CMP      R4,#+2
   \   00000008   0xD102             BNE.N    ??read_slider_0
     40              {
     41                  return CaptouchCurrentHSlidePosition();
   \   0000000A   0x.... 0x....      BL       CaptouchCurrentHSlidePosition
   \   0000000E   0xE009             B.N      ??read_slider_1
     42              }
     43              else if(horz_or_vertical == V_SLIDER)
   \                     ??read_slider_0: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C03             CMP      R4,#+3
   \   00000014   0xD105             BNE.N    ??read_slider_2
     44              {
     45                  //VSlider's 0 is the top, while 255 is the bottom. We invert this value
     46                  return 255-CaptouchCurrentVSlidePosition();
   \   00000016   0x.... 0x....      BL       CaptouchCurrentVSlidePosition
   \   0000001A   0xF1D0 0x00FF      RSBS     R0,R0,#+255
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xE000             B.N      ??read_slider_1
     47              }
     48              else
     49              {
     50                  return 0; //Should never get here
   \                     ??read_slider_2: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??read_slider_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
     51              }
     52          }
     53          

   \                                 In section .text, align 2, keep-with-next
     54          bool check_capacitive_trigger(PhysicalDevice* device)
     55          {
   \                     check_capacitive_trigger: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
     56              bool toReturn = false;
   \   00000006   0x2500             MOVS     R5,#+0
     57              if(device != NULL && device->physical_type == CAPACITIVE)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD063             BEQ.N    ??check_capacitive_trigger_0
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD160             BNE.N    ??check_capacitive_trigger_0
     58              {
     59                  //Obtain device address parameters
     60                  uint8_t  upOrDown =      (device->dev_address & UP_OR_DOWN_MASK) >> 8;
   \   00000012   0x8860             LDRH     R0,[R4, #+2]
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x0A06             LSRS     R6,R0,#+8
     61                  uint8_t  sliderType =     device->dev_address & DEVICE_ADDRESS_MASK;
   \   00000018   0x8867             LDRH     R7,[R4, #+2]
     62                  //Obtain device data parameters
     63                  sint16_t lastSlideValue = device->data & SLIDER_DATA_MASK;
   \   0000001A   0x7A20             LDRB     R0,[R4, #+8]
   \   0000001C   0xF000 0x08FF      AND      R8,R0,#0xFF
     64                  uint8_t  numOfIdenticalSamples = (device->data & IDENTICAL_SAMPLES_MASK) >> 8;
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0xEA5F 0x2910      LSRS     R9,R0,#+8
     65                  uint8_t  currentSlideValue = read_slider(sliderType);
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       read_slider
     66          
     67                  //DebugPrintNumber(currentSlideValue);
     68                  //DebugPrintf("  ");
     69                  
     70                  //Identical samples >= 10
     71                  if( numOfIdenticalSamples >= 2 )
   \   0000002E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000032   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000036   0xDB13             BLT.N    ??check_capacitive_trigger_1
     72                  {
     73                      //Last sample != current sample
     74                      if( lastSlideValue != currentSlideValue )
   \   00000038   0x4641             MOV      R1,R8
   \   0000003A   0x0002             MOVS     R2,R0
   \   0000003C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003E   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000040   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000042   0x4291             CMP      R1,R2
   \   00000044   0xD03E             BEQ.N    ??check_capacitive_trigger_2
     75                      {
     76                          numOfIdenticalSamples = 0;
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x4689             MOV      R9,R1
     77                          device->data &= ~IDENTICAL_SAMPLES_MASK;
   \   0000004A   0x68A1             LDR      R1,[R4, #+8]
   \   0000004C   0xF431 0x417F      BICS     R1,R1,#0xFF00
   \   00000050   0x60A1             STR      R1,[R4, #+8]
     78                          device->data |= (numOfIdenticalSamples << 8);
   \   00000052   0x68A1             LDR      R1,[R4, #+8]
   \   00000054   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000058   0xEA51 0x2109      ORRS     R1,R1,R9, LSL #+8
   \   0000005C   0x60A1             STR      R1,[R4, #+8]
   \   0000005E   0xE031             B.N      ??check_capacitive_trigger_2
     79                      }
     80                  }
     81                  //Identical Samples < 10
     82                  else if( numOfIdenticalSamples < 10 )
   \                     ??check_capacitive_trigger_1: (+1)
   \   00000060   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000064   0xF1B9 0x0F0A      CMP      R9,#+10
   \   00000068   0xDA2C             BGE.N    ??check_capacitive_trigger_2
     83                  {
     84                      //Last sample == current sample
     85                      if( lastSlideValue == currentSlideValue )
   \   0000006A   0x4641             MOV      R1,R8
   \   0000006C   0x0002             MOVS     R2,R0
   \   0000006E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000070   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000072   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xD10C             BNE.N    ??check_capacitive_trigger_3
     86                      {
     87                          numOfIdenticalSamples++;
   \   00000078   0xF119 0x0901      ADDS     R9,R9,#+1
     88                          device->data &= ~IDENTICAL_SAMPLES_MASK;
   \   0000007C   0x68A1             LDR      R1,[R4, #+8]
   \   0000007E   0xF431 0x417F      BICS     R1,R1,#0xFF00
   \   00000082   0x60A1             STR      R1,[R4, #+8]
     89                          device->data |= (numOfIdenticalSamples << 8);
   \   00000084   0x68A1             LDR      R1,[R4, #+8]
   \   00000086   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000008A   0xEA51 0x2109      ORRS     R1,R1,R9, LSL #+8
   \   0000008E   0x60A1             STR      R1,[R4, #+8]
   \   00000090   0xE018             B.N      ??check_capacitive_trigger_2
     90                      }
     91                      else
     92                      {
     93                          //Is the current sample > threshold?
     94                          if( upOrDown == UP )
   \                     ??check_capacitive_trigger_3: (+1)
   \   00000092   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000094   0x2E01             CMP      R6,#+1
   \   00000096   0xD109             BNE.N    ??check_capacitive_trigger_4
     95                          {
     96                              if( currentSlideValue > (lastSlideValue + SLIDE_SENSITIVITY))
   \   00000098   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000009C   0xF118 0x0133      ADDS     R1,R8,#+51
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x4281             CMP      R1,R0
   \   000000A4   0xDA0E             BGE.N    ??check_capacitive_trigger_2
     97                              {
     98                                  //DebugPrintf("Moved right\r\n");
     99                                  toReturn = true;
   \   000000A6   0x2101             MOVS     R1,#+1
   \   000000A8   0x000D             MOVS     R5,R1
   \   000000AA   0xE00B             B.N      ??check_capacitive_trigger_2
    100                              }
    101                          }
    102                          else if ( upOrDown == DOWN)
   \                     ??check_capacitive_trigger_4: (+1)
   \   000000AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AE   0x2E02             CMP      R6,#+2
   \   000000B0   0xD108             BNE.N    ??check_capacitive_trigger_2
    103                          {
    104                              if( currentSlideValue < (lastSlideValue-SLIDE_SENSITIVITY))
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   000000B8   0xF1B8 0x0133      SUBS     R1,R8,#+51
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xDA01             BGE.N    ??check_capacitive_trigger_2
    105                              {
    106                                  //DebugPrintf("Moved left\r\n");
    107                                  toReturn = true;
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0x000D             MOVS     R5,R1
    108                              }
    109                          }
    110                      }
    111                  }
    112          
    113                  device->data &= ~SLIDER_DATA_MASK;
   \                     ??check_capacitive_trigger_2: (+1)
   \   000000C4   0x68A1             LDR      R1,[R4, #+8]
   \   000000C6   0x0A09             LSRS     R1,R1,#+8
   \   000000C8   0x0209             LSLS     R1,R1,#+8
   \   000000CA   0x60A1             STR      R1,[R4, #+8]
    114                  device->data |= currentSlideValue;
   \   000000CC   0x68A1             LDR      R1,[R4, #+8]
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0x4308             ORRS     R0,R0,R1
   \   000000D2   0x60A0             STR      R0,[R4, #+8]
    115              }
    116          
    117              return toReturn;    
   \                     ??check_capacitive_trigger_0: (+1)
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          PhysicalDevice create_capacitive_device(uint16_t dev_address, uint8_t upOrDown)
    121          {
   \                     create_capacitive_device: (+1)
   \   00000000   0xB47E             PUSH     {R1-R6}
    122              PhysicalDevice device;
    123              device.physical_type = CAPACITIVE;
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xF88D 0x3000      STRB     R3,[SP, #+0]
    124              device.dev_address = 0;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0xF8AD 0x3002      STRH     R3,[SP, #+2]
    125              //Upper byte contains whether to check for delta up or down
    126              device.dev_address |= (upOrDown << 8);
   \   0000000E   0xF8BD 0x3002      LDRH     R3,[SP, #+2]
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0xEA53 0x2302      ORRS     R3,R3,R2, LSL #+8
   \   00000018   0xF8AD 0x3002      STRH     R3,[SP, #+2]
    127              //Lower byte contains the capacitive device index
    128              device.dev_address |= (dev_address & DEVICE_ADDRESS_MASK);
   \   0000001C   0xF8BD 0x3002      LDRH     R3,[SP, #+2]
   \   00000020   0xF001 0x04FF      AND      R4,R1,#0xFF
   \   00000024   0x4323             ORRS     R3,R4,R3
   \   00000026   0xF8AD 0x3002      STRH     R3,[SP, #+2]
    129              device.data = 0;
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x9302             STR      R3,[SP, #+8]
    130          
    131              device.need_send = &check_capacitive_trigger;
   \   0000002E   0x....             LDR.N    R3,??DataTable3
   \   00000030   0x9301             STR      R3,[SP, #+4]
    132              return device;
   \   00000032   0x466B             MOV      R3,SP
   \   00000034   0xCB70             LDM      R3!,{R4-R6}
   \   00000036   0xC070             STM      R0!,{R4-R6}
   \   00000038   0x3B0C             SUBS     R3,R3,#+12
   \   0000003A   0x380C             SUBS     R0,R0,#+12
   \   0000003C   0xBC77             POP      {R0-R2,R4-R6}
   \   0000003E   0x4770             BX       LR               ;; return
    133          }
    134          

   \                                 In section .text, align 2, keep-with-next
    135          PhysicalDevice create_button_device(uint16_t dev_address)
    136          {
   \                     create_button_device: (+1)
   \   00000000   0xB43E             PUSH     {R1-R5}
    137              PhysicalDevice device;
    138              device.physical_type = BUTTON;
   \   00000002   0x2202             MOVS     R2,#+2
   \   00000004   0xF88D 0x2000      STRB     R2,[SP, #+0]
    139              device.dev_address = dev_address;
   \   00000008   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    140              device.data = BUTTON_STATE_UNPRESSED;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x9202             STR      R2,[SP, #+8]
    141          
    142              device.need_send = &check_button_trigger;
   \   00000010   0x....             LDR.N    R2,??DataTable3_1
   \   00000012   0x9201             STR      R2,[SP, #+4]
    143              return device;
   \   00000014   0x466A             MOV      R2,SP
   \   00000016   0xCA38             LDM      R2!,{R3-R5}
   \   00000018   0xC038             STM      R0!,{R3-R5}
   \   0000001A   0x3A0C             SUBS     R2,R2,#+12
   \   0000001C   0x380C             SUBS     R0,R0,#+12
   \   0000001E   0xBC37             POP      {R0-R2,R4,R5}
   \   00000020   0x4770             BX       LR               ;; return
    144          }
    145          

   \                                 In section .text, align 2, keep-with-next
    146          LogicalDevice create_logical_device(LogicalInputTypes type)
    147          {
   \                     create_logical_device: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0001             MOVS     R1,R0
    148              LogicalDevice device;
    149              device.logical_type = type;
   \   00000004   0xF88D 0x1000      STRB     R1,[SP, #+0]
    150          
    151              return device;
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0x4770             BX       LR               ;; return
    152          }
    153          

   \                                 In section .text, align 2, keep-with-next
    154          void InputController_Initialize(void)
    155          {
   \                     InputController_Initialize: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    156              uint8_t i = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    157          
    158              buttonA.logical_input =   create_logical_device(INPUT_B);
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x.... 0x....      BL       create_logical_device
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x....             LDR.N    R0,??DataTable3_2
   \   00000010   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000014   0x7001             STRB     R1,[R0, #+0]
    159              buttonA.physical_input =  create_button_device(BUTTON_0);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       create_button_device
   \   0000001E   0x....             LDR.N    R0,??DataTable3_3
   \   00000020   0xA901             ADD      R1,SP,#+4
   \   00000022   0xC92C             LDM      R1!,{R2,R3,R5}
   \   00000024   0xC02C             STM      R0!,{R2,R3,R5}
   \   00000026   0x390C             SUBS     R1,R1,#+12
   \   00000028   0x380C             SUBS     R0,R0,#+12
    160              mappings[i++] = &buttonA;
   \   0000002A   0x....             LDR.N    R0,??DataTable3_2
   \   0000002C   0x....             LDR.N    R1,??DataTable3_4
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   00000034   0x1C64             ADDS     R4,R4,#+1
    161          
    162              buttonB.logical_input =   create_logical_device(INPUT_A);
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       create_logical_device
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0x....             LDR.N    R0,??DataTable3_5
   \   00000040   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    163              buttonB.physical_input =  create_button_device(BUTTON_1);
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xA801             ADD      R0,SP,#+4
   \   0000004A   0x.... 0x....      BL       create_button_device
   \   0000004E   0x....             LDR.N    R0,??DataTable3_6
   \   00000050   0xA901             ADD      R1,SP,#+4
   \   00000052   0xC92C             LDM      R1!,{R2,R3,R5}
   \   00000054   0xC02C             STM      R0!,{R2,R3,R5}
   \   00000056   0x390C             SUBS     R1,R1,#+12
   \   00000058   0x380C             SUBS     R0,R0,#+12
    164              mappings[i++] = &buttonB;
   \   0000005A   0x....             LDR.N    R0,??DataTable3_5
   \   0000005C   0x....             LDR.N    R1,??DataTable3_4
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   00000064   0x1C64             ADDS     R4,R4,#+1
    165          
    166              sliderUp.logical_input =  create_logical_device(INPUT_UP);
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x.... 0x....      BL       create_logical_device
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0x....             LDR.N    R0,??DataTable3_7
   \   00000070   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000074   0x7001             STRB     R1,[R0, #+0]
    167              sliderUp.physical_input = create_capacitive_device(V_SLIDER, UP);
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x2103             MOVS     R1,#+3
   \   0000007A   0xA801             ADD      R0,SP,#+4
   \   0000007C   0x.... 0x....      BL       create_capacitive_device
   \   00000080   0x....             LDR.N    R0,??DataTable3_8
   \   00000082   0xA901             ADD      R1,SP,#+4
   \   00000084   0xC92C             LDM      R1!,{R2,R3,R5}
   \   00000086   0xC02C             STM      R0!,{R2,R3,R5}
   \   00000088   0x390C             SUBS     R1,R1,#+12
   \   0000008A   0x380C             SUBS     R0,R0,#+12
    168              mappings[i++] = &sliderUp;
   \   0000008C   0x....             LDR.N    R0,??DataTable3_7
   \   0000008E   0x....             LDR.N    R1,??DataTable3_4
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   00000096   0x1C64             ADDS     R4,R4,#+1
    169          
    170              sliderDown.logical_input =  create_logical_device(INPUT_DOWN);
   \   00000098   0x2004             MOVS     R0,#+4
   \   0000009A   0x.... 0x....      BL       create_logical_device
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable3_9
   \   000000A2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000A6   0x7001             STRB     R1,[R0, #+0]
    171              sliderDown.physical_input = create_capacitive_device(V_SLIDER, DOWN);
   \   000000A8   0x2202             MOVS     R2,#+2
   \   000000AA   0x2103             MOVS     R1,#+3
   \   000000AC   0xA801             ADD      R0,SP,#+4
   \   000000AE   0x.... 0x....      BL       create_capacitive_device
   \   000000B2   0x....             LDR.N    R0,??DataTable3_10
   \   000000B4   0xA901             ADD      R1,SP,#+4
   \   000000B6   0xC92C             LDM      R1!,{R2,R3,R5}
   \   000000B8   0xC02C             STM      R0!,{R2,R3,R5}
   \   000000BA   0x390C             SUBS     R1,R1,#+12
   \   000000BC   0x380C             SUBS     R0,R0,#+12
    172              mappings[i++] = &sliderDown;
   \   000000BE   0x....             LDR.N    R0,??DataTable3_9
   \   000000C0   0x....             LDR.N    R1,??DataTable3_4
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   000000C8   0x1C64             ADDS     R4,R4,#+1
    173          
    174              sliderLeft.logical_input =  create_logical_device(INPUT_LEFT);
   \   000000CA   0x2005             MOVS     R0,#+5
   \   000000CC   0x.... 0x....      BL       create_logical_device
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \   000000D2   0x....             LDR.N    R0,??DataTable3_11
   \   000000D4   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000D8   0x7001             STRB     R1,[R0, #+0]
    175              sliderLeft.physical_input = create_capacitive_device(H_SLIDER, DOWN);
   \   000000DA   0x2202             MOVS     R2,#+2
   \   000000DC   0x2102             MOVS     R1,#+2
   \   000000DE   0xA801             ADD      R0,SP,#+4
   \   000000E0   0x.... 0x....      BL       create_capacitive_device
   \   000000E4   0x....             LDR.N    R0,??DataTable3_12
   \   000000E6   0xA901             ADD      R1,SP,#+4
   \   000000E8   0xC92C             LDM      R1!,{R2,R3,R5}
   \   000000EA   0xC02C             STM      R0!,{R2,R3,R5}
   \   000000EC   0x390C             SUBS     R1,R1,#+12
   \   000000EE   0x380C             SUBS     R0,R0,#+12
    176              mappings[i++] = &sliderLeft;
   \   000000F0   0x....             LDR.N    R0,??DataTable3_11
   \   000000F2   0x....             LDR.N    R1,??DataTable3_4
   \   000000F4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F6   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   000000FA   0x1C64             ADDS     R4,R4,#+1
    177          
    178              sliderRight.logical_input =  create_logical_device(INPUT_RIGHT);
   \   000000FC   0x2006             MOVS     R0,#+6
   \   000000FE   0x.... 0x....      BL       create_logical_device
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x....             LDR.N    R0,??DataTable3_13
   \   00000106   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000010A   0x7001             STRB     R1,[R0, #+0]
    179              sliderRight.physical_input = create_capacitive_device(H_SLIDER, UP);
   \   0000010C   0x2201             MOVS     R2,#+1
   \   0000010E   0x2102             MOVS     R1,#+2
   \   00000110   0xA801             ADD      R0,SP,#+4
   \   00000112   0x.... 0x....      BL       create_capacitive_device
   \   00000116   0x....             LDR.N    R0,??DataTable3_14
   \   00000118   0xA901             ADD      R1,SP,#+4
   \   0000011A   0xC92C             LDM      R1!,{R2,R3,R5}
   \   0000011C   0xC02C             STM      R0!,{R2,R3,R5}
   \   0000011E   0x390C             SUBS     R1,R1,#+12
   \   00000120   0x380C             SUBS     R0,R0,#+12
    180              mappings[i++] = &sliderRight;
   \   00000122   0x....             LDR.N    R0,??DataTable3_13
   \   00000124   0x....             LDR.N    R1,??DataTable3_4
   \   00000126   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000128   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   0000012C   0x1C64             ADDS     R4,R4,#+1
    181          
    182              CapTouchOn();
   \   0000012E   0x.... 0x....      BL       CapTouchOn
    183          }
   \   00000132   0xB005             ADD      SP,SP,#+20
   \   00000134   0xBD30             POP      {R4,R5,PC}       ;; return
    184          

   \                                 In section .text, align 2, keep-with-next
    185          void InputController_RunInputController(void)
    186          {
   \                     InputController_RunInputController: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    187              //Iterate through each thing, check to see if the physical device needs send
    188              for(uint8_t i = 0 ; i < MAX_MAPPINGS; i++)
   \   00000002   0x2400             MOVS     R4,#+0
   \                     ??InputController_RunInputController_0: (+1)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C06             CMP      R4,#+6
   \   00000008   0xDA0F             BGE.N    ??InputController_RunInputController_1
    189              {
    190                  InputMap* mapping = mappings[i];
   \   0000000A   0x....             LDR.N    R0,??DataTable3_4
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xF850 0x5024      LDR      R5,[R0, R4, LSL #+2]
    191                  PhysicalDevice *phys_device = &(mapping->physical_input);
   \   00000012   0x1D2E             ADDS     R6,R5,#+4
    192          
    193                  //If it does, then flag for send update
    194                  if(phys_device->need_send(phys_device) == true)
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x6871             LDR      R1,[R6, #+4]
   \   00000018   0x4788             BLX      R1
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD103             BNE.N    ??InputController_RunInputController_2
    195                  {
    196                      channel_send(CHANNEL_GAMECONTROLLER, mapping->logical_input.logical_type);
   \   0000001E   0x7829             LDRB     R1,[R5, #+0]
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x.... 0x....      BL       channel_send
    197                  }
    198              }
   \                     ??InputController_RunInputController_2: (+1)
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0xE7EC             B.N      ??InputController_RunInputController_0
    199          }
   \                     ??InputController_RunInputController_1: (+1)
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     check_capacitive_trigger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     check_button_trigger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     buttonA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     buttonA+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     mappings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     buttonB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     buttonB+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     sliderUp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     sliderUp+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     sliderDown

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     sliderDown+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     sliderLeft

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     sliderLeft+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     sliderRight

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     sliderRight+0x4

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   InputController_Initialize
        32   -> CapTouchOn
        32   -> create_button_device
        32   -> create_capacitive_device
        32   -> create_logical_device
      16   InputController_RunInputController
        16   -- Indirect call
        16   -> channel_send
       8   check_button_trigger
         8   -> IsButtonPressed
      32   check_capacitive_trigger
        32   -> read_slider
      20   create_button_device
      24   create_capacitive_device
       4   create_logical_device
       8   read_slider
         8   -> CaptouchCurrentHSlidePosition
         8   -> CaptouchCurrentVSlidePosition


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     310  InputController_Initialize
      44  InputController_RunInputController
      16  buttonA
      16  buttonB
      64  check_button_trigger
     220  check_capacitive_trigger
      34  create_button_device
      64  create_capacitive_device
      14  create_logical_device
      24  mappings
      38  read_slider
      16  sliderDown
      16  sliderLeft
      16  sliderRight
      16  sliderUp

 
 120 bytes in section .bss
 848 bytes in section .text
 
 848 bytes of CODE memory
 120 bytes of DATA memory

Errors: none
Warnings: 1
