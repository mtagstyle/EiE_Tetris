###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       22/Mar/2018  01:24:52
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\sam3u_i2c.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\sam3u_i2c.c" -D
#        MPGL2 -D MPG2 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -o "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\bsp\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\tetris\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List\sam3u_i2c.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj\sam3u_i2c.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\sam3u_i2c.c
      1          /**********************************************************************************************************************
      2          File: sam3u_TWI.c                                                                
      3          
      4          Description: 
      5          Provides a driver to use TWI0 peripheral to send and receive data using interrupts.
      6          Currently Set at - 200kHz Master Mode.
      7          This is a simpler version of a serial system driver that does not use resource control
      8          through Request() and Release() calls
      9          
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          API:
     13          
     14          Public use Functions:
     15          
     16          bool TWI0ReadByte(u8 u8SlaveAddress_, u8* pu8RxBuffer_);
     17          bool TWI0ReadData(u8 u8SlaveAddress_, u8* pu8RxBuffer_, u32 u32Size_);
     18          u32 TWIWriteByte(TWIPeripheralType* psTWIPeripheral_, u8 u8Byte_, TWIStopType Send_);
     19          u32 TWIWriteData(TWIPeripheralType* psTWIPeripheral_, u32 u32Size_, u8* u8Data_, TWIStopType Send_);
     20          
     21          All of these functions return a value that should be checked to ensure the operation will be completed
     22          
     23          Both TWI0ReadByte and TWI0ReadData require that pu8RxBuffer is large enough to hold the data
     24          As well it is assumed, that since you know the amount of data to be sent, a stop can be sent
     25          when all bytes have benn received (and not tie the data and clock line low).
     26          
     27          WriteByte and WriteData have the option to hold the lines low as it waits for more data 
     28          to be queue. If a stop condition is not sent only Writes can follow until a stop condition is
     29          requested (as the current transmission isn't complete).
     30          
     31          !!!!! ISSUES: 
     32              - No Debugging of Read functionality
     33          
     34          **********************************************************************************************************************/
     35          
     36          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable14  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable14_1  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     37          
     38          
     39          /***********************************************************************************************************************
     40          Global variable definitions with scope across entire project.
     41          All Global variable names shall start with "G_"
     42          ***********************************************************************************************************************/
     43          /* New variables */
     44          
     45          /*--------------------------------------------------------------------------------------------------------------------*/
     46          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     47          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     48          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     49          
     50          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     51          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     52          
     53          
     54          /***********************************************************************************************************************
     55          Global variable definitions with scope limited to this local application.
     56          Variable names shall start with "TWI_" and be declared as static.
     57          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     58          static fnCode_type TWI_StateMachine;              /* The TWI application state machine function pointer */
   \                     TWI_StateMachine:
   \   00000000                      DS8 4
     59          

   \                                 In section .bss, align 4
     60          static u32 TWI_u32Timer;                          /* Counter used across states */
   \                     TWI_u32Timer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     61          static u32 TWI_u32Flags;                          /* Application flags for TWI */
   \                     TWI_u32Flags:
   \   00000000                      DS8 4
     62          

   \                                 In section .bss, align 4
     63          static TWIPeripheralType TWI_Peripheral0;         /* TWI0 peripheral object */
   \                     TWI_Peripheral0:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     64          static TWIPeripheralType* TWI0;
   \                     TWI0:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 4
     66          static u32 TWI_u32CurrentBytesRemaining;                        /* Down counter for number of bytes being clocked out */
   \                     TWI_u32CurrentBytesRemaining:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     67          static u8* TWI_pu8CurrentTxData;                                /* Pointer to current message being clocked out */
   \                     TWI_pu8CurrentTxData:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     68          static TWIMessageQueueType TWI_MessageBuffer[TX_QUEUE_SIZE];    /* A circular buffer that stores queued msgs stop condition */
   \                     TWI_MessageBuffer:
   \   00000000                      DS8 256

   \                                 In section .bss, align 1
     69          static u8 TWI_MessageBufferNextIndex;                           /* A pointer to the next position to place a message */
   \                     TWI_MessageBufferNextIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     70          static u8 TWI_MessageBufferCurIndex;                            /* A pointer to the current message that is being processed */
   \                     TWI_MessageBufferCurIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     71          static u8 TWI_MessageQueueLength;                               /* Counter to track the number of messages stored in the queue */
   \                     TWI_MessageQueueLength:
   \   00000000                      DS8 1
     72          
     73          
     74          /***********************************************************************************************************************
     75          Function Definitions
     76          ***********************************************************************************************************************/
     77          
     78          /*----------------------------------------------------------------------------------------------------------------------
     79          Function: TWI0ReadByte
     80          
     81          Description:
     82          Queues a TWI Read Message into TWI_MessageBuffer, will be processed after all msgs queued before it
     83            - Single byte
     84          
     85          Requires:
     86            - Initialization of the task
     87            - Requires that pu8RxBuffer has the space to save the data
     88          
     89          Promises:
     90            - Queues msg if there is space available
     91            - Returns TRUE if successful queue
     92          */

   \                                 In section .text, align 2, keep-with-next
     93          bool TWI0ReadByte(u8 u8SlaveAddress_, u8* pu8RxBuffer_)
     94          {
   \                     TWI0ReadByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     95            if(TWI_MessageQueueLength == TX_QUEUE_SIZE || (TWI0->u32Flags & _TWI_TRANS_NOT_COMP))
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2810             CMP      R0,#+16
   \   0000000E   0xD005             BEQ.N    ??TWI0ReadByte_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x7B00             LDRB     R0,[R0, #+12]
   \   00000018   0x0740             LSLS     R0,R0,#+29
   \   0000001A   0xD501             BPL.N    ??TWI0ReadByte_1
     96            {
     97              /* TWI Message Task Queue Full or the Tx transmit isn't complete */
     98              return FALSE;
   \                     ??TWI0ReadByte_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE051             B.N      ??TWI0ReadByte_2
     99            }
    100            else
    101            {
    102              /* Queue Relevant data for TWI register setup */
    103              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = READ;
   \                     ??TWI0ReadByte_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000002A   0x7812             LDRB     R2,[R2, #+0]
   \   0000002C   0x0112             LSLS     R2,R2,#+4
   \   0000002E   0x5488             STRB     R0,[R1, R2]
    104              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000003A   0x7812             LDRB     R2,[R2, #+0]
   \   0000003C   0x0112             LSLS     R2,R2,#+4
   \   0000003E   0x4411             ADD      R1,R1,R2
   \   00000040   0x6048             STR      R0,[R1, #+4]
    105              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000004A   0x7809             LDRB     R1,[R1, #+0]
   \   0000004C   0x0109             LSLS     R1,R1,#+4
   \   0000004E   0x4408             ADD      R0,R0,R1
   \   00000050   0x7204             STRB     R4,[R0, #+8]
    106              TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer   = pu8RxBuffer_;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x0109             LSLS     R1,R1,#+4
   \   0000005E   0x4408             ADD      R0,R0,R1
   \   00000060   0x60C5             STR      R5,[R0, #+12]
    107              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000068   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000006C   0x7812             LDRB     R2,[R2, #+0]
   \   0000006E   0x0112             LSLS     R2,R2,#+4
   \   00000070   0x4411             ADD      R1,R1,R2
   \   00000072   0x7248             STRB     R0,[R1, #+9]
    108              
    109              /* Not used by Receive */
    110              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop = NA; 
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
   \   00000080   0x0112             LSLS     R2,R2,#+4
   \   00000082   0x4411             ADD      R1,R1,R2
   \   00000084   0x7288             STRB     R0,[R1, #+10]
    111               
    112              /* Update array pointers and size */
    113              TWI_MessageBufferNextIndex++;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    114              TWI_MessageQueueLength++;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    115              if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2810             CMP      R0,#+16
   \   000000AA   0xD103             BNE.N    ??TWI0ReadByte_3
    116              {
    117                TWI_MessageBufferNextIndex = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
    118              }
    119              
    120              /* If the system is initializing, we want to manually cycle the TWI task through one iteration
    121                to send the message */
    122              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0ReadByte_3: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD501             BPL.N    ??TWI0ReadByte_4
    123              {
    124                TWIManualMode();
   \   000000BE   0x.... 0x....      BL       TWIManualMode
    125              }
    126              
    127              return TRUE;
   \                     ??TWI0ReadByte_4: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \                     ??TWI0ReadByte_2: (+1)
   \   000000C4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    128            }
    129          
    130          } /* end TWI0ReadByte() */
    131          
    132          
    133          /*----------------------------------------------------------------------------------------------------------------------
    134          Function: TWI0ReadData
    135          
    136          Description:
    137          Queues a TWI Read Message into TWI_MessageBuffer, will be processed after all msgs queued before it
    138          
    139          Requires:
    140            - Initialization of the task
    141            - Requires pu8RxBuffer has the space to save the data
    142          
    143          Promises:
    144            - Queues a multi byte command into the command array
    145            - Returns TRUE if the queue was successful
    146          */

   \                                 In section .text, align 2, keep-with-next
    147          bool TWI0ReadData(u8 u8SlaveAddress_, u8* pu8RxBuffer_, u32 u32Size_)
    148          {
   \                     TWI0ReadData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    149            if(TWI_MessageQueueLength == TX_QUEUE_SIZE || (TWI0->u32Flags & _TWI_TRANS_NOT_COMP))
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2810             CMP      R0,#+16
   \   00000010   0xD005             BEQ.N    ??TWI0ReadData_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7B00             LDRB     R0,[R0, #+12]
   \   0000001A   0x0740             LSLS     R0,R0,#+29
   \   0000001C   0xD501             BPL.N    ??TWI0ReadData_1
    150            {
    151              /* TWI Message Task Queue Full or the Tx transmit isn't complete */
    152              return FALSE;
   \                     ??TWI0ReadData_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE050             B.N      ??TWI0ReadData_2
    153            }
    154            else
    155            {
    156              /* Queue Relevant data for TWI register setup */
    157              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = READ;
   \                     ??TWI0ReadData_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0x0112             LSLS     R2,R2,#+4
   \   00000030   0x5488             STRB     R0,[R1, R2]
    158              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = u32Size_;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000003A   0x7809             LDRB     R1,[R1, #+0]
   \   0000003C   0x0109             LSLS     R1,R1,#+4
   \   0000003E   0x4408             ADD      R0,R0,R1
   \   00000040   0x6046             STR      R6,[R0, #+4]
    159              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000004A   0x7809             LDRB     R1,[R1, #+0]
   \   0000004C   0x0109             LSLS     R1,R1,#+4
   \   0000004E   0x4408             ADD      R0,R0,R1
   \   00000050   0x7204             STRB     R4,[R0, #+8]
    160              TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer   = pu8RxBuffer_;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x0109             LSLS     R1,R1,#+4
   \   0000005E   0x4408             ADD      R0,R0,R1
   \   00000060   0x60C5             STR      R5,[R0, #+12]
    161              TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000068   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000006C   0x7812             LDRB     R2,[R2, #+0]
   \   0000006E   0x0112             LSLS     R2,R2,#+4
   \   00000070   0x4411             ADD      R1,R1,R2
   \   00000072   0x7248             STRB     R0,[R1, #+9]
    162              
    163              /* Not used by Receive */
    164              TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop = NA; 
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
   \   00000080   0x0112             LSLS     R2,R2,#+4
   \   00000082   0x4411             ADD      R1,R1,R2
   \   00000084   0x7288             STRB     R0,[R1, #+10]
    165              
    166              /* Update array pointers and size */
    167              TWI_MessageBufferNextIndex++;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    168              TWI_MessageQueueLength++;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    169              if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2810             CMP      R0,#+16
   \   000000AA   0xD103             BNE.N    ??TWI0ReadData_3
    170              {
    171                TWI_MessageBufferNextIndex = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
    172              }
    173              
    174              /* If the system is initializing, we want to manually cycle the TWI task through one iteration
    175                to send the message */
    176              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0ReadData_3: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD501             BPL.N    ??TWI0ReadData_4
    177              {
    178                TWIManualMode();
   \   000000BE   0x.... 0x....      BL       TWIManualMode
    179              }
    180              
    181              return TRUE;
   \                     ??TWI0ReadData_4: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \                     ??TWI0ReadData_2: (+1)
   \   000000C4   0xBD70             POP      {R4-R6,PC}       ;; return
    182            }
    183            
    184          } /* end TWI0ReadData() */
    185          
    186          
    187          /*----------------------------------------------------------------------------------------------------------------------
    188          Function: TWI0WriteByte
    189          
    190          Description:
    191          Queues a single byte for transfer on TWI0 peripheral.  
    192          
    193          Requires:
    194            - Initialization of the task
    195          
    196          Promises:
    197            - Creates a 1-byte message at TWI0->pTransmitBuffer that will be sent by the TWI application
    198              when it is available.
    199            - Returns the message token assigned to the message
    200          */

   \                                 In section .text, align 2, keep-with-next
    201          u32 TWI0WriteByte(u8 u8SlaveAddress_, u8 u8Byte_, TWIStopType Send_)
    202          {
   \                     TWI0WriteByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    203            u32 u32Token;
    204            u8 u8Data = u8Byte_;
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
    205            
    206            if(TWI_MessageQueueLength == TX_QUEUE_SIZE)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2810             CMP      R0,#+16
   \   00000014   0xD101             BNE.N    ??TWI0WriteByte_0
    207            {
    208              /* TWI Message Task Queue Full */
    209              return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE05C             B.N      ??TWI0WriteByte_1
    210            }
    211            else
    212            {
    213              /* Queue Message in message system */
    214              u32Token = QueueMessage(&TWI0->pTransmitBuffer, 1, &u8Data);
   \                     ??TWI0WriteByte_0: (+1)
   \   0000001A   0x466A             MOV      R2,SP
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x1D00             ADDS     R0,R0,#+4
   \   00000026   0x.... 0x....      BL       QueueMessage
   \   0000002A   0x0007             MOVS     R7,R0
    215              if(u32Token)
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD050             BEQ.N    ??TWI0WriteByte_2
    216              {
    217                /* Queue Relevant data for TWI register setup */
    218                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = WRITE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000003A   0x7812             LDRB     R2,[R2, #+0]
   \   0000003C   0x0112             LSLS     R2,R2,#+4
   \   0000003E   0x5488             STRB     R0,[R1, R2]
    219                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000004A   0x7812             LDRB     R2,[R2, #+0]
   \   0000004C   0x0112             LSLS     R2,R2,#+4
   \   0000004E   0x4411             ADD      R1,R1,R2
   \   00000050   0x6048             STR      R0,[R1, #+4]
    220                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x0109             LSLS     R1,R1,#+4
   \   0000005E   0x4408             ADD      R0,R0,R1
   \   00000060   0x7204             STRB     R4,[R0, #+8]
    221                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop          = Send_;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000006A   0x7809             LDRB     R1,[R1, #+0]
   \   0000006C   0x0109             LSLS     R1,R1,#+4
   \   0000006E   0x4408             ADD      R0,R0,R1
   \   00000070   0x7286             STRB     R6,[R0, #+10]
    222                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000078   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000007C   0x7812             LDRB     R2,[R2, #+0]
   \   0000007E   0x0112             LSLS     R2,R2,#+4
   \   00000080   0x4411             ADD      R1,R1,R2
   \   00000082   0x7248             STRB     R0,[R1, #+9]
    223                
    224                /* Not used by Transmit */
    225                TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer = NULL;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000008E   0x7812             LDRB     R2,[R2, #+0]
   \   00000090   0x0112             LSLS     R2,R2,#+4
   \   00000092   0x4411             ADD      R1,R1,R2
   \   00000094   0x60C8             STR      R0,[R1, #+12]
    226                
    227                /* Update array pointers and size */
    228                TWI_MessageBufferNextIndex++;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000009A   0x7800             LDRB     R0,[R0, #+0]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000A2   0x7008             STRB     R0,[R1, #+0]
    229                TWI_MessageQueueLength++;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000B0   0x7008             STRB     R0,[R1, #+0]
    230                if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0x2810             CMP      R0,#+16
   \   000000BA   0xD103             BNE.N    ??TWI0WriteByte_3
    231                {
    232                  TWI_MessageBufferNextIndex = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    233                }
    234          
    235                /* If the system is initializing, we want to manually cycle the TWI task through one iteration
    236                to send the message */
    237                if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0WriteByte_3: (+1)
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD501             BPL.N    ??TWI0WriteByte_2
    238                {
    239                  TWIManualMode();
   \   000000CE   0x.... 0x....      BL       TWIManualMode
    240                }
    241              }
    242              
    243              return(u32Token);
   \                     ??TWI0WriteByte_2: (+1)
   \   000000D2   0x0038             MOVS     R0,R7
   \                     ??TWI0WriteByte_1: (+1)
   \   000000D4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    244            }
    245            
    246          } /* end TWIWriteByte() */
    247          
    248          
    249          /*----------------------------------------------------------------------------------------------------------------------
    250          Function: TWI0WriteData
    251          
    252          Description:
    253          Queues a data array for transfer on the  TWI0 peripheral.  
    254          
    255          Requires:
    256            - if a transmission is in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    257            - u32Size_ is the number of bytes in the data array
    258            - u8Data_ points to the first byte of the data array
    259          
    260          Promises:
    261            - adds the data message at TWI_Peripheral0->pTransmitBuffer buffer that will be sent by the TWI application
    262              when it is available.
    263            - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    264              G_u32MessagingFlags can be checked for the reason
    265          */

   \                                 In section .text, align 2, keep-with-next
    266          u32 TWI0WriteData(u8 u8SlaveAddress_, u32 u32Size_, u8* u8Data_, TWIStopType Send_)
    267          {
   \                     TWI0WriteData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    268            u32 u32Token;
    269              
    270            if(TWI_MessageQueueLength == TX_QUEUE_SIZE)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2810             CMP      R0,#+16
   \   00000014   0xD101             BNE.N    ??TWI0WriteData_0
    271            {
    272              /* Queue Message in message system */
    273              return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE05D             B.N      ??TWI0WriteData_1
    274            }
    275            else
    276            {
    277              /* Queue Message in message system */
    278              u32Token = QueueMessage(&TWI0->pTransmitBuffer, u32Size_, u8Data_);
   \                     ??TWI0WriteData_0: (+1)
   \   0000001A   0x0032             MOVS     R2,R6
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x1D00             ADDS     R0,R0,#+4
   \   00000026   0x.... 0x....      BL       QueueMessage
   \   0000002A   0x4680             MOV      R8,R0
    279              if(u32Token)
   \   0000002C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000030   0xD050             BEQ.N    ??TWI0WriteData_2
    280              {
    281                /* Queue Relevant data for TWI register setup */
    282                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Direction     = WRITE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0x0112             LSLS     R2,R2,#+4
   \   00000040   0x5488             STRB     R0,[R1, R2]
    283                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u32Size       = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x0112             LSLS     R2,R2,#+4
   \   00000050   0x4411             ADD      R1,R1,R2
   \   00000052   0x6048             STR      R0,[R1, #+4]
    284                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Address     = u8SlaveAddress_;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000005C   0x7809             LDRB     R1,[R1, #+0]
   \   0000005E   0x0109             LSLS     R1,R1,#+4
   \   00000060   0x4408             ADD      R0,R0,R1
   \   00000062   0x7204             STRB     R4,[R0, #+8]
    285                TWI_MessageBuffer[TWI_MessageBufferNextIndex].Stop          = Send_;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0x0109             LSLS     R1,R1,#+4
   \   00000070   0x4408             ADD      R0,R0,R1
   \   00000072   0x7287             STRB     R7,[R0, #+10]
    286                TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts    = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
   \   00000080   0x0112             LSLS     R2,R2,#+4
   \   00000082   0x4411             ADD      R1,R1,R2
   \   00000084   0x7248             STRB     R0,[R1, #+9]
    287                
    288                /* Not used by Transmit */
    289                TWI_MessageBuffer[TWI_MessageBufferNextIndex].pu8RxBuffer = NULL;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000008C   0x.... 0x....      LDR.W    R2,??DataTable14_5
   \   00000090   0x7812             LDRB     R2,[R2, #+0]
   \   00000092   0x0112             LSLS     R2,R2,#+4
   \   00000094   0x4411             ADD      R1,R1,R2
   \   00000096   0x60C8             STR      R0,[R1, #+12]
    290                
    291                /* Update array pointers and size */
    292                TWI_MessageBufferNextIndex++;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    293                TWI_MessageQueueLength++;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
    294                if(TWI_MessageBufferNextIndex == TX_QUEUE_SIZE)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x2810             CMP      R0,#+16
   \   000000BC   0xD103             BNE.N    ??TWI0WriteData_3
    295                {
    296                  TWI_MessageBufferNextIndex = 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
    297                }
    298          
    299                /* If the system is initializing, manually cycle the TWI task through one iteration to send the message */
    300                if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??TWI0WriteData_3: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD501             BPL.N    ??TWI0WriteData_2
    301                {
    302                  TWIManualMode();
   \   000000D0   0x.... 0x....      BL       TWIManualMode
    303                }
    304              }
    305            
    306              return(u32Token);
   \                     ??TWI0WriteData_2: (+1)
   \   000000D4   0x4640             MOV      R0,R8
   \                     ??TWI0WriteData_1: (+1)
   \   000000D6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    307            }
    308            
    309          } /* end TWIWriteData() */
    310          
    311          
    312          /*--------------------------------------------------------------------------------------------------------------------*/
    313          /* Protected Functions */
    314          /*--------------------------------------------------------------------------------------------------------------------*/
    315          
    316          /*----------------------------------------------------------------------------------------------------------------------
    317          Function: TWIInitialize
    318          
    319          Description:
    320          Initializes the TWI application and its variables. 
    321          
    322          Requires:
    323            - 
    324          
    325          Promises:
    326            - TWI peripheral objects are ready 
    327            - TWI application set to Idle
    328          */

   \                                 In section .text, align 2, keep-with-next
    329          void TWIInitialize(void)
    330          {
   \                     TWIInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    331            u32 u32TargetPerpipheralNumber = AT91C_ID_TWI0;
   \   00000002   0x2412             MOVS     R4,#+18
    332            
    333            AT91C_BASE_PMC->PMC_PCER |= (1<<u32TargetPerpipheralNumber);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14_7  ;; 0x400e0410
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x40A1             LSLS     R1,R1,R4
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0410
   \   00000014   0x6008             STR      R0,[R1, #+0]
    334            
    335            TWI_u32Flags = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    336            TWI0 = &TWI_Peripheral0;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000026   0x6008             STR      R0,[R1, #+0]
    337            TWI_MessageBufferNextIndex = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    338            TWI_MessageBufferCurIndex = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable14_10
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    339            TWI_MessageQueueLength = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    340            
    341            /* Initialize the TWI peripheral structures */
    342            TWI_Peripheral0.pBaseAddress    = AT91C_BASE_TWI0;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable14_11  ;; 0x40084000
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \   00000048   0x6008             STR      R0,[R1, #+0]
    343            TWI_Peripheral0.pTransmitBuffer = NULL;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \   00000050   0x6048             STR      R0,[R1, #+4]
    344            TWI_Peripheral0.pu8RxBuffer     = NULL;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \   00000058   0x6088             STR      R0,[R1, #+8]
    345            TWI_Peripheral0.u32Flags        = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \   00000060   0x60C8             STR      R0,[R1, #+12]
    346          
    347            /* Software reset of peripheral */
    348            TWI0->pBaseAddress->TWI_CR   |= _TWI_CR_SWRST_BIT;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x6008             STR      R0,[R1, #+0]
    349            TWI_u32Timer = G_u32SystemTime1ms;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000084   0x6008             STR      R0,[R1, #+0]
    350            while( !IsTimeUp(&TWI_u32Timer, 5) );
   \                     ??TWIInitialize_0: (+1)
   \   00000086   0x2105             MOVS     R1,#+5
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   0000008C   0x.... 0x....      BL       IsTimeUp
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD0F8             BEQ.N    ??TWIInitialize_0
    351            
    352            /* Configure Peripheral */
    353            TWI0->pBaseAddress->TWI_CWGR = TWI0_CWGR_INIT;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable14_14  ;; 0x21d1d
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000009C   0x6809             LDR      R1,[R1, #+0]
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0x6108             STR      R0,[R1, #+16]
    354            TWI0->pBaseAddress->TWI_CR   = TWI0_CR_INIT;
   \   000000A2   0x2024             MOVS     R0,#+36
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0x6809             LDR      R1,[R1, #+0]
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    355            TWI0->pBaseAddress->TWI_MMR  = TWI0_MMR_INIT;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000000B4   0x6809             LDR      R1,[R1, #+0]
   \   000000B6   0x6809             LDR      R1,[R1, #+0]
   \   000000B8   0x6048             STR      R0,[R1, #+4]
    356            TWI0->pBaseAddress->TWI_IER  = TWI0_IER_INIT;
   \   000000BA   0xF44F 0x70A1      MOV      R0,#+322
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000000C2   0x6809             LDR      R1,[R1, #+0]
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0x6248             STR      R0,[R1, #+36]
    357            TWI0->pBaseAddress->TWI_IDR  = TWI0_IDR_INIT;
   \   000000C8   0xF64F 0x6035      MOVW     R0,#+65077
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000000D0   0x6809             LDR      R1,[R1, #+0]
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0x6288             STR      R0,[R1, #+40]
    358            
    359            /* Enable TWI interrupts */
    360            NVIC_ClearPendingIRQ( (IRQn_Type)u32TargetPerpipheralNumber );
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000DA   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    361            NVIC_EnableIRQ( (IRQn_Type)u32TargetPerpipheralNumber );
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000E2   0x.... 0x....      BL       NVIC_EnableIRQ
    362          
    363            TWI_u32CurrentBytesRemaining   = 0;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    364            TWI_pu8CurrentTxData           = NULL;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \   000000F4   0x6008             STR      R0,[R1, #+0]
    365          
    366            /* Set application pointer */
    367            TWI_StateMachine = TWISM_Idle;
   \   000000F6   0x.... 0x....      ADR.W    R0,TWISM_Idle
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable14_17
   \   000000FE   0x6008             STR      R0,[R1, #+0]
    368            
    369          } /* end TWIInitialize() */
   \   00000100   0xBD10             POP      {R4,PC}          ;; return
    370          
    371          
    372          /*----------------------------------------------------------------------------------------------------------------------
    373          Function TWIRunActiveState()
    374          
    375          Description:
    376          Selects and runs one iteration of the current state in the state machine.
    377          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    378          may take 1ms / n to execute.
    379          
    380          Requires:
    381            - State machine function pointer points at current state
    382          
    383          Promises:
    384            - Calls the function to pointed by the state machine function pointer
    385          */

   \                                 In section .text, align 2, keep-with-next
    386          void TWIRunActiveState(void)
    387          {
   \                     TWIRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    388            TWI_StateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    389          
    390          } /* end TWIRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    391          
    392          
    393          
    394          /*--------------------------------------------------------------------------------------------------------------------*/
    395          /* Protected Functions */
    396          /*--------------------------------------------------------------------------------------------------------------------*/
    397          
    398          /*----------------------------------------------------------------------------------------------------------------------
    399          Function: TWIFillTxBuffer
    400          
    401          Description:
    402          Fills the TWI peripheral buffer with bytes from the current messsage that is sending.  
    403          This function can be called from the TWI ISR!
    404          Note: if the implemented processor does not have a FIFO, this function can still be used but will only ever
    405          add one byte to the transmitter.
    406          
    407          Requires:
    408            - The TxBuffer is empty
    409            - TWI_pu8CurrentTxData points to the next byte in the message to be sent
    410            - TWI_u32CurrentBytesRemaining has an accurate count of the bytes remaining in the message data to be sent
    411            - Transmit interrupts are off
    412          
    413          Promises:
    414            - Data from *TWI_pu8CurrentTxData is added to the TWI peripheral Tx FIFO until the FIFO is full or there
    415              is no more data to send.
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          static void TWI0FillTxBuffer(void)
    418          {
    419            u8 u8ByteCount = TWI_TX_FIFO_SIZE;
   \                     TWI0FillTxBuffer: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
    420            
    421            /* Use the active global variables to fill up the transmit FIFO */
    422            while( (u8ByteCount != 0) && (TWI_u32CurrentBytesRemaining != 0) )
   \                     ??TWI0FillTxBuffer_0: (+1)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD01D             BEQ.N    ??TWI0FillTxBuffer_1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD018             BEQ.N    ??TWI0FillTxBuffer_1
    423            {
    424              TWI0->pBaseAddress->TWI_THR = *TWI_pu8CurrentTxData;
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x6351             STR      R1,[R2, #+52]
    425              TWI_pu8CurrentTxData++;
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable14_16
   \   00000030   0x6011             STR      R1,[R2, #+0]
    426              TWI_u32CurrentBytesRemaining--;
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x1E49             SUBS     R1,R1,#+1
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable14_15
   \   0000003E   0x6011             STR      R1,[R2, #+0]
    427              u8ByteCount--;
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0xE7DE             B.N      ??TWI0FillTxBuffer_0
    428            }
    429            
    430            /* If there are no remaining bytes to load to the TX FIFO, disable the TWI transmit 
    431            FIFO empty interrupt */
    432            if(TWI_u32CurrentBytesRemaining == 0)
   \                     ??TWI0FillTxBuffer_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD11C             BNE.N    ??TWI0FillTxBuffer_2
    433            {
    434              TWI0->pBaseAddress->TWI_IDR = AT91C_TWI_TXRDY_MASTER;
   \   0000004E   0x2104             MOVS     R1,#+4
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \   00000054   0x6812             LDR      R2,[R2, #+0]
   \   00000056   0x6812             LDR      R2,[R2, #+0]
   \   00000058   0x6291             STR      R1,[R2, #+40]
    435              if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Stop == STOP)
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable14_10
   \   00000062   0x7812             LDRB     R2,[R2, #+0]
   \   00000064   0x0112             LSLS     R2,R2,#+4
   \   00000066   0x4411             ADD      R1,R1,R2
   \   00000068   0x7A89             LDRB     R1,[R1, #+10]
   \   0000006A   0x2900             CMP      R1,#+0
   \   0000006C   0xD112             BNE.N    ??TWI0FillTxBuffer_3
    436              {
    437                TWI0->pBaseAddress->TWI_CR |= _TWI_CR_STOP_BIT;
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \   00000080   0x6812             LDR      R2,[R2, #+0]
   \   00000082   0x6812             LDR      R2,[R2, #+0]
   \   00000084   0x6011             STR      R1,[R2, #+0]
   \   00000086   0xE005             B.N      ??TWI0FillTxBuffer_3
    438              }
    439            }
    440            /* Otherwise make sure transmit interrupts are enabled */
    441            else
    442            {
    443              TWI0->pBaseAddress->TWI_IER = AT91C_TWI_TXRDY_MASTER;
   \                     ??TWI0FillTxBuffer_2: (+1)
   \   00000088   0x2104             MOVS     R1,#+4
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \   0000008E   0x6812             LDR      R2,[R2, #+0]
   \   00000090   0x6812             LDR      R2,[R2, #+0]
   \   00000092   0x6251             STR      R1,[R2, #+36]
    444            }
    445            
    446          } /* end TWIFillTxBuffer() */
   \                     ??TWI0FillTxBuffer_3: (+1)
   \   00000094   0x4770             BX       LR               ;; return
    447          
    448          
    449          /*----------------------------------------------------------------------------------------------------------------------
    450          Function: TWIManualMode
    451          
    452          Description:
    453          Runs a transmit cycle of the TWI application to clock out a message.  This function is used only during
    454          initialization.
    455          
    456          Requires:
    457            - TWI application has been initialized.
    458          
    459          Promises:
    460            - All bytes currently in the TWI Rx FIFO are read out to the application receive circular buffer.
    461          */

   \                                 In section .text, align 2, keep-with-next
    462          static void TWIManualMode(void)
    463          {
   \                     TWIManualMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    464            TWI_u32Flags |=_TWI_INIT_MODE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000010   0x6008             STR      R0,[R1, #+0]
    465            TWI_u32Timer  = G_u32SystemTime1ms;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    466            
    467            while(TWI_u32Flags &_TWI_INIT_MODE)
   \                     ??TWIManualMode_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD509             BPL.N    ??TWIManualMode_1
    468            {
    469              TWI_StateMachine();
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4780             BLX      R0
    470              IsTimeUp(&TWI_u32Timer, 1);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000036   0x.... 0x....      BL       IsTimeUp
   \   0000003A   0xE7F0             B.N      ??TWIManualMode_0
    471            }
    472                
    473          } /* end TWIManualMode() */
   \                     ??TWIManualMode_1: (+1)
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    474          
    475          
    476          /*----------------------------------------------------------------------------------------------------------------------
    477          Function: TWI0_IrqHandler
    478          
    479          Description:
    480          Handles the TWI0 Peripheral interrupts
    481          
    482          Requires:
    483            - TWI application has been initialized.
    484          
    485          Promises:
    486            - More data has been queued or error flag raised
    487            - Or recieved byte is placed in desied buffer
    488          */

   \                                 In section .text, align 2, keep-with-next
    489          void TWI0_IrqHandler(void)
    490          {
   \                     TWI0_IrqHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    491            u32 u32InterruptStatus;
    492            
    493            /* Grab active interrupts and compare with status */
    494            u32InterruptStatus = AT91C_BASE_TWI0->TWI_IMR;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14_18  ;; 0x4008402c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0004             MOVS     R4,R0
    495            u32InterruptStatus &= AT91C_BASE_TWI0->TWI_SR;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable14_19  ;; 0x40084020
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x4004             ANDS     R4,R0,R4
    496            
    497            /* NACK Received */
    498            if(u32InterruptStatus & _TWI_SR_NACK )
   \   00000012   0x05E0             LSLS     R0,R4,#+23
   \   00000014   0xD508             BPL.N    ??TWI0_IrqHandler_0
    499            {
    500              /* Error has occurred, reset the msg */
    501              TWI_u32Flags |= _TWI_ERROR_NACK;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000024   0x6008             STR      R0,[R1, #+0]
   \   00000026   0xE046             B.N      ??TWI0_IrqHandler_1
    502              
    503            }
    504            /* Receiving Bytes */
    505            else if(u32InterruptStatus & _TWI_SR_RXRDY && ( TWI0->u32Flags & _TWI_RECEIVING ) )
   \                     ??TWI0_IrqHandler_0: (+1)
   \   00000028   0x07A0             LSLS     R0,R4,#+30
   \   0000002A   0xD531             BPL.N    ??TWI0_IrqHandler_2
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x7B00             LDRB     R0,[R0, #+12]
   \   00000034   0x0700             LSLS     R0,R0,#+28
   \   00000036   0xD52B             BPL.N    ??TWI0_IrqHandler_2
    506            {
    507              *TWI0->pu8RxBuffer = TWI0->pBaseAddress->TWI_RHR;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x6B00             LDR      R0,[R0, #+48]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x6889             LDR      R1,[R1, #+8]
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    508              TWI0->pu8RxBuffer++;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x6088             STR      R0,[R1, #+8]
    509              TWI_u32CurrentBytesRemaining--;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable14_15
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    510              
    511              if(TWI_u32CurrentBytesRemaining == 1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable14_15
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD11F             BNE.N    ??TWI0_IrqHandler_1
    512              {
    513                TWI0->pBaseAddress->TWI_CR |= _TWI_CR_STOP_BIT;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   \   0000008E   0xE012             B.N      ??TWI0_IrqHandler_1
    514              }
    515            }
    516            /* Transmitting Bytes */
    517            else if(u32InterruptStatus & _TWI_SR_TXRDY && ( TWI0->u32Flags & _TWI_TRANSMITTING ) )
   \                     ??TWI0_IrqHandler_2: (+1)
   \   00000090   0x0760             LSLS     R0,R4,#+29
   \   00000092   0xD508             BPL.N    ??TWI0_IrqHandler_3
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000009C   0x0780             LSLS     R0,R0,#+30
   \   0000009E   0xD502             BPL.N    ??TWI0_IrqHandler_3
    518            {
    519              /* There is more data queued and peripheral ready */
    520              TWI0FillTxBuffer();
   \   000000A0   0x.... 0x....      BL       TWI0FillTxBuffer
   \   000000A4   0xE007             B.N      ??TWI0_IrqHandler_1
    521            }
    522            else
    523            {
    524              TWI_u32Flags |= _TWI_ERROR_INTERRUPT;
   \                     ??TWI0_IrqHandler_3: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    525            }
    526          }
   \                     ??TWI0_IrqHandler_1: (+1)
   \   000000B6   0xBD10             POP      {R4,PC}          ;; return
    527          
    528          /***********************************************************************************************************************
    529          State Machine Function Definitions
    530          ***********************************************************************************************************************/
    531          
    532          /*-------------------------------------------------------------------------------------------------------------------*/
    533          /* Wait for a transmit message to be queued.  Received data is handled in interrupts. */

   \                                 In section .text, align 4, keep-with-next
    534          void TWISM_Idle(void)
    535          {
   \                     TWISM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    536            if(TWI_MessageBufferNextIndex != TWI_MessageBufferCurIndex )
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_10
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xF000 0x8096      BEQ.W    ??TWISM_Idle_0
    537            {
    538              TWI0->pBaseAddress->TWI_MMR = TWI0_MMR_INIT;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x6048             STR      R0,[R1, #+4]
    539              TWI0->pBaseAddress->TWI_CR = TWI0_CR_INIT;
   \   00000020   0x2024             MOVS     R0,#+36
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    540              
    541              if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Direction == WRITE)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable14_10
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0x0109             LSLS     R1,R1,#+4
   \   00000038   0x5C40             LDRB     R0,[R0, R1]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD132             BNE.N    ??TWISM_Idle_1
    542              {
    543                /* insert new address */
    544                TWI0->pBaseAddress->TWI_MMR |= ((TWI_MessageBuffer[TWI_MessageBufferCurIndex].u8Address << _TWI_MMR_ADDRESS_SHIFT));
   \   0000003E   0x....             LDR.N    R0,??DataTable14_3
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x6840             LDR      R0,[R0, #+4]
   \   00000046   0x....             LDR.N    R1,??DataTable14_4
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable14_10
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x0112             LSLS     R2,R2,#+4
   \   00000050   0x4411             ADD      R1,R1,R2
   \   00000052   0x7A09             LDRB     R1,[R1, #+8]
   \   00000054   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000058   0x....             LDR.N    R1,??DataTable14_3
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6048             STR      R0,[R1, #+4]
    545                
    546                /* Set up to transmit the message */
    547                TWI_u32CurrentBytesRemaining = TWI0->pTransmitBuffer->u32Size;
   \   00000060   0x....             LDR.N    R0,??DataTable14_3
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6840             LDR      R0,[R0, #+4]
   \   00000066   0x6840             LDR      R0,[R0, #+4]
   \   00000068   0x....             LDR.N    R1,??DataTable14_15
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    548                TWI_pu8CurrentTxData = TWI0->pTransmitBuffer->pu8Message;
   \   0000006C   0x....             LDR.N    R0,??DataTable14_3
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x6840             LDR      R0,[R0, #+4]
   \   00000072   0x3008             ADDS     R0,R0,#+8
   \   00000074   0x....             LDR.N    R1,??DataTable14_16
   \   00000076   0x6008             STR      R0,[R1, #+0]
    549                TWI0FillTxBuffer();    
   \   00000078   0x.... 0x....      BL       TWI0FillTxBuffer
    550                
    551                /* Update the message's status */
    552                UpdateMessageStatus(TWI0->pTransmitBuffer->u32Token, SENDING);
   \   0000007C   0x2102             MOVS     R1,#+2
   \   0000007E   0x....             LDR.N    R0,??DataTable14_3
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x6840             LDR      R0,[R0, #+4]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x.... 0x....      BL       UpdateMessageStatus
    553            
    554                /* Proceed to next state to let the current message send */
    555                TWI0->u32Flags |= (_TWI_TRANSMITTING | _TWI_TRANS_NOT_COMP);
   \   0000008A   0x....             LDR.N    R0,??DataTable14_3
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x68C0             LDR      R0,[R0, #+12]
   \   00000090   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   00000094   0x....             LDR.N    R1,??DataTable14_3
   \   00000096   0x6809             LDR      R1,[R1, #+0]
   \   00000098   0x60C8             STR      R0,[R1, #+12]
    556                TWI_StateMachine = TWISM_Transmitting;
   \   0000009A   0x.... 0x....      ADR.W    R0,TWISM_Transmitting
   \   0000009E   0x....             LDR.N    R1,??DataTable14_17
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0xE044             B.N      ??TWISM_Idle_2
    557              }
    558              else if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Direction == READ)
   \                     ??TWISM_Idle_1: (+1)
   \   000000A4   0x....             LDR.N    R0,??DataTable14_4
   \   000000A6   0x....             LDR.N    R1,??DataTable14_10
   \   000000A8   0x7809             LDRB     R1,[R1, #+0]
   \   000000AA   0x0109             LSLS     R1,R1,#+4
   \   000000AC   0x5C40             LDRB     R0,[R0, R1]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD13D             BNE.N    ??TWISM_Idle_2
    559              {
    560                /* insert new address and set Read bit */
    561                TWI0->pBaseAddress->TWI_MMR |= (((TWI_MessageBuffer[TWI_MessageBufferCurIndex].u8Address) << _TWI_MMR_ADDRESS_SHIFT) & _TWI_MMR_MREAD_BIT);
   \   000000B2   0x....             LDR.N    R0,??DataTable14_3
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x6840             LDR      R0,[R0, #+4]
   \   000000BA   0x....             LDR.N    R1,??DataTable14_3
   \   000000BC   0x6809             LDR      R1,[R1, #+0]
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0x6048             STR      R0,[R1, #+4]
    562                
    563                /* Grab number of desired bytes and the pointer to store the buffer */
    564                TWI_u32CurrentBytesRemaining = TWI_MessageBuffer[TWI_MessageBufferCurIndex].u32Size;
   \   000000C2   0x....             LDR.N    R0,??DataTable14_4
   \   000000C4   0x....             LDR.N    R1,??DataTable14_10
   \   000000C6   0x7809             LDRB     R1,[R1, #+0]
   \   000000C8   0x0109             LSLS     R1,R1,#+4
   \   000000CA   0x4408             ADD      R0,R0,R1
   \   000000CC   0x6840             LDR      R0,[R0, #+4]
   \   000000CE   0x....             LDR.N    R1,??DataTable14_15
   \   000000D0   0x6008             STR      R0,[R1, #+0]
    565                TWI0->pu8RxBuffer = TWI_MessageBuffer[TWI_MessageBufferCurIndex].pu8RxBuffer;
   \   000000D2   0x....             LDR.N    R0,??DataTable14_4
   \   000000D4   0x....             LDR.N    R1,??DataTable14_10
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x0109             LSLS     R1,R1,#+4
   \   000000DA   0x4408             ADD      R0,R0,R1
   \   000000DC   0x68C0             LDR      R0,[R0, #+12]
   \   000000DE   0x....             LDR.N    R1,??DataTable14_3
   \   000000E0   0x6809             LDR      R1,[R1, #+0]
   \   000000E2   0x6088             STR      R0,[R1, #+8]
    566                
    567                if(TWI_u32CurrentBytesRemaining == 1)
   \   000000E4   0x....             LDR.N    R0,??DataTable14_15
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0x2801             CMP      R0,#+1
   \   000000EA   0xD10A             BNE.N    ??TWISM_Idle_3
    568                {
    569                  /* Start and Stop need to be set at same time */
    570                  TWI0->pBaseAddress->TWI_CR |= (_TWI_CR_START_BIT | _TWI_CR_STOP_BIT);
   \   000000EC   0x....             LDR.N    R0,??DataTable14_3
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   000000F8   0x....             LDR.N    R1,??DataTable14_3
   \   000000FA   0x6809             LDR      R1,[R1, #+0]
   \   000000FC   0x6809             LDR      R1,[R1, #+0]
   \   000000FE   0x6008             STR      R0,[R1, #+0]
   \   00000100   0xE009             B.N      ??TWISM_Idle_4
    571                }
    572                else
    573                {
    574                  /* Just start bit, stop will be handled by interrupt */
    575                  TWI0->pBaseAddress->TWI_CR |= _TWI_CR_START_BIT;
   \                     ??TWISM_Idle_3: (+1)
   \   00000102   0x....             LDR.N    R0,??DataTable14_3
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000010E   0x....             LDR.N    R1,??DataTable14_3
   \   00000110   0x6809             LDR      R1,[R1, #+0]
   \   00000112   0x6809             LDR      R1,[R1, #+0]
   \   00000114   0x6008             STR      R0,[R1, #+0]
    576                }
    577                
    578                /* Proceed to receiving state and set flag */
    579                TWI0->u32Flags |= _TWI_RECEIVING;
   \                     ??TWISM_Idle_4: (+1)
   \   00000116   0x....             LDR.N    R0,??DataTable14_3
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x68C0             LDR      R0,[R0, #+12]
   \   0000011C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000120   0x....             LDR.N    R1,??DataTable14_3
   \   00000122   0x6809             LDR      R1,[R1, #+0]
   \   00000124   0x60C8             STR      R0,[R1, #+12]
    580                TWI_StateMachine = TWISM_Receiving;
   \   00000126   0x.... 0x....      ADR.W    R0,TWISM_Receiving
   \   0000012A   0x....             LDR.N    R1,??DataTable14_17
   \   0000012C   0x6008             STR      R0,[R1, #+0]
    581                
    582              }  
    583              
    584              /* Check for errors */
    585              if(TWI_u32Flags & TWI_ERROR_FLAG_MASK)
   \                     ??TWISM_Idle_2: (+1)
   \   0000012E   0x....             LDR.N    R0,??DataTable14_8
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0xF010 0x4F7F      TST      R0,#0xFF000000
   \   00000136   0xD003             BEQ.N    ??TWISM_Idle_0
    586              {
    587                /* Reset peripheral parser and go to error state */
    588                TWI_StateMachine = TWISM_Error;
   \   00000138   0x.... 0x....      ADR.W    R0,TWISM_Error
   \   0000013C   0x....             LDR.N    R1,??DataTable14_17
   \   0000013E   0x6008             STR      R0,[R1, #+0]
    589              }
    590            }
    591          } /* end TWISM_Idle() */
   \                     ??TWISM_Idle_0: (+1)
   \   00000140   0xBD01             POP      {R0,PC}          ;; return
    592               
    593          
    594          /*-------------------------------------------------------------------------------------------------------------------*/
    595          /* Transmit in progress until current bytes have reached 0.  On exit, the transmit message must be dequeued.
    596          */

   \                                 In section .text, align 4, keep-with-next
    597          void TWISM_Transmitting(void)
    598          {
   \                     TWISM_Transmitting: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    599            /* Check if a stop condition has been requested */
    600            if(TWI_MessageBuffer[TWI_MessageBufferCurIndex].Stop == STOP)
   \   00000002   0x....             LDR.N    R0,??DataTable14_4
   \   00000004   0x....             LDR.N    R1,??DataTable14_10
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x0109             LSLS     R1,R1,#+4
   \   0000000A   0x4408             ADD      R0,R0,R1
   \   0000000C   0x7A80             LDRB     R0,[R0, #+10]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD118             BNE.N    ??TWISM_Transmitting_0
    601            {
    602              /* Check if all of the message bytes have completely finished sending and transmission complete */
    603              if( (TWI_u32CurrentBytesRemaining == 0) && 
    604                  (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXRDY) &&
    605                  (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXCOMP) )
   \   00000012   0x....             LDR.N    R0,??DataTable14_15
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD126             BNE.N    ??TWISM_Transmitting_1
   \   0000001A   0x....             LDR.N    R0,??DataTable14_3
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x6A00             LDR      R0,[R0, #+32]
   \   00000022   0x0740             LSLS     R0,R0,#+29
   \   00000024   0xD520             BPL.N    ??TWISM_Transmitting_1
   \   00000026   0x....             LDR.N    R0,??DataTable14_3
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x6A00             LDR      R0,[R0, #+32]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD51A             BPL.N    ??TWISM_Transmitting_1
    606              {
    607                /*  Clear flags */
    608                TWI0->u32Flags &= ~(_TWI_TRANSMITTING | _TWI_TRANS_NOT_COMP);
   \   00000032   0x....             LDR.N    R0,??DataTable14_3
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF030 0x0006      BICS     R0,R0,#0x6
   \   0000003C   0x....             LDR.N    R1,??DataTable14_3
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   \   00000042   0xE011             B.N      ??TWISM_Transmitting_1
    609              }
    610            }
    611            else
    612            {
    613              /* Check if all of the message bytes have completely finished sending */
    614              if( (TWI_u32CurrentBytesRemaining == 0) && 
    615                  (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXRDY) )
   \                     ??TWISM_Transmitting_0: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable14_15
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD10D             BNE.N    ??TWISM_Transmitting_1
   \   0000004C   0x....             LDR.N    R0,??DataTable14_3
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x6A00             LDR      R0,[R0, #+32]
   \   00000054   0x0740             LSLS     R0,R0,#+29
   \   00000056   0xD507             BPL.N    ??TWISM_Transmitting_1
    616              { 
    617                /* Clear flag */
    618                TWI0->u32Flags &= ~_TWI_TRANSMITTING;
   \   00000058   0x....             LDR.N    R0,??DataTable14_3
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x68C0             LDR      R0,[R0, #+12]
   \   0000005E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000062   0x....             LDR.N    R1,??DataTable14_3
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
    619              }
    620            }
    621            
    622            if( !(TWI0->u32Flags & _TWI_TRANSMITTING) )
   \                     ??TWISM_Transmitting_1: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable14_3
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000006E   0x0780             LSLS     R0,R0,#+30
   \   00000070   0xD425             BMI.N    ??TWISM_Transmitting_2
    623            {
    624              /* Update the status queue and then dequeue the message */
    625              UpdateMessageStatus(TWI0->pTransmitBuffer->u32Token, COMPLETE);
   \   00000072   0x2104             MOVS     R1,#+4
   \   00000074   0x....             LDR.N    R0,??DataTable14_3
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x6840             LDR      R0,[R0, #+4]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x.... 0x....      BL       UpdateMessageStatus
    626              DeQueueMessage(&TWI0->pTransmitBuffer);
   \   00000080   0x....             LDR.N    R0,??DataTable14_3
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x1D00             ADDS     R0,R0,#+4
   \   00000086   0x.... 0x....      BL       DeQueueMessage
    627              
    628              /* Make sure _TWI_INIT_MODE flag is clear in case this was a manual cycle */
    629              TWI_u32Flags &= ~_TWI_INIT_MODE;
   \   0000008A   0x....             LDR.N    R0,??DataTable14_8
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x0840             LSRS     R0,R0,#+1
   \   00000090   0x0040             LSLS     R0,R0,#+1
   \   00000092   0x....             LDR.N    R1,??DataTable14_8
   \   00000094   0x6008             STR      R0,[R1, #+0]
    630              TWI_StateMachine = TWISM_Idle;
   \   00000096   0x....             LDR.N    R0,??DataTable14_20
   \   00000098   0x....             LDR.N    R1,??DataTable14_17
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    631              
    632              /* Update queue pointers */
    633              TWI_MessageBufferCurIndex++;
   \   0000009C   0x....             LDR.N    R0,??DataTable14_10
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0x....             LDR.N    R1,??DataTable14_10
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    634              TWI_MessageQueueLength--;
   \   000000A6   0x....             LDR.N    R0,??DataTable14_2
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x1E40             SUBS     R0,R0,#+1
   \   000000AC   0x....             LDR.N    R1,??DataTable14_2
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
    635              if(TWI_MessageBufferCurIndex == TX_QUEUE_SIZE)
   \   000000B0   0x....             LDR.N    R0,??DataTable14_10
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0x2810             CMP      R0,#+16
   \   000000B6   0xD102             BNE.N    ??TWISM_Transmitting_2
    636              {
    637                TWI_MessageBufferCurIndex = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x....             LDR.N    R1,??DataTable14_10
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
    638              }
    639            }
    640            
    641            /* Check for errors */
    642            if(TWI_u32Flags & TWI_ERROR_FLAG_MASK)
   \                     ??TWISM_Transmitting_2: (+1)
   \   000000BE   0x....             LDR.N    R0,??DataTable14_8
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF010 0x4F7F      TST      R0,#0xFF000000
   \   000000C6   0xD003             BEQ.N    ??TWISM_Transmitting_3
    643            {
    644              /* Reset peripheral parser and go to error state */
    645              TWI_StateMachine = TWISM_Error;
   \   000000C8   0x.... 0x....      ADR.W    R0,TWISM_Error
   \   000000CC   0x....             LDR.N    R1,??DataTable14_17
   \   000000CE   0x6008             STR      R0,[R1, #+0]
    646            }
    647            
    648          } /* end TWISM_Transmitting() */
   \                     ??TWISM_Transmitting_3: (+1)
   \   000000D0   0xBD01             POP      {R0,PC}          ;; return
    649          
    650          /*-------------------------------------------------------------------------------------------------------------------*/
    651          /* Receive in progress until current bytes have reached 0.
    652          */

   \                                 In section .text, align 4, keep-with-next
    653          void TWISM_Receiving(void)
    654          {
    655            if( (TWI_u32CurrentBytesRemaining == 0) &&
    656                (TWI0->pBaseAddress->TWI_SR & _TWI_SR_RXRDY) &&
    657                (TWI0->pBaseAddress->TWI_SR & _TWI_SR_TXCOMP) )
   \                     TWISM_Receiving: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14_15
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD12D             BNE.N    ??TWISM_Receiving_0
   \   00000008   0x....             LDR.N    R0,??DataTable14_3
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6A00             LDR      R0,[R0, #+32]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD527             BPL.N    ??TWISM_Receiving_0
   \   00000014   0x....             LDR.N    R0,??DataTable14_3
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6A00             LDR      R0,[R0, #+32]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD521             BPL.N    ??TWISM_Receiving_0
    658            {
    659              /* Clear flag */
    660              TWI0->u32Flags &= ~_TWI_RECEIVING;
   \   00000020   0x....             LDR.N    R0,??DataTable14_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000002A   0x....             LDR.N    R1,??DataTable14_3
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x60C8             STR      R0,[R1, #+12]
    661              
    662              /* Make sure _TWI_INIT_MODE flag is clear in case this was a manual cycle */
    663              TWI_u32Flags &= ~_TWI_INIT_MODE;
   \   00000030   0x....             LDR.N    R0,??DataTable14_8
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0840             LSRS     R0,R0,#+1
   \   00000036   0x0040             LSLS     R0,R0,#+1
   \   00000038   0x....             LDR.N    R1,??DataTable14_8
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    664              TWI_StateMachine = TWISM_Idle;
   \   0000003C   0x....             LDR.N    R0,??DataTable14_20
   \   0000003E   0x....             LDR.N    R1,??DataTable14_17
   \   00000040   0x6008             STR      R0,[R1, #+0]
    665              
    666              /* Update queue pointers */
    667              TWI_MessageBufferCurIndex++;
   \   00000042   0x....             LDR.N    R0,??DataTable14_10
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable14_10
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    668              TWI_MessageQueueLength--;
   \   0000004C   0x....             LDR.N    R0,??DataTable14_2
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x....             LDR.N    R1,??DataTable14_2
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    669              if(TWI_MessageBufferCurIndex == TX_QUEUE_SIZE)
   \   00000056   0x....             LDR.N    R0,??DataTable14_10
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2810             CMP      R0,#+16
   \   0000005C   0xD102             BNE.N    ??TWISM_Receiving_0
    670              {
    671                TWI_MessageBufferCurIndex = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x....             LDR.N    R1,??DataTable14_10
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    672              }
    673            }
    674            
    675            /* Check for errors */
    676            if(TWI_u32Flags & TWI_ERROR_FLAG_MASK)
   \                     ??TWISM_Receiving_0: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable14_8
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF010 0x4F7F      TST      R0,#0xFF000000
   \   0000006C   0xD003             BEQ.N    ??TWISM_Receiving_1
    677            {
    678              /* Reset peripheral parser and go to error state */
    679              TWI_StateMachine = TWISM_Error;
   \   0000006E   0x.... 0x....      ADR.W    R0,TWISM_Error
   \   00000072   0x....             LDR.N    R1,??DataTable14_17
   \   00000074   0x6008             STR      R0,[R1, #+0]
    680            }  
    681            
    682          }
   \                     ??TWISM_Receiving_1: (+1)
   \   00000076   0x4770             BX       LR               ;; return
    683          
    684          /*-------------------------------------------------------------------------------------------------------------------*/
    685          /* Handle an error */

   \                                 In section .text, align 4, keep-with-next
    686          void TWISM_Error(void)          
    687          {
   \                     TWISM_Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    688            /* NACK recieved */
    689            if( TWI_u32Flags & _TWI_ERROR_NACK )
   \   00000002   0x....             LDR.N    R0,??DataTable14_8
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x01C0             LSLS     R0,R0,#+7
   \   00000008   0xD53A             BPL.N    ??TWISM_Error_0
    690            {
    691              /* Msg attempted too many times */
    692              if( ++TWI_MessageBuffer[TWI_MessageBufferNextIndex].u8Attempts == MAX_ATTEMPTS )
   \   0000000A   0x....             LDR.N    R0,??DataTable14_4
   \   0000000C   0x....             LDR.N    R1,??DataTable14_5
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x0109             LSLS     R1,R1,#+4
   \   00000012   0x4408             ADD      R0,R0,R1
   \   00000014   0x7A40             LDRB     R0,[R0, #+9]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable14_4
   \   0000001A   0x....             LDR.N    R2,??DataTable14_5
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0112             LSLS     R2,R2,#+4
   \   00000020   0x4411             ADD      R1,R1,R2
   \   00000022   0x7248             STRB     R0,[R1, #+9]
   \   00000024   0x....             LDR.N    R0,??DataTable14_4
   \   00000026   0x....             LDR.N    R1,??DataTable14_5
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x0109             LSLS     R1,R1,#+4
   \   0000002C   0x4408             ADD      R0,R0,R1
   \   0000002E   0x7A40             LDRB     R0,[R0, #+9]
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xD121             BNE.N    ??TWISM_Error_1
    693              {
    694                /* Remove the message from buffer queue */
    695                TWI_MessageBufferCurIndex++;
   \   00000034   0x....             LDR.N    R0,??DataTable14_10
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x....             LDR.N    R1,??DataTable14_10
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
    696                TWI_MessageQueueLength--;
   \   0000003E   0x....             LDR.N    R0,??DataTable14_2
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable14_2
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    697                if(TWI_MessageBufferCurIndex == TX_QUEUE_SIZE)
   \   00000048   0x....             LDR.N    R0,??DataTable14_10
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2810             CMP      R0,#+16
   \   0000004E   0xD102             BNE.N    ??TWISM_Error_2
    698                {
    699                  TWI_MessageBufferCurIndex = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x....             LDR.N    R1,??DataTable14_10
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    700                }
    701                
    702                if( TWI0->u32Flags & _TWI_TRANSMITTING )
   \                     ??TWISM_Error_2: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable14_3
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000005C   0x0780             LSLS     R0,R0,#+30
   \   0000005E   0xD50B             BPL.N    ??TWISM_Error_1
    703                {
    704                  /* Dequeue Msg and Update Status */ 
    705                  UpdateMessageStatus(TWI0->pTransmitBuffer->u32Token, ABANDONED);
   \   00000060   0x2106             MOVS     R1,#+6
   \   00000062   0x....             LDR.N    R0,??DataTable14_3
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x6840             LDR      R0,[R0, #+4]
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x.... 0x....      BL       UpdateMessageStatus
    706                  DeQueueMessage(&TWI0->pTransmitBuffer);
   \   0000006E   0x....             LDR.N    R0,??DataTable14_3
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x1D00             ADDS     R0,R0,#+4
   \   00000074   0x.... 0x....      BL       DeQueueMessage
    707                }
    708              }
    709          
    710              /* Reset the msg flags */
    711              TWI0->u32Flags = 0;
   \                     ??TWISM_Error_1: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x....             LDR.N    R1,??DataTable14_3
   \   0000007C   0x6809             LDR      R1,[R1, #+0]
   \   0000007E   0x60C8             STR      R0,[R1, #+12]
    712            }
    713            
    714            /* Return to Idle */
    715            TWI_u32Flags &= ~TWI_ERROR_FLAG_MASK;
   \                     ??TWISM_Error_0: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable14_8
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   00000088   0x....             LDR.N    R1,??DataTable14_8
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    716            TWI_StateMachine = TWISM_Idle;
   \   0000008C   0x....             LDR.N    R0,??DataTable14_20
   \   0000008E   0x....             LDR.N    R1,??DataTable14_17
   \   00000090   0x6008             STR      R0,[R1, #+0]
    717            
    718          } /* end TWISM_Error() */
   \   00000092   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     TWI_MessageQueueLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     TWI0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     TWI_MessageBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     TWI_MessageBufferNextIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     TWI_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     TWI_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     TWI_MessageBufferCurIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x40084000         DC32     0x40084000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     TWI_u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x00021D1D         DC32     0x21d1d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x........         DC32     TWI_u32CurrentBytesRemaining

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x........         DC32     TWI_pu8CurrentTxData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x........         DC32     TWI_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \   00000000   0x4008402C         DC32     0x4008402c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \   00000000   0x40084020         DC32     0x40084020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \   00000000   0x........         DC32     TWISM_Idle
    719          
    720          
    721          
    722          /*--------------------------------------------------------------------------------------------------------------------*/
    723          /* End of File */
    724          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
       0   TWI0FillTxBuffer
      16   TWI0ReadByte
        16   -> TWIManualMode
      16   TWI0ReadData
        16   -> TWIManualMode
      24   TWI0WriteByte
        24   -> QueueMessage
        24   -> TWIManualMode
      24   TWI0WriteData
        24   -> QueueMessage
        24   -> TWIManualMode
       8   TWI0_IrqHandler
         8   -> TWI0FillTxBuffer
       8   TWIInitialize
         8   -> IsTimeUp
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_EnableIRQ
       8   TWIManualMode
         8   -- Indirect call
         8   -> IsTimeUp
       8   TWIRunActiveState
         8   -- Indirect call
       8   TWISM_Error
         8   -> DeQueueMessage
         8   -> UpdateMessageStatus
       8   TWISM_Idle
         8   -> TWI0FillTxBuffer
         8   -> UpdateMessageStatus
       0   TWISM_Receiving
       8   TWISM_Transmitting
         8   -> DeQueueMessage
         8   -> UpdateMessageStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      22  NVIC_ClearPendingIRQ
      22  NVIC_EnableIRQ
       4  TWI0
     150  TWI0FillTxBuffer
     198  TWI0ReadByte
     198  TWI0ReadData
     214  TWI0WriteByte
     218  TWI0WriteData
     184  TWI0_IrqHandler
     258  TWIInitialize
      62  TWIManualMode
      12  TWIRunActiveState
     148  TWISM_Error
     322  TWISM_Idle
     120  TWISM_Receiving
     210  TWISM_Transmitting
     256  TWI_MessageBuffer
       1  TWI_MessageBufferCurIndex
       1  TWI_MessageBufferNextIndex
       1  TWI_MessageQueueLength
      16  TWI_Peripheral0
       4  TWI_StateMachine
       4  TWI_pu8CurrentTxData
       4  TWI_u32CurrentBytesRemaining
       4  TWI_u32Flags
       4  TWI_u32Timer

 
   299 bytes in section .bss
 2 422 bytes in section .text
 
 2 422 bytes of CODE memory
   299 bytes of DATA memory

Errors: none
Warnings: none
