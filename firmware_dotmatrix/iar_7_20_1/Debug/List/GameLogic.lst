###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       22/Mar/2018  01:46:48
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GameLogic.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GameLogic.c" -D
#        MPGL2 -D MPG2 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -o "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\bsp\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\tetris\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List\GameLogic.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj\GameLogic.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GameLogic.c
      1          #include <stdio.h>
      2          #include <stdlib.h>
      3          #include "GameLogic.h"

  #define DEBUG_MODE 0
          ^
"C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\Defs.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "DEBUG_MODE" (declared at line 27)
      4          #include "Defs.h"
      5          #include "Commands.h"
      6          #include "Grid.h"
      7          

   \                                 In section .bss, align 4
      8          static Timer* gravityTimer = NULL;
   \                     gravityTimer:
   \   00000000                      DS8 4
      9          
     10          /*==================================================
     11          State Machine Functions
     12          ==================================================*/

   \                                 In section .text, align 2, keep-with-next
     13          void Initialize(GameInstance* game)
     14          {
   \                     Initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     15          #if DEBUG_MODE
     16              printf("Current State: %s\n", __FUNCTION__);
     17          #endif
     18              channel_open(CHANNEL_GAMEINSTANCE);
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       channel_open
     19              gravityTimer = timer_create(250);
   \   0000000A   0x20FA             MOVS     R0,#+250
   \   0000000C   0x.... 0x....      BL       timer_create
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable4_2
   \   00000014   0x6008             STR      R0,[R1, #+0]
     20          
     21              if(game != NULL)
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD012             BEQ.N    ??Initialize_0
     22              {
     23                  game->gridPtr = create_grid();
   \   0000001A   0x.... 0x....      BL       create_grid
   \   0000001E   0x6020             STR      R0,[R4, #+0]
     24                  game->blockPtr = NULL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6060             STR      R0,[R4, #+4]
     25                  game->score = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x8120             STRH     R0,[R4, #+8]
     26                  game->level = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x8160             STRH     R0,[R4, #+10]
     27                  game->blockFallTimer = timer_create(250);
   \   0000002C   0x20FA             MOVS     R0,#+250
   \   0000002E   0x.... 0x....      BL       timer_create
   \   00000032   0x60E0             STR      R0,[R4, #+12]
     28                  game->runState = &SM_SpawnBlock;
   \   00000034   0x.... 0x....      ADR.W    R0,SM_SpawnBlock
   \   00000038   0x6120             STR      R0,[R4, #+16]
     29          
     30                  timer_start(game->blockFallTimer);
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x.... 0x....      BL       timer_start
     31              }
     32          }
   \                     ??Initialize_0: (+1)
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
     33          

   \                                 In section .text, align 4, keep-with-next
     34          void SM_SpawnBlock(GameInstance* game)
     35          {
   \                     SM_SpawnBlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     36          #if DEBUG_MODE
     37              printf("Current State: %s\n", __FUNCTION__);
     38          #endif
     39              // Change block type
     40              game->blockPtr = change_tetromino(game->blockPtr);
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x.... 0x....      BL       change_tetromino
   \   0000000A   0x6060             STR      R0,[R4, #+4]
     41          
     42              Tetromino* tetromino = game->blockPtr;
   \   0000000C   0x6865             LDR      R5,[R4, #+4]
     43              // Set position
     44              tetromino->blockCords.x = (game->gridPtr->numCols-TETROMINO_COLS)/2;   //This places the block right at the center x-cord of the board
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0xF890 0x00F1      LDRB     R0,[R0, #+241]
   \   00000014   0x1F40             SUBS     R0,R0,#+5
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001C   0x8368             STRH     R0,[R5, #+26]
     45              tetromino->blockCords.y = -2;                                          //This places it high enough so it hides part of the tetromino
   \   0000001E   0xF07F 0x0001      MVNS     R0,#+1
   \   00000022   0x83A8             STRH     R0,[R5, #+28]
     46          
     47              //Assign game with new tetromino
     48              game->blockPtr = tetromino;
   \   00000024   0x6065             STR      R5,[R4, #+4]
     49          
     50              //Print the border
     51              channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_BORDER_UPDATE);
   \   00000026   0x2109             MOVS     R1,#+9
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       channel_send
     52              channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_SCORE_UPDATE);
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x.... 0x....      BL       channel_send
     53          
     54              // Change state to idle
     55              game->runState = &SM_Idle;
   \   00000036   0x.... 0x....      ADR.W    R0,SM_Idle
   \   0000003A   0x6120             STR      R0,[R4, #+16]
     56          }
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     57          

   \                                 In section .text, align 4, keep-with-next
     58          void SM_Idle(GameInstance* game)
     59          {
   \                     SM_Idle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     60          #if DEBUG_MODE
     61              printf("Current State: %s\n", __FUNCTION__);
     62          #endif
     63          
     64              // Check for commands (input)
     65              if(!channel_is_empty(CHANNEL_GAMEINSTANCE))
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       channel_is_empty
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??SM_Idle_0
     66              {
     67                  game_process_commands(game);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       game_process_commands
     68              }
     69          
     70              // Check to see if timer is ready
     71              if(timer_ready(game->blockFallTimer))
   \                     ??SM_Idle_0: (+1)
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x.... 0x....      BL       timer_ready
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??SM_Idle_1
     72              {
     73                  // If it is, change state to timeout
     74                  game->runState = &SM_Timeout;
   \   0000001E   0x.... 0x....      ADR.W    R0,SM_Timeout
   \   00000022   0x6120             STR      R0,[R4, #+16]
     75              }
     76          }
   \                     ??SM_Idle_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
     77          

   \                                 In section .text, align 4, keep-with-next
     78          void SM_Timeout(GameInstance* game)
     79          {
   \                     SM_Timeout: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     80          #if DEBUG_MODE
     81              printf("Current State: %s\n", __FUNCTION__);
     82          #endif
     83              //Check for any filled squares below the current block
     84              if( is_collision(game->gridPtr, game->blockPtr) )
   \   00000004   0x6861             LDR      R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       is_collision
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??SM_Timeout_0
     85              {
     86                  //If there are, then go to colliison state
     87                  game->runState = &SM_Collision;
   \   00000010   0x.... 0x....      ADR.W    R0,SM_Collision
   \   00000014   0x6120             STR      R0,[R4, #+16]
   \   00000016   0xE002             B.N      ??SM_Timeout_1
     88              }
     89              else
     90              {
     91                  //If there isn't, go to drop block state
     92                  game->runState = &SM_Drop;
   \                     ??SM_Timeout_0: (+1)
   \   00000018   0x.... 0x....      ADR.W    R0,SM_Drop
   \   0000001C   0x6120             STR      R0,[R4, #+16]
     93              }
     94          }
   \                     ??SM_Timeout_1: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
     95          

   \                                 In section .text, align 4, keep-with-next
     96          void SM_Collision(GameInstance* game)
     97          {
   \                     SM_Collision: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
     98          #if DEBUG_MODE
     99              printf("Current State: %s\n", __FUNCTION__);
    100          #endif
    101              Grid* grid = game->gridPtr;
   \   00000008   0x6825             LDR      R5,[R4, #+0]
    102              Tetromino* tetromino = game->blockPtr;
   \   0000000A   0x6866             LDR      R6,[R4, #+4]
    103          
    104              // Check for lose condition
    105              if(has_lost(game))
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       has_lost
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??SM_Collision_0
    106              {
    107                  game->runState = &SM_Lose;
   \   00000016   0x.... 0x....      ADR.W    R0,SM_Lose
   \   0000001A   0x6120             STR      R0,[R4, #+16]
   \   0000001C   0xE03A             B.N      ??SM_Collision_1
    108              }
    109              else
    110              {
    111                  // Fill grid
    112                  fill_grid_with_tetromino(grid, tetromino);
   \                     ??SM_Collision_0: (+1)
   \   0000001E   0x0031             MOVS     R1,R6
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       fill_grid_with_tetromino
    113                  fill_tetromino(tetromino, 0);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       fill_tetromino
    114                  bool doCollapse = false;
   \   0000002E   0x2700             MOVS     R7,#+0
    115                  // Iterate through all rows that the tetromino occupies and check for any cleared rows
    116                  for(uint8_t y = 0; y < TETROMINO_ROWS; y++)
   \   00000030   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??SM_Collision_2: (+1)
   \   00000034   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000038   0xF1B8 0x0F05      CMP      R8,#+5
   \   0000003C   0xDA20             BGE.N    ??SM_Collision_3
    117                  {
    118                      // X is 0 because we don't care what it is
    119                      Location block_wrt_grid = blockcords_to_gridcords(tetromino, y, 0);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x.... 0x....      BL       blockcords_to_gridcords
   \   0000004E   0x9000             STR      R0,[SP, #+0]
    120                      // Range check the converted y value because block with respect to grid cords can be negative
    121                      // and we don't want to check those values
    122                      if( block_wrt_grid.y >= 0 && block_wrt_grid.y < MAX_ROW )
   \   00000050   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD410             BMI.N    ??SM_Collision_4
   \   00000058   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000005C   0x2818             CMP      R0,#+24
   \   0000005E   0xDA0C             BGE.N    ??SM_Collision_4
    123                      {
    124                          if( is_row_filled(grid, block_wrt_grid.y, 1) )
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000066   0x0001             MOVS     R1,R0
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0x.... 0x....      BL       is_row_filled
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD002             BEQ.N    ??SM_Collision_4
    125                          {
    126                              doCollapse = true;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x0007             MOVS     R7,R0
    127                              break;
   \   00000078   0xE002             B.N      ??SM_Collision_3
    128                          }
    129                      }
    130                  }
   \                     ??SM_Collision_4: (+1)
   \   0000007A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000007E   0xE7D9             B.N      ??SM_Collision_2
    131          
    132                  if(doCollapse)
   \                     ??SM_Collision_3: (+1)
   \   00000080   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000082   0x2F00             CMP      R7,#+0
   \   00000084   0xD003             BEQ.N    ??SM_Collision_5
    133                      game->runState = &SM_Collapse;    // If cleared row, collapse blocks
   \   00000086   0x.... 0x....      ADR.W    R0,SM_Collapse
   \   0000008A   0x6120             STR      R0,[R4, #+16]
   \   0000008C   0xE002             B.N      ??SM_Collision_1
    134                  else
    135                      game->runState = &SM_SpawnBlock;  // If not cleared, reset block drops
   \                     ??SM_Collision_5: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   00000092   0x6120             STR      R0,[R4, #+16]
    136              }
    137          }
   \                     ??SM_Collision_1: (+1)
   \   00000094   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    138          

   \                                 In section .text, align 4, keep-with-next
    139          void SM_Drop(GameInstance *game)
    140          {
   \                     SM_Drop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    141          #if DEBUG_MODE
    142              printf("Current State: %s\n", __FUNCTION__);
    143          #endif
    144          
    145              Tetromino* tetromino = game->blockPtr;
   \   00000004   0x6865             LDR      R5,[R4, #+4]
    146              // Decrease position of the tetromino
    147              tetromino->blockCords.y++;
   \   00000006   0x8BA8             LDRH     R0,[R5, #+28]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x83A8             STRH     R0,[R5, #+28]
    148              
    149              // Reset timer
    150              timer_reset(game->blockFallTimer);
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0x.... 0x....      BL       timer_reset
    151          
    152              // Block has dropped, update affected area
    153              channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_BLOCK_UPDATE);
   \   00000012   0x2107             MOVS     R1,#+7
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       channel_send
    154          
    155              // Next state is idle
    156              game->runState = &SM_Idle;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   0000001E   0x6120             STR      R0,[R4, #+16]
    157          }
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    158          

   \                                 In section .text, align 4, keep-with-next
    159          void SM_Lose(GameInstance *game)
    160          {
    161          #if DEBUG_MODE
    162              printf("Current State: %s\n", __FUNCTION__);
    163          #endif
    164          }
   \                     SM_Lose: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    165          

   \                                 In section .text, align 4, keep-with-next
    166          void SM_Collapse(GameInstance *game)
    167          {
   \                     SM_Collapse: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    168          #if DEBUG_MODE
    169              printf("Current State: %s\n", __FUNCTION__);
    170          #endif
    171              static uint8_t SUBSTATE = 0;
    172              Tetromino* tetromino = game->blockPtr;
   \   00000004   0x6865             LDR      R5,[R4, #+4]
    173              Grid* grid = game->gridPtr;
   \   00000006   0x6826             LDR      R6,[R4, #+0]
    174          
    175              static uint8_t rowToClear = MAX_ROW;
    176              switch(SUBSTATE)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ.N    ??SM_Collapse_0
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD047             BEQ.N    ??SM_Collapse_1
   \   00000016   0xE062             B.N      ??SM_Collapse_2
    177              {
    178                  //This state means we are waiting for the timer to end
    179                  case 0:
    180                      rowToClear = MAX_ROW;
   \                     ??SM_Collapse_0: (+1)
   \   00000018   0x2018             MOVS     R0,#+24
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable4_6
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    181                      for(uint8_t y = MAX_ROW - 1 ; y >= tetromino->blockCords.y; y--)
   \   00000020   0x2717             MOVS     R7,#+23
   \                     ??SM_Collapse_3: (+1)
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xF9B5 0x101C      LDRSH    R1,[R5, #+28]
   \   0000002A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xDB0D             BLT.N    ??SM_Collapse_4
    182                      {
    183                          //If found, then do stuff
    184                          if( is_row_filled(grid, y, 1) )
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x0039             MOVS     R1,R7
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x.... 0x....      BL       is_row_filled
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??SM_Collapse_5
    185                          {
    186                              rowToClear = y;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000044   0x7007             STRB     R7,[R0, #+0]
    187                              break;
   \   00000046   0xE001             B.N      ??SM_Collapse_4
    188                          }
    189                      }
   \                     ??SM_Collapse_5: (+1)
   \   00000048   0x1E7F             SUBS     R7,R7,#+1
   \   0000004A   0xE7EA             B.N      ??SM_Collapse_3
    190          
    191                      if( rowToClear != MAX_ROW )
   \                     ??SM_Collapse_4: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x2818             CMP      R0,#+24
   \   00000054   0xD024             BEQ.N    ??SM_Collapse_6
    192                      {
    193                          for(sint16_t x = 0 ; x < MAX_COL; x++ )
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??SM_Collapse_7: (+1)
   \   00000058   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000005A   0x280A             CMP      R0,#+10
   \   0000005C   0xDA09             BGE.N    ??SM_Collapse_8
    194                              grid->_grid[rowToClear][x] = 0;
   \   0000005E   0x....             LDR.N    R1,??DataTable4_6
   \   00000060   0x7809             LDRB     R1,[R1, #+0]
   \   00000062   0x220A             MOVS     R2,#+10
   \   00000064   0x4351             MULS     R1,R2,R1
   \   00000066   0x4431             ADD      R1,R6,R1
   \   00000068   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x540A             STRB     R2,[R1, R0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0xE7F2             B.N      ??SM_Collapse_7
    195          
    196                          timer_reset(gravityTimer);
   \                     ??SM_Collapse_8: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable4_2
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x.... 0x....      BL       timer_reset
    197                          timer_stop(gravityTimer);
   \   0000007A   0x....             LDR.N    R0,??DataTable4_2
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x.... 0x....      BL       timer_stop
    198                          game->score++;
   \   00000082   0x8920             LDRH     R0,[R4, #+8]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x8120             STRH     R0,[R4, #+8]
    199          
    200                          channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_GRID_UPDATE); //Since we just cleared a row, send a grid update
   \   00000088   0x2108             MOVS     R1,#+8
   \   0000008A   0x2002             MOVS     R0,#+2
   \   0000008C   0x.... 0x....      BL       channel_send
    201                          channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_SCORE_UPDATE);
   \   00000090   0x210A             MOVS     R1,#+10
   \   00000092   0x2002             MOVS     R0,#+2
   \   00000094   0x.... 0x....      BL       channel_send
    202                          SUBSTATE = 1;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x....             LDR.N    R1,??DataTable4_5
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
   \   0000009E   0xE001             B.N      ??SM_Collapse_9
    203                      }
    204                      else
    205                      {
    206                          game->runState = &SM_SpawnBlock;
   \                     ??SM_Collapse_6: (+1)
   \   000000A0   0x....             LDR.N    R0,??DataTable4_3
   \   000000A2   0x6120             STR      R0,[R4, #+16]
    207                      }
    208                  break;
   \                     ??SM_Collapse_9: (+1)
   \   000000A4   0xE01B             B.N      ??SM_Collapse_2
    209          
    210                  case 1:
    211                      if(gravityTimer->active == true && timer_ready(gravityTimer))
   \                     ??SM_Collapse_1: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable4_2
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x7A40             LDRB     R0,[R0, #+9]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD112             BNE.N    ??SM_Collapse_10
   \   000000B0   0x....             LDR.N    R0,??DataTable4_2
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x.... 0x....      BL       timer_ready
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD00C             BEQ.N    ??SM_Collapse_10
    212                      {
    213                          shift_grid_down(grid, rowToClear);
   \   000000BC   0x....             LDR.N    R0,??DataTable4_6
   \   000000BE   0x7801             LDRB     R1,[R0, #+0]
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0x.... 0x....      BL       shift_grid_down
    214                          channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_GRID_UPDATE); //Since we shifted a row down, send a grid update
   \   000000C6   0x2108             MOVS     R1,#+8
   \   000000C8   0x2002             MOVS     R0,#+2
   \   000000CA   0x.... 0x....      BL       channel_send
    215                          SUBSTATE = 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x....             LDR.N    R1,??DataTable4_5
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
   \   000000D4   0xE003             B.N      ??SM_Collapse_11
    216                      }
    217                      else
    218                      {
    219                          timer_start(gravityTimer);
   \                     ??SM_Collapse_10: (+1)
   \   000000D6   0x....             LDR.N    R0,??DataTable4_2
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x.... 0x....      BL       timer_start
    220                      }
    221                  break;
    222              }
    223          }
   \                     ??SM_Collapse_11: (+1)
   \                     ??SM_Collapse_2: (+1)
   \   000000DE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .bss, align 1
   \                     `SM_Collapse::SUBSTATE`:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
   \                     `SM_Collapse::rowToClear`:
   \   00000000   0x18               DC8 24
    224          
    225          
    226          /*==================================================
    227          Private Helper Functions
    228          ==================================================*/
    229          /**
    230           * Check if there is a collision imminent
    231           **/

   \                                 In section .text, align 2, keep-with-next
    232          bool is_collision(Grid* grid, Tetromino* tetromino)
    233          {
   \                     is_collision: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    234              bool toReturn = false;
   \   00000008   0x2600             MOVS     R6,#+0
    235              //Find the lowest filled block on the tetromino
    236              sint16_t x, y;
    237          
    238              //Go from left to right, finding the lowest block and seeing if there is anything below it
    239              for(x = 0 ; x < TETROMINO_COLS; x++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0007             MOVS     R7,R0
   \                     ??is_collision_0: (+1)
   \   0000000E   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000010   0x2F05             CMP      R7,#+5
   \   00000012   0xDA3A             BGE.N    ??is_collision_1
    240              {
    241                  bool found = false;
   \   00000014   0xF05F 0x0900      MOVS     R9,#+0
    242                  for(y = TETROMINO_ROWS-1; y >= 0; y--)
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x4680             MOV      R8,R0
   \                     ??is_collision_2: (+1)
   \   0000001C   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000020   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000024   0xD42F             BMI.N    ??is_collision_3
    243                  {
    244                      if( !found && tetromino->_tetromino[y][x] == 1 )
   \   00000026   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002E   0xD127             BNE.N    ??is_collision_4
   \   00000030   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0xFB00 0xF008      MUL      R0,R0,R8
   \   0000003A   0x4428             ADD      R0,R5,R0
   \   0000003C   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   0000003E   0x5DC0             LDRB     R0,[R0, R7]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD11D             BNE.N    ??is_collision_4
    245                      {
    246                          found = true;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x4681             MOV      R9,R0
    247                          Location block_wrt_grid = blockcords_to_gridcords(tetromino, y, x);
   \   00000048   0x003A             MOVS     R2,R7
   \   0000004A   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000004C   0x4641             MOV      R1,R8
   \   0000004E   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       blockcords_to_gridcords
   \   00000056   0x9000             STR      R0,[SP, #+0]
    248          
    249                          //If the block has landed on the first row
    250                          if(block_wrt_grid.y == MAX_ROW -1)
   \   00000058   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000005C   0x2817             CMP      R0,#+23
   \   0000005E   0xD102             BNE.N    ??is_collision_5
    251                              toReturn = true;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x0006             MOVS     R6,R0
   \   00000064   0xE00C             B.N      ??is_collision_4
    252          
    253                          else if( grid->_grid[block_wrt_grid.y+1][block_wrt_grid.x] == 1 )
   \                     ??is_collision_5: (+1)
   \   00000066   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000006A   0x210A             MOVS     R1,#+10
   \   0000006C   0x4348             MULS     R0,R1,R0
   \   0000006E   0x4420             ADD      R0,R4,R0
   \   00000070   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000074   0x4408             ADD      R0,R0,R1
   \   00000076   0x7A80             LDRB     R0,[R0, #+10]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD101             BNE.N    ??is_collision_4
    254                              toReturn = true;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x0006             MOVS     R6,R0
    255                      }
    256                  }
   \                     ??is_collision_4: (+1)
   \   00000080   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000084   0xE7CA             B.N      ??is_collision_2
    257              }
   \                     ??is_collision_3: (+1)
   \   00000086   0x1C7F             ADDS     R7,R7,#+1
   \   00000088   0xE7C1             B.N      ??is_collision_0
    258          
    259              return toReturn;
   \                     ??is_collision_1: (+1)
   \   0000008A   0x0030             MOVS     R0,R6
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    260          }
    261          
    262          /**
    263           * Returns true if the tetromino is too high, false if not
    264           **/

   \                                 In section .text, align 2, keep-with-next
    265          bool has_lost(GameInstance * game)
    266          {
   \                     has_lost: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    267              Tetromino* tetromino = game->blockPtr;
   \   00000004   0x6865             LDR      R5,[R4, #+4]
    268          
    269              for(sint16_t y = 0; y < TETROMINO_ROWS; y++)
   \   00000006   0x2600             MOVS     R6,#+0
   \                     ??has_lost_0: (+1)
   \   00000008   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   0000000A   0x2E05             CMP      R6,#+5
   \   0000000C   0xDA1E             BGE.N    ??has_lost_1
    270              {
    271                  for(sint16_t x = 0; x < TETROMINO_COLS; x++)
   \   0000000E   0x2700             MOVS     R7,#+0
   \                     ??has_lost_2: (+1)
   \   00000010   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000012   0x2F05             CMP      R7,#+5
   \   00000014   0xDA18             BGE.N    ??has_lost_3
    272                  {
    273                      if( tetromino->_tetromino[y][x] == 1 )
   \   00000016   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0xFB00 0xF006      MUL      R0,R0,R6
   \   0000001E   0x4428             ADD      R0,R5,R0
   \   00000020   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000022   0x5DC0             LDRB     R0,[R0, R7]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD10D             BNE.N    ??has_lost_4
    274                      {
    275                          Location block_wrt_grid = blockcords_to_gridcords(tetromino, y, x);
   \   00000028   0x003A             MOVS     R2,R7
   \   0000002A   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000002C   0x0031             MOVS     R1,R6
   \   0000002E   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x.... 0x....      BL       blockcords_to_gridcords
   \   00000036   0x9000             STR      R0,[SP, #+0]
    276                          if( (block_wrt_grid.y) < 0 )
   \   00000038   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD501             BPL.N    ??has_lost_4
    277                          {
    278                              return true;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE004             B.N      ??has_lost_5
    279                          }
    280                      }
    281                  }
   \                     ??has_lost_4: (+1)
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
   \   00000046   0xE7E3             B.N      ??has_lost_2
    282              }
   \                     ??has_lost_3: (+1)
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \   0000004A   0xE7DD             B.N      ??has_lost_0
    283          
    284              return false;
   \                     ??has_lost_1: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??has_lost_5: (+1)
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    285          }
    286          
    287          /**
    288           * Fills the grid with 1's wherever the tetromino is
    289           */

   \                                 In section .text, align 2, keep-with-next
    290          void fill_grid_with_tetromino(Grid* grid, Tetromino* tetromino)
    291          {
   \                     fill_grid_with_tetromino: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    292              for(sint16_t y = 0; y < TETROMINO_ROWS; y++)
   \   00000006   0x2600             MOVS     R6,#+0
   \                     ??fill_grid_with_tetromino_0: (+1)
   \   00000008   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   0000000A   0x2E05             CMP      R6,#+5
   \   0000000C   0xDA37             BGE.N    ??fill_grid_with_tetromino_1
    293              {
    294                  for(sint16_t x = 0; x < TETROMINO_COLS; x++)
   \   0000000E   0x2700             MOVS     R7,#+0
   \                     ??fill_grid_with_tetromino_2: (+1)
   \   00000010   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000012   0x2F05             CMP      R7,#+5
   \   00000014   0xDA31             BGE.N    ??fill_grid_with_tetromino_3
    295                  {
    296                      Location block_wrt_grid = blockcords_to_gridcords(tetromino, y, x);
   \   00000016   0x003A             MOVS     R2,R7
   \   00000018   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000001A   0x0031             MOVS     R1,R6
   \   0000001C   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       blockcords_to_gridcords
   \   00000024   0x9000             STR      R0,[SP, #+0]
    297                      if(block_wrt_grid.x >= 0 && block_wrt_grid.x < MAX_COL && block_wrt_grid.y >= 0 && block_wrt_grid.x < MAX_ROW)
   \   00000026   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD423             BMI.N    ??fill_grid_with_tetromino_4
   \   0000002E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000032   0x280A             CMP      R0,#+10
   \   00000034   0xDA1F             BGE.N    ??fill_grid_with_tetromino_4
   \   00000036   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD41B             BMI.N    ??fill_grid_with_tetromino_4
   \   0000003E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000042   0x2818             CMP      R0,#+24
   \   00000044   0xDA17             BGE.N    ??fill_grid_with_tetromino_4
    298                      {
    299                          if( tetromino->_tetromino[y][x] == 1 )
   \   00000046   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000048   0x2005             MOVS     R0,#+5
   \   0000004A   0xFB00 0xF006      MUL      R0,R0,R6
   \   0000004E   0x4428             ADD      R0,R5,R0
   \   00000050   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000052   0x5DC0             LDRB     R0,[R0, R7]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD10E             BNE.N    ??fill_grid_with_tetromino_4
    300                          {
    301                              grid->_grid[block_wrt_grid.y][block_wrt_grid.x] = tetromino->_tetromino[y][x];
   \   00000058   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000005C   0x210A             MOVS     R1,#+10
   \   0000005E   0x4348             MULS     R0,R1,R0
   \   00000060   0x4420             ADD      R0,R4,R0
   \   00000062   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000066   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000068   0x2205             MOVS     R2,#+5
   \   0000006A   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000006E   0x442A             ADD      R2,R5,R2
   \   00000070   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000072   0x5DD2             LDRB     R2,[R2, R7]
   \   00000074   0x5442             STRB     R2,[R0, R1]
    302                          }
    303                      }
    304                  }
   \                     ??fill_grid_with_tetromino_4: (+1)
   \   00000076   0x1C7F             ADDS     R7,R7,#+1
   \   00000078   0xE7CA             B.N      ??fill_grid_with_tetromino_2
    305              }
   \                     ??fill_grid_with_tetromino_3: (+1)
   \   0000007A   0x1C76             ADDS     R6,R6,#+1
   \   0000007C   0xE7C4             B.N      ??fill_grid_with_tetromino_0
    306          }
   \                     ??fill_grid_with_tetromino_1: (+1)
   \   0000007E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    307          
    308          /**
    309           * Converts coordinates from tetromino-relative to grid-relative
    310           */

   \                                 In section .text, align 2, keep-with-next
    311          Location blockcords_to_gridcords(Tetromino* tetromino, sint16_t y, sint16_t x)
    312          {
   \                     blockcords_to_gridcords: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0003             MOVS     R3,R0
    313              Location gridCords;
    314              gridCords.x = tetromino->blockCords.x + x;
   \   00000004   0x8B58             LDRH     R0,[R3, #+26]
   \   00000006   0x1810             ADDS     R0,R2,R0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    315              gridCords.y = tetromino->blockCords.y + y;
   \   0000000C   0x8B98             LDRH     R0,[R3, #+28]
   \   0000000E   0x1808             ADDS     R0,R1,R0
   \   00000010   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    316          
    317              return gridCords;
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
    318          }
    319          

   \                                 In section .text, align 2, keep-with-next
    320          Location gridcords_to_blockcords(Tetromino* tetromino, sint16_t y, sint16_t x)
    321          {
   \                     gridcords_to_blockcords: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0003             MOVS     R3,R0
    322              Location blockCords;
    323              blockCords.x = x - tetromino->blockCords.x;
   \   00000004   0x8B58             LDRH     R0,[R3, #+26]
   \   00000006   0x1A10             SUBS     R0,R2,R0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    324              blockCords.y = y - tetromino->blockCords.y;
   \   0000000C   0x8B98             LDRH     R0,[R3, #+28]
   \   0000000E   0x1A08             SUBS     R0,R1,R0
   \   00000010   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    325          
    326              return blockCords;
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
    327          }
    328          

   \                                 In section .text, align 2, keep-with-next
    329          void game_process_commands(GameInstance * game)
    330          {
   \                     game_process_commands: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    331              Grid* grid = game->gridPtr;
   \   00000006   0x6825             LDR      R5,[R4, #+0]
    332              Tetromino* tetromino = game->blockPtr;
   \   00000008   0x6866             LDR      R6,[R4, #+4]
    333          
    334              sint32_t value = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    335              do
    336              {
    337                  value = channel_dequeue(CHANNEL_GAMEINSTANCE);
   \                     ??game_process_commands_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       channel_dequeue
   \   00000012   0x0007             MOVS     R7,R0
    338                  bool updateGUI = true;
   \   00000014   0xF05F 0x0801      MOVS     R8,#+1
    339          
    340                  switch(value)
   \   00000018   0x0038             MOVS     R0,R7
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD006             BEQ.N    ??game_process_commands_1
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD009             BEQ.N    ??game_process_commands_2
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD00C             BEQ.N    ??game_process_commands_3
   \   00000026   0x2806             CMP      R0,#+6
   \   00000028   0xD00F             BEQ.N    ??game_process_commands_4
   \   0000002A   0xE013             B.N      ??game_process_commands_5
    341                  {
    342                      case CONTROL_LEFT:
    343                          Control_MoveLeft(grid, tetromino);
   \                     ??game_process_commands_1: (+1)
   \   0000002C   0x0031             MOVS     R1,R6
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       Control_MoveLeft
    344                      break;
   \   00000034   0xE010             B.N      ??game_process_commands_6
    345          
    346                      case CONTROL_RIGHT:
    347                          Control_MoveRight(grid, tetromino);
   \                     ??game_process_commands_2: (+1)
   \   00000036   0x0031             MOVS     R1,R6
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       Control_MoveRight
    348                      break;
   \   0000003E   0xE00B             B.N      ??game_process_commands_6
    349          
    350                      case CONTROL_ROTLEFT:
    351                          Control_RotateLeft(grid, tetromino);
   \                     ??game_process_commands_3: (+1)
   \   00000040   0x0031             MOVS     R1,R6
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       Control_RotateLeft
    352                      break;
   \   00000048   0xE006             B.N      ??game_process_commands_6
    353          
    354                      case CONTROL_ROTRIGHT:
    355                          Control_RotateRight(grid, tetromino);
   \                     ??game_process_commands_4: (+1)
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       Control_RotateRight
    356                      break;
   \   00000052   0xE001             B.N      ??game_process_commands_6
    357          
    358                      default:
    359                          updateGUI = false;
   \                     ??game_process_commands_5: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x4680             MOV      R8,R0
    360                      break;
    361                  }
    362                  if(updateGUI)
   \                     ??game_process_commands_6: (+1)
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000060   0xD003             BEQ.N    ??game_process_commands_7
    363                  {
    364                      channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_BLOCK_UPDATE);
   \   00000062   0x2107             MOVS     R1,#+7
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      BL       channel_send
    365                  }
    366              } while(value != RC_FAIL);
   \                     ??game_process_commands_7: (+1)
   \   0000006A   0xF117 0x0F01      CMN      R7,#+1
   \   0000006E   0xD1CD             BNE.N    ??game_process_commands_0
    367          }
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    368          

   \                                 In section .text, align 2, keep-with-next
    369          void print_game(GameInstance* game)
    370          {
   \                     print_game: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
    371              Tetromino* tetromino = game->blockPtr;
   \   00000008   0x6865             LDR      R5,[R4, #+4]
    372              Grid* grid = game->gridPtr;
   \   0000000A   0x6826             LDR      R6,[R4, #+0]
    373          
    374              for(uint16_t y = 0; y < MAX_ROW; y++)
   \   0000000C   0x2700             MOVS     R7,#+0
   \                     ??print_game_0: (+1)
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0x2F18             CMP      R7,#+24
   \   00000012   0xDA49             BGE.N    ??print_game_1
    375              {
    376                  for(uint16_t x = 0; x < MAX_COL; x++)
   \   00000014   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??print_game_2: (+1)
   \   00000018   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000001C   0xF1B8 0x0F0A      CMP      R8,#+10
   \   00000020   0xDA3D             BGE.N    ??print_game_3
    377                  {
    378                      Location block_wrt_grid = gridcords_to_blockcords(tetromino, y, x);
   \   00000022   0x4642             MOV      R2,R8
   \   00000024   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000026   0x0039             MOVS     R1,R7
   \   00000028   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       gridcords_to_blockcords
   \   00000030   0x9000             STR      R0,[SP, #+0]
    379                      //If within range
    380                      if( tetromino->blockCords.y <= y && y < (tetromino->blockCords.y + TETROMINO_ROWS) 
    381                      &&  tetromino->blockCords.x <= x && x < (tetromino->blockCords.x + TETROMINO_COLS)
    382                      &&  tetromino->_tetromino[block_wrt_grid.y][block_wrt_grid.x] == 1)
   \   00000032   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000034   0xF9B5 0x001C      LDRSH    R0,[R5, #+28]
   \   00000038   0x4287             CMP      R7,R0
   \   0000003A   0xDB21             BLT.N    ??print_game_4
   \   0000003C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003E   0xF9B5 0x001C      LDRSH    R0,[R5, #+28]
   \   00000042   0x1D40             ADDS     R0,R0,#+5
   \   00000044   0x4287             CMP      R7,R0
   \   00000046   0xDA1B             BGE.N    ??print_game_4
   \   00000048   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000004C   0xF9B5 0x001A      LDRSH    R0,[R5, #+26]
   \   00000050   0x4580             CMP      R8,R0
   \   00000052   0xDB15             BLT.N    ??print_game_4
   \   00000054   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000058   0xF9B5 0x001A      LDRSH    R0,[R5, #+26]
   \   0000005C   0x1D40             ADDS     R0,R0,#+5
   \   0000005E   0x4580             CMP      R8,R0
   \   00000060   0xDA0E             BGE.N    ??print_game_4
   \   00000062   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000066   0x2105             MOVS     R1,#+5
   \   00000068   0x4348             MULS     R0,R1,R0
   \   0000006A   0x4428             ADD      R0,R5,R0
   \   0000006C   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000070   0x5C40             LDRB     R0,[R0, R1]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD104             BNE.N    ??print_game_4
    383                      {
    384                          printf("%d ", 1);
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x....             ADR.N    R0,??DataTable4  ;; "%d "
   \   0000007A   0x.... 0x....      BL       printf
   \   0000007E   0xE00B             B.N      ??print_game_5
    385                      }
    386                      else
    387                      {
    388                          printf("%d ", grid->_grid[y][x]);
   \                     ??print_game_4: (+1)
   \   00000080   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000082   0x200A             MOVS     R0,#+10
   \   00000084   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000088   0x4430             ADD      R0,R6,R0
   \   0000008A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000008E   0xF810 0x1008      LDRB     R1,[R0, R8]
   \   00000092   0x....             ADR.N    R0,??DataTable4  ;; "%d "
   \   00000094   0x.... 0x....      BL       printf
    389                      }
    390                  }
   \                     ??print_game_5: (+1)
   \   00000098   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000009C   0xE7BC             B.N      ??print_game_2
    391          
    392                  printf("\n");
   \                     ??print_game_3: (+1)
   \   0000009E   0x....             ADR.N    R0,??DataTable4_1  ;; "\n"
   \   000000A0   0x.... 0x....      BL       printf
    393              }
   \   000000A4   0x1C7F             ADDS     R7,R7,#+1
   \   000000A6   0xE7B2             B.N      ??print_game_0
    394          }
   \                     ??print_game_1: (+1)
   \   000000A8   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    395          
    396          /**
    397          * Checks for any invalid conditions i.e. tetromino overlapping grid or tetromino out of range
    398          */

   \                                 In section .text, align 2, keep-with-next
    399          bool check_overlap(Grid* grid, Tetromino* tetromino)
    400          {
   \                     check_overlap: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    401              for(uint8_t y = 0; y < TETROMINO_ROWS; y++)
   \   00000006   0x2600             MOVS     R6,#+0
   \                     ??check_overlap_0: (+1)
   \   00000008   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000A   0x2E05             CMP      R6,#+5
   \   0000000C   0xDA38             BGE.N    ??check_overlap_1
    402              {
    403                  for(uint8_t x = 0; x < TETROMINO_COLS; x++)
   \   0000000E   0x2700             MOVS     R7,#+0
   \                     ??check_overlap_2: (+1)
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F05             CMP      R7,#+5
   \   00000014   0xDA32             BGE.N    ??check_overlap_3
    404                  {
    405                      if( tetromino->_tetromino[y][x] == 1 )
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0xFB00 0xF006      MUL      R0,R0,R6
   \   0000001E   0x4428             ADD      R0,R5,R0
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0x5DC0             LDRB     R0,[R0, R7]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD127             BNE.N    ??check_overlap_4
    406                      {
    407                          Location block_wrt_grid = blockcords_to_gridcords(tetromino, y, x);
   \   00000028   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002A   0x003A             MOVS     R2,R7
   \   0000002C   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x0031             MOVS     R1,R6
   \   00000032   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       blockcords_to_gridcords
   \   0000003A   0x9000             STR      R0,[SP, #+0]
    408                          
    409                          //Out of range condition (We only care about X, because Y out of range can be valid)
    410                          if(block_wrt_grid.x < 0 || block_wrt_grid.x >= MAX_COL)
   \   0000003C   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD403             BMI.N    ??check_overlap_5
   \   00000044   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000048   0x280A             CMP      R0,#+10
   \   0000004A   0xDB01             BLT.N    ??check_overlap_6
    411                          {
    412                              return true;
   \                     ??check_overlap_5: (+1)
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE018             B.N      ??check_overlap_7
    413                          }
    414                          //Overlap condition
    415                          if(block_wrt_grid.y > 0 && block_wrt_grid.y <= MAX_ROW)
   \                     ??check_overlap_6: (+1)
   \   00000050   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xDB0F             BLT.N    ??check_overlap_4
   \   00000058   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000005C   0x2819             CMP      R0,#+25
   \   0000005E   0xDA0B             BGE.N    ??check_overlap_4
    416                          {
    417                              if( grid->_grid[block_wrt_grid.y][block_wrt_grid.x] == 1)
   \   00000060   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000064   0x210A             MOVS     R1,#+10
   \   00000066   0x4348             MULS     R0,R1,R0
   \   00000068   0x4420             ADD      R0,R4,R0
   \   0000006A   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   0000006E   0x5C40             LDRB     R0,[R0, R1]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD101             BNE.N    ??check_overlap_4
    418                              {
    419                                  return true;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE004             B.N      ??check_overlap_7
    420                              }
    421                          }
    422                      }
    423                  }
   \                     ??check_overlap_4: (+1)
   \   00000078   0x1C7F             ADDS     R7,R7,#+1
   \   0000007A   0xE7C9             B.N      ??check_overlap_2
    424              }
   \                     ??check_overlap_3: (+1)
   \   0000007C   0x1C76             ADDS     R6,R6,#+1
   \   0000007E   0xE7C3             B.N      ??check_overlap_0
    425          
    426              return false;
   \                     ??check_overlap_1: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??check_overlap_7: (+1)
   \   00000082   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    427          }
    428          /*=====================
    429          * Game commands
    430          ======================*/
    431          

   \                                 In section .text, align 2, keep-with-next
    432          void Control_MoveLeft(Grid* grid, Tetromino* tetromino)
    433          {
   \                     Control_MoveLeft: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    434              tetromino->blockCords.x--;
   \   00000006   0x8B68             LDRH     R0,[R5, #+26]
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \   0000000A   0x8368             STRH     R0,[R5, #+26]
    435              if(check_overlap(grid, tetromino))
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       check_overlap
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??Control_MoveLeft_0
    436                  tetromino->blockCords.x++;
   \   00000018   0x8B68             LDRH     R0,[R5, #+26]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x8368             STRH     R0,[R5, #+26]
   \   0000001E   0xE003             B.N      ??Control_MoveLeft_1
    437              else
    438                  channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_BLOCK_UPDATE);
   \                     ??Control_MoveLeft_0: (+1)
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       channel_send
    439          }
   \                     ??Control_MoveLeft_1: (+1)
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    440          

   \                                 In section .text, align 2, keep-with-next
    441          void Control_MoveRight(Grid* grid, Tetromino* tetromino)
    442          {
   \                     Control_MoveRight: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    443              tetromino->blockCords.x++;
   \   00000006   0x8B68             LDRH     R0,[R5, #+26]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x8368             STRH     R0,[R5, #+26]
    444              if(check_overlap(grid, tetromino))
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       check_overlap
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??Control_MoveRight_0
    445                  tetromino->blockCords.x--;
   \   00000018   0x8B68             LDRH     R0,[R5, #+26]
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
   \   0000001C   0x8368             STRH     R0,[R5, #+26]
   \   0000001E   0xE003             B.N      ??Control_MoveRight_1
    446              else
    447                  channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_BLOCK_UPDATE);
   \                     ??Control_MoveRight_0: (+1)
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       channel_send
    448          }
   \                     ??Control_MoveRight_1: (+1)
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    449          

   \                                 In section .text, align 2, keep-with-next
    450          void Control_RotateLeft(Grid* grid, Tetromino* tetromino)
    451          {
   \                     Control_RotateLeft: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    452              rotate_left(tetromino);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       rotate_left
    453              if(check_overlap(grid, tetromino))
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       check_overlap
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??Control_RotateLeft_0
    454                  rotate_right(tetromino);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       rotate_right
   \   0000001E   0xE003             B.N      ??Control_RotateLeft_1
    455              else
    456                  channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_BLOCK_UPDATE);
   \                     ??Control_RotateLeft_0: (+1)
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       channel_send
    457          }
   \                     ??Control_RotateLeft_1: (+1)
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    458          

   \                                 In section .text, align 2, keep-with-next
    459          void Control_RotateRight(Grid* grid, Tetromino* tetromino)
    460          {
   \                     Control_RotateRight: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    461              rotate_right(tetromino);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       rotate_right
    462              if(check_overlap(grid, tetromino))
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       check_overlap
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??Control_RotateRight_0
    463                  rotate_left(tetromino);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       rotate_left
   \   0000001E   0xE003             B.N      ??Control_RotateRight_1
    464              else
    465                  channel_send(CHANNEL_GAMECONTROLLER, MESSAGE_GUI_BLOCK_UPDATE);
   \                     ??Control_RotateRight_0: (+1)
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       channel_send
    466          }
   \                     ??Control_RotateRight_1: (+1)
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x25 0x64          DC8      "%d "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     gravityTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     SM_SpawnBlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     SM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     `SM_Collapse::SUBSTATE`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     `SM_Collapse::rowToClear`

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x64          DC8 "%d "
   \              0x20 0x00    

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Control_MoveLeft
        16   -> channel_send
        16   -> check_overlap
      16   Control_MoveRight
        16   -> channel_send
        16   -> check_overlap
      16   Control_RotateLeft
        16   -> channel_send
        16   -> check_overlap
        16   -> rotate_left
        16   -> rotate_right
      16   Control_RotateRight
        16   -> channel_send
        16   -> check_overlap
        16   -> rotate_left
        16   -> rotate_right
       8   Initialize
         8   -> channel_open
         8   -> create_grid
         8   -> timer_create
         8   -> timer_start
      24   SM_Collapse
        24   -> channel_send
        24   -> is_row_filled
        24   -> shift_grid_down
        24   -> timer_ready
        24   -> timer_reset
        24   -> timer_start
        24   -> timer_stop
      32   SM_Collision
        32   -> blockcords_to_gridcords
        32   -> fill_grid_with_tetromino
        32   -> fill_tetromino
        32   -> has_lost
        32   -> is_row_filled
      16   SM_Drop
        16   -> channel_send
        16   -> timer_reset
       8   SM_Idle
         8   -> channel_is_empty
         8   -> game_process_commands
         8   -> timer_ready
       0   SM_Lose
      16   SM_SpawnBlock
        16   -> change_tetromino
        16   -> channel_send
       8   SM_Timeout
         8   -> is_collision
       4   blockcords_to_gridcords
      24   check_overlap
        24   -> blockcords_to_gridcords
      24   fill_grid_with_tetromino
        24   -> blockcords_to_gridcords
      24   game_process_commands
        24   -> Control_MoveLeft
        24   -> Control_MoveRight
        24   -> Control_RotateLeft
        24   -> Control_RotateRight
        24   -> channel_dequeue
        24   -> channel_send
       4   gridcords_to_blockcords
      24   has_lost
        24   -> blockcords_to_gridcords
      32   is_collision
        32   -> blockcords_to_gridcords
      32   print_game
        32   -> gridcords_to_blockcords
        32   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ?_0
       2  ?_1
      42  Control_MoveLeft
      42  Control_MoveRight
      42  Control_RotateLeft
      42  Control_RotateRight
      66  Initialize
     224  SM_Collapse
     152  SM_Collision
      34  SM_Drop
      38  SM_Idle
       2  SM_Lose
      62  SM_SpawnBlock
      32  SM_Timeout
       1  SUBSTATE
      26  blockcords_to_gridcords
     132  check_overlap
     128  fill_grid_with_tetromino
     116  game_process_commands
       4  gravityTimer
      26  gridcords_to_blockcords
      80  has_lost
     146  is_collision
     172  print_game
       1  rowToClear

 
     5 bytes in section .bss
     1 byte  in section .data
     6 bytes in section .rodata
 1 632 bytes in section .text
 
 1 632 bytes of CODE  memory
     6 bytes of CONST memory
     6 bytes of DATA  memory

Errors: none
Warnings: 1
