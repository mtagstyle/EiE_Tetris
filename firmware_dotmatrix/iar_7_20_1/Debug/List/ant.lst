###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       22/Mar/2018  01:24:49
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\ant.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\ant.c" -D MPGL2
#        -D MPG2 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -o "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\bsp\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\tetris\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List\ant.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj\ant.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\drivers\ant.c
      1          /***********************************************************************************************************************
      2          File: ant.c                                                               
      3          
      4          Description:
      5          ANT implementation for Atmel SAM3U2 Cortex-M3 / Ant slave SPI.  This driver requires synchronous
      6          SPI slave connection to an AP2 or AP2-emulated ANT device (the ANT device is the Master).  
      7          All interface layer code is maintained here.  
      8          Transmitted messages use the Message task; received messages use an SSP peripheral
      9          with SPI_SLAVE_FLOW_CONTROL.
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          
     13          
     14          ***********************************************************************************************************************/
     15          
     16          #include "configuration.h"
     17          
     18          /***********************************************************************************************************************
     19          * Bookmarks
     20          ************************************************************************************************************************
     21          !!!!! ANT Serial-layer Functions
     22          @@@@@ ANT Interface-layer Functions
     23          ##### ANT State Machine Definition                                             
     24          ***********************************************************************************************************************/
     25          
     26          /***********************************************************************************************************************
     27          Global variable definitions with scope across entire project.
     28          All Global variable names shall start with "G_<type>Ant"
     29          ***********************************************************************************************************************/
     30          
     31          /* New variables */

   \                                 In section .bss, align 4
     32          u32 G_u32AntFlags;                                    /* Flag bits for ANT-related information */
   \                     G_u32AntFlags:
   \   00000000                      DS8 4
     33          

   \                                 In section .bss, align 4
     34          AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]; /* Keeps track of all configured ANT channels */
   \                     G_asAntChannelConfiguration:
   \   00000000                      DS8 160

   \                                 In section .bss, align 4
     35          AntMessageResponseType G_stMessageResponse;           /* Holds the latest message response info */
   \                     G_stMessageResponse:
   \   00000000                      DS8 4
     36          

   \                                 In section .bss, align 4
     37          AntApplicationMsgListType *G_sAntApplicationMsgList;  /* Public linked list of messages from ANT to the application */
   \                     G_sAntApplicationMsgList:
   \   00000000                      DS8 4
     38          

   \                                 In section .data, align 4
     39          u8 G_au8AntMessageOk[]     = "OK\n\r";
   \                     G_au8AntMessageOk:
   \   00000000   0x4F 0x4B          DC8 "OK\012\015"
   \              0x0A 0x0D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     40          u8 G_au8AntMessageFail[  ] = "FAIL\n\r";
   \                     G_au8AntMessageFail:
   \   00000000   0x46 0x41          DC8 "FAIL\012\015"
   \              0x49 0x4C    
   \              0x0A 0x0D    
   \              0x00         
   \   00000007   0x00               DC8 0
     41          
     42          /* Replace 'd' at [12] with channel number */

   \                                 In section .data, align 4
     43          u8 G_au8AntMessageAssign[]    = "ANT channel d assign "; 
   \                     G_au8AntMessageAssign:
   \   00000000   0x41 0x4E          DC8 "ANT channel d assign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     44          u8 G_au8AntMessageUnassign[]  = "ANT channel d unassign ";
   \                     G_au8AntMessageUnassign:
   \   00000000   0x41 0x4E          DC8 "ANT channel d unassign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x75 0x6E    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    

   \                                 In section .data, align 4
     45          u8 G_au8AntMessageUnhandled[] = "ANT channel d message 0xxx response dd ";
   \                     G_au8AntMessageUnhandled:
   \   00000000   0x41 0x4E          DC8 "ANT channel d message 0xxx response dd "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x78 0x78    
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x20    
   \              0x64 0x64    
   \              0x20 0x00    

   \                                 In section .data, align 4
     46          u8 G_au8AntMessageSetup[] = "ANT channel d setup ";
   \                     G_au8AntMessageSetup:
   \   00000000   0x41 0x4E          DC8 "ANT channel d setup "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x75    
   \              0x70 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     47          u8 G_au8AntMessageClose[] = "ANT channel d close ";
   \                     G_au8AntMessageClose:
   \   00000000   0x41 0x4E          DC8 "ANT channel d close "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     48          u8 G_au8AntMessageOpen[]  = "ANT channel d open ";
   \                     G_au8AntMessageOpen:
   \   00000000   0x41 0x4E          DC8 "ANT channel d open "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6F 0x70    
   \              0x65 0x6E    
   \              0x20 0x00    
     49          

   \                                 In section .data, align 4
     50          u8 G_au8AntMessageInit[]  = "Initializing ANT... ";
   \                     G_au8AntMessageInit:
   \   00000000   0x49 0x6E          DC8 "Initializing ANT... "
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x69    
   \              0x6E 0x67    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x2E 0x2E    
   \              0x2E 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     51          u8 G_au8AntMessageInitFail[] = "failed. Host IOs set to HiZ.\r\n";
   \                     G_au8AntMessageInitFail:
   \   00000000   0x66 0x61          DC8 "failed. Host IOs set to HiZ.\015\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x49    
   \              0x4F 0x73    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x48 0x69    
   \              0x5A 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .data, align 4
     52          u8 G_au8AntMessageNoAnt[] = "\n\r### nRF51422 Programming Mode: no ANT functionality ####\n\r";
   \                     G_au8AntMessageNoAnt:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 23H, 23H, 23H, 20H, 6EH, 52H
   \              0x23 0x23    
   \              0x23 0x20    
   \              0x6E 0x52    
   \   00000008   0x46 0x35          DC8 46H, 35H, 31H, 34H, 32H, 32H, 20H, 50H
   \              0x31 0x34    
   \              0x32 0x32    
   \              0x20 0x50    
   \   00000010   0x72 0x6F          DC8 72H, 6FH, 67H, 72H, 61H, 6DH, 6DH, 69H
   \              0x67 0x72    
   \              0x61 0x6D    
   \              0x6D 0x69    
   \   00000018   0x6E 0x67          DC8 6EH, 67H, 20H, 4DH, 6FH, 64H, 65H, 3AH
   \              0x20 0x4D    
   \              0x6F 0x64    
   \              0x65 0x3A    
   \   00000020   0x20 0x6E          DC8 20H, 6EH, 6FH, 20H, 41H, 4EH, 54H, 20H
   \              0x6F 0x20    
   \              0x41 0x4E    
   \              0x54 0x20    
   \   00000028   0x66 0x75          DC8 66H, 75H, 6EH, 63H, 74H, 69H, 6FH, 6EH
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000030   0x61 0x6C          DC8 61H, 6CH, 69H, 74H, 79H, 20H, 23H, 23H
   \              0x69 0x74    
   \              0x79 0x20    
   \              0x23 0x23    
   \   00000038   0x23 0x23          DC8 23H, 23H, 0AH, 0DH, 0
   \              0x0A 0x0D    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     53          
     54          
     55          /* ANT message structures */

   \                                 In section .data, align 4
     56          u8 G_au8AntSetNetworkKey[]    = {MESG_NETWORK_KEY_SIZE, MESG_NETWORK_KEY_ID, 0 /* Network number */, 
   \                     G_au8AntSetNetworkKey:
   \   00000000   0x09 0x46          DC8 9, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     57                                           0 /* KEY0 */, 0 /* KEY1 */, 0 /* KEY2 */, 0 /* KEY3 */, 
     58                                           0 /* KEY4 */, 0 /* KEY5 */, 0 /* KEY6 */, 0 /* KEY7 */, CS};

   \                                 In section .data, align 4
     59          u8 G_au8AntAssignChannel[]    = {MESG_ASSIGN_CHANNEL_SIZE, MESG_ASSIGN_CHANNEL_ID, 0 /* AntChannel */, 
   \                     G_au8AntAssignChannel:
   \   00000000   0x03 0x42          DC8 3, 66, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     60                                           0 /* AntChannelType */, 0 /* AntNetwork */, CS};

   \                                 In section .data, align 4
     61          u8 G_au8AntSetChannelID[]     = {MESG_CHANNEL_ID_SIZE, MESG_CHANNEL_ID_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelID:
   \   00000000   0x05 0x51          DC8 5, 81, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     62                                           0 /* AntDeviceIdLo */, 0 /* AntDeviceIdHi */, 0 /* AntDeviceType */, 
     63                                           0 /* AntTransmissionType */, CS};

   \                                 In section .data, align 4
     64          u8 G_au8AntSetChannelPeriod[] = {MESG_CHANNEL_MESG_PERIOD_SIZE, MESG_CHANNEL_MESG_PERIOD_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPeriod:
   \   00000000   0x03 0x43          DC8 3, 67, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     65                                           0 /* AntChannelPeriodLo */, 0 /* AntChannelPeriodHi */, CS};

   \                                 In section .data, align 4
     66          u8 G_au8AntSetChannelRFFreq[] = {MESG_CHANNEL_RADIO_FREQ_SIZE, MESG_CHANNEL_RADIO_FREQ_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelRFFreq:
   \   00000000   0x02 0x45          DC8 2, 69, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     67                                           0 /* AntFrequency */, CS};           

   \                                 In section .data, align 4
     68          u8 G_au8AntSetChannelPower[]  = {MESG_RADIO_TX_POWER_SIZE, MESG_RADIO_TX_POWER_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPower:
   \   00000000   0x02 0x47          DC8 2, 71, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     69                                           0 /* AntTxPower */, CS};        

   \                                 In section .data, align 4
     70          u8 G_au8AntLibConfig[]        = {MESG_LIB_CONFIG_SIZE, MESG_LIB_CONFIG_ID, 0, LIB_CONFIG_CHANNEL_ID_FLAG | LIB_CONFIG_RSSI_FLAG, CS};        
   \                     G_au8AntLibConfig:
   \   00000000   0x02 0x6E          DC8 2, 110, 0, 192, 0, 0, 0, 0
   \              0x00 0xC0    
   \              0x00 0x00    
   \              0x00 0x00    
     71          

   \                                 In section .data, align 4
     72          u8 G_au8AntBroadcastDataMessage[] = {MESG_DATA_SIZE, MESG_BROADCAST_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntBroadcastDataMessage:
   \   00000000   0x09 0x4E          DC8 9, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     73          u8 G_au8AntAckDataMessage[] = {MESG_DATA_SIZE, MESG_ACKNOWLEDGED_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntAckDataMessage:
   \   00000000   0x09 0x4F          DC8 9, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     74          u8 G_au8ANTGetVersion[]     = {MESG_REQUEST_SIZE, MESG_REQUEST_ID, 0, MESG_VERSION_ID, 0};   
   \                     G_au8ANTGetVersion:
   \   00000000   0x02 0x4D          DC8 2, 77, 0, 62, 0, 0, 0, 0
   \              0x00 0x3E    
   \              0x00 0x00    
   \              0x00 0x00    
     75          
     76          
     77          /*----------------------------------------------------------------------------*/
     78          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
     79          and indicate what file the variable is defined in. */
     80          extern u32 G_u32SystemFlags;                            /* From main.c */
     81          extern u32 G_u32ApplicationFlags;                       /* From main.c */
     82          
     83          extern volatile u32 G_u32SystemTime1ms;                 /* From board-specific source file */
     84          extern volatile u32 G_u32SystemTime1s;                  /* From board-specific source file */
     85          
     86          extern volatile u32 ANT_SSP_FLAGS;                      /* From configuration.h */
     87          
     88          
     89          /***********************************************************************************************************************
     90          Global variable definitions with scope limited to this local application.
     91          Variable names shall start with "Ant_<type>Name" and be declared as static.
     92          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     93          static fnCode_type Ant_pfnStateMachine;                 /* The ANT state machine function pointer */
   \                     Ant_pfnStateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     94          static u32 Ant_u32RxTimer;                              /* Dedicated timer for receiving bytes */
   \                     Ant_u32RxTimer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     95          static u32 Ant_u32TxTimer;                              /* Dedicated timer for transmitting bytes */
   \                     Ant_u32TxTimer:
   \   00000000                      DS8 4
     96          

   \                                 In section .bss, align 4
     97          static u32 Ant_u32TxByteCounter = 0;                    /* Counter counts callbacks on sent bytes */
   \                     Ant_u32TxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     98          static u32 Ant_u32RxByteCounter = 0;                    /* Counter counts callbacks on received bytes */
   \                     Ant_u32RxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     99          static u32 Ant_u32RxTimeoutCounter = 0;                 /* Increments any time an ANT reception times out */
   \                     Ant_u32RxTimeoutCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    100          static u32 Ant_u32UnexpectedByteCounter = 0;            /* Increments any time a byte is received that was not expected value */
   \                     Ant_u32UnexpectedByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    101          static u32 Ant_u32CurrentTxMessageToken = 0;            /* Token for message currently being sent to ANT */
   \                     Ant_u32CurrentTxMessageToken:
   \   00000000                      DS8 4
    102          

   \                                 In section .bss, align 4
    103          static SspConfigurationType Ant_sSspConfig;             /* Configuration information for SSP peripheral */
   \                     Ant_sSspConfig:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    104          static SspPeripheralType* Ant_Ssp;                      /* Pointer to Ant's SSP peripheral object */
   \                     Ant_Ssp:
   \   00000000                      DS8 4
    105          

   \                                 In section .bss, align 4
    106          static u8 Ant_u8AntVersion[MESG_VERSION_SIZE];          /* ANT device version string */
   \                     Ant_u8AntVersion:
   \   00000000                      DS8 12
    107          

   \                                 In section .bss, align 4
    108          static u8 Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE];       /* Space for verified received ANT messages */
   \                     Ant_au8AntRxBuffer:
   \   00000000                      DS8 256

   \                                 In section .bss, align 4
    109          static u8 *Ant_pu8AntRxBufferNextChar;                  /* Pointer to next char to be written in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    110          static u8 *Ant_pu8AntRxBufferCurrentChar;               /* Pointer to the current char in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferCurrentChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    111          static u8 *Ant_pu8AntRxBufferUnreadMsg;                 /* Pointer to unread chars in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferUnreadMsg:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    112          static u8 Ant_u8AntNewRxMessages;                       /* Counter for number of new messages in AntRxBuffer */
   \                     Ant_u8AntNewRxMessages:
   \   00000000                      DS8 1
    113          

   \                                 In section .bss, align 4
    114          static u32 Ant_u32ApplicationMessageCount = 0;          /* Counts messages queued on G_sAntApplicationMsgList */
   \                     Ant_u32ApplicationMessageCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    115          static AntOutgoingMessageListType *Ant_psDataOutgoingMsgList; /* Linked list of outgoing ANT-formatted messages */
   \                     Ant_psDataOutgoingMsgList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    116          static u32 Ant_u32OutgoingMessageCount = 0;             /* Counts messages queued on Ant_psDataOutgoingMsgList */
   \                     Ant_u32OutgoingMessageCount:
   \   00000000                      DS8 4
    117          

   \                                 In section .bss, align 1
    118          static u8 Ant_u8SlaveMissedMessageHigh = 0;             /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageHigh:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    119          static u8 Ant_u8SlaveMissedMessageMid = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageMid:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    120          static u8 Ant_u8SlaveMissedMessageLow = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageLow:
   \   00000000                      DS8 1
    121          
    122          
    123          /* Debug variables */

   \                                 In section .bss, align 4
    124          static u32 Ant_DebugRxMessageCounter = 0;
   \                     Ant_DebugRxMessageCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    125          static u32 Ant_DebugTotalRxMessages = 0;
   \                     Ant_DebugTotalRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    126          static u32 Ant_DebugProcessRxMessages = 0;
   \                     Ant_DebugProcessRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    127          static u32 Ant_DebugQueuedDataMessages = 0;
   \                     Ant_DebugQueuedDataMessages:
   \   00000000                      DS8 4
    128          
    129          
    130          /***********************************************************************************************************************
    131          !!!!! ANT Serial-layer Functions
    132          ***********************************************************************************************************************/
    133          
    134          /* ANT Private Serial-layer Functions */
    135          
    136          /*------------------------------------------------------------------------------
    137          Function: AntSyncSerialInitialize
    138          
    139          Description:
    140          Properly sets up the ANT SPI interface and tests Host <-> ANT communications.
    141          
    142          Requires:
    143            - ANT_SPI is configured
    144            - !CS (SEN) interrupt should be enabled
    145          // - GPIO interrupts are configured and enabled
    146          
    147          Promises:
    148            - Ant_pu8AntRxBufferNextChar is initialized to start of AntRxBuffer
    149            - Ant_pu8AntRxBufferUnreadMsg is initialized to start of AntRxBuffer
    150            - Ant_u8AntNewRxMessages = 0;
    151            - ANT SSP CS and RX interrupts are enabled
    152            - If ANT starts up correctly and responds to version request, then 
    153              G_u32SystemFlags _APPLICATION_FLAGS_ANT is set and Ant_u8AntVersion is populated
    154              with the returned version information from the ANT IC.  
    155          */

   \                                 In section .text, align 2, keep-with-next
    156          static void AntSyncSerialInitialize(void)
    157          {
   \                     AntSyncSerialInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    158            u32 u32EventTimer;
    159            bool bErrorStatus = FALSE;
   \   00000004   0x2400             MOVS     R4,#+0
    160            
    161            /* Initialize buffer pointers */  
    162            Ant_pu8AntRxBufferNextChar    = Ant_au8AntRxBuffer;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    163            Ant_pu8AntRxBufferCurrentChar = Ant_au8AntRxBuffer;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000018   0x6008             STR      R0,[R1, #+0]
    164            Ant_pu8AntRxBufferUnreadMsg   = Ant_au8AntRxBuffer;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000022   0x6008             STR      R0,[R1, #+0]
    165            Ant_u8AntNewRxMessages = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    166           
    167            /* Reset the 51422 and initialize SRDY and MRDY */
    168            u32EventTimer = G_u32SystemTime1ms;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x9000             STR      R0,[SP, #+0]
    169            ANT_RESET_ASSERT();
   \   00000034   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0x400e0e34
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    170            SYNC_MRDY_DEASSERT();
   \   0000003E   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000046   0x6008             STR      R0,[R1, #+0]
    171            SYNC_SRDY_DEASSERT();
   \   00000048   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000050   0x6008             STR      R0,[R1, #+0]
    172            while( !IsTimeUp(&u32EventTimer, ANT_RESET_WAIT_MS) );
   \                     ??AntSyncSerialInitialize_0: (+1)
   \   00000052   0x2164             MOVS     R1,#+100
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x.... 0x....      BL       IsTimeUp
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD0F9             BEQ.N    ??AntSyncSerialInitialize_0
    173            ANT_RESET_DEASSERT();
   \   0000005E   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000066   0x6008             STR      R0,[R1, #+0]
    174            u32EventTimer = G_u32SystemTime1ms;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x9000             STR      R0,[SP, #+0]
    175            while( !IsTimeUp(&u32EventTimer, ANT_RESTART_DELAY_MS) );
   \                     ??AntSyncSerialInitialize_1: (+1)
   \   00000070   0xF44F 0x717A      MOV      R1,#+1000
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x.... 0x....      BL       IsTimeUp
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD0F8             BEQ.N    ??AntSyncSerialInitialize_1
    176          
    177            
    178            /* ANT should want to send message 0x6F now to indicate it has reset */
    179            u32EventTimer = G_u32SystemTime1ms;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x9000             STR      R0,[SP, #+0]
    180            while( !IS_SEN_ASSERTED() && !bErrorStatus )
   \                     ??AntSyncSerialInitialize_2: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x07C0             LSLS     R0,R0,#+31
   \   0000008E   0xD409             BMI.N    ??AntSyncSerialInitialize_3
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x2C00             CMP      R4,#+0
   \   00000094   0xD106             BNE.N    ??AntSyncSerialInitialize_3
    181            {
    182              bErrorStatus = IsTimeUp(&u32EventTimer, ANT_MSG_TIMEOUT_MS);
   \   00000096   0xF44F 0x717A      MOV      R1,#+1000
   \   0000009A   0x4668             MOV      R0,SP
   \   0000009C   0x.... 0x....      BL       IsTimeUp
   \   000000A0   0x0004             MOVS     R4,R0
   \   000000A2   0xE7F0             B.N      ??AntSyncSerialInitialize_2
    183            }
    184          
    185            if (!bErrorStatus)
   \                     ??AntSyncSerialInitialize_3: (+1)
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x2C00             CMP      R4,#+0
   \   000000A8   0xD113             BNE.N    ??AntSyncSerialInitialize_4
    186            {
    187              /* Receive and process the restart message */
    188              AntRxMessage();
   \   000000AA   0x.... 0x....      BL       AntRxMessage
    189              AntProcessMessage();   
   \   000000AE   0x.... 0x....      BL       AntProcessMessage
    190          
    191            /* Send out version request message and expect response */
    192              G_au8ANTGetVersion[4] = AntCalculateTxChecksum(&G_au8ANTGetVersion[0]);
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \   000000B6   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \   000000BE   0x7108             STRB     R0,[R1, #+4]
    193              AntTxMessage(&G_au8ANTGetVersion[0]);    
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \   000000C4   0x.... 0x....      BL       AntTxMessage
    194              AntExpectResponse(MESG_VERSION_ID, ANT_MSG_TIMEOUT_MS);
   \   000000C8   0xF44F 0x717A      MOV      R1,#+1000
   \   000000CC   0x203E             MOVS     R0,#+62
   \   000000CE   0x.... 0x....      BL       AntExpectResponse
    195            }
    196           
    197          } /* end AntSyncSerialInitialize */
   \                     ??AntSyncSerialInitialize_4: (+1)
   \   000000D2   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    198          
    199          
    200          /*-----------------------------------------------------------------------------
    201          Function: AntSrdyPulse
    202          
    203          Description:
    204          Pulses Srdy with added delays on the front and middle. 
    205          
    206          Requires:
    207            - 
    208          
    209          Promises:
    210            - A delay controlled by ANT_SRDY_DELAY is passed
    211            - SRDY is asserted
    212            - A delay of ANT_SRDY_PERIOD is passed
    213            - SRDY is deasserted
    214          */

   \                                 In section .text, align 2, keep-with-next
    215          static void AntSrdyPulse(void)
    216          {
    217            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     AntSrdyPulse: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_0: (+1)
   \   00000002   0x28C8             CMP      R0,#+200
   \   00000004   0xD201             BCS.N    ??AntSrdyPulse_1
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0xE7FB             B.N      ??AntSrdyPulse_0
    218            SYNC_SRDY_ASSERT();
   \                     ??AntSrdyPulse_1: (+1)
   \   0000000A   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0x400e0e34
   \   00000012   0x6008             STR      R0,[R1, #+0]
    219            
    220            for(u32 i = 0; i < ANT_SRDY_PERIOD; i++);
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_2: (+1)
   \   00000016   0x2814             CMP      R0,#+20
   \   00000018   0xD201             BCS.N    ??AntSrdyPulse_3
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xE7FB             B.N      ??AntSrdyPulse_2
    221            SYNC_SRDY_DEASSERT();
   \                     ??AntSrdyPulse_3: (+1)
   \   0000001E   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000026   0x6008             STR      R0,[R1, #+0]
    222          
    223          } /* end AntSrdyPulse() */
   \   00000028   0x4770             BX       LR               ;; return
    224          
    225          
    226          /*-----------------------------------------------------------------------------
    227          Function: AntRxMessage
    228          
    229          Description:
    230          Completely receive a message from ANT to the Host.  Incoming bytes are deposited directly into the receive
    231          buffer from the SSP ISR which should be extremely fast and complete in a maximum of 500us.  
    232          
    233          Requires:
    234            - _SSP_CS_ASSERTED is set indicating a message is ready to come in 
    235            - G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set if the system wanted to transmit
    236              but ANT wanted to send a message at the same time (so MESG_TX_SYNC has already 
    237              been received); _SSP_RX_COMPLETE must still be set from this.
    238            - Ant_pu8AntRxBufferCurrentChar points to the first byte of the message
    239          
    240          Promises:
    241            - If a good new message has been received, then Ant_u8AntNewMessages is incremented
    242              and the message is at Ant_pu8AntRxBufferUnreadMsg in Ant_au8AntRxBuffer
    243            - If a good message is not received, then Ant_u8AntNewMessages is unchanged.
    244            - In both cases, Ant_pu8AntRxBufferNextChar points at the next empty buffer location
    245          */

   \                                 In section .text, align 2, keep-with-next
    246          static void AntRxMessage(void)
    247          {
   \                     AntRxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    248            u8 u8Checksum;
    249            u8 u8Length;
    250            u32 u32CurrentRxByteCount;
    251            u8 au8RxTimeoutMsg[] = "AntRx: timeout\n\r";
   \   00000004   0xA806             ADD      R0,SP,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_10
   \   0000000A   0x2211             MOVS     R2,#+17
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    252            u8 au8RxFailMsg[] = "AntRx: message failed\n\r";
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_11
   \   00000016   0x2218             MOVS     R2,#+24
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    253            bool bReceptionError = FALSE;
   \   0000001C   0x2700             MOVS     R7,#+0
    254            
    255            /* Ensure we have CS flag */
    256            if( !( IS_SEN_ASSERTED() ) )
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xF140 0x810C      BPL.W    ??AntRxMessage_0
    257            {
    258              return;
    259            }
    260            
    261            /* Initialize the receive timer and get a snapshot of current byte count */
    262            u32CurrentRxByteCount = Ant_u32RxByteCounter;
   \                     ??AntRxMessage_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0006             MOVS     R6,R0
    263            Ant_u32RxTimer = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000038   0x6008             STR      R0,[R1, #+0]
    264            
    265            /* If the Global _ANT_FLAGS_TX_INTERRUPTED flag has been set, then we have already read the TX_SYNC byte */
    266            if(G_u32AntFlags & _ANT_FLAGS_TX_INTERRUPTED)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x00C0             LSLS     R0,R0,#+3
   \   00000042   0xD509             BPL.N    ??AntRxMessage_2
    267            {
    268              /* Clear flag and load the value we know was already received to allow the function to proceed*/
    269              G_u32AntFlags &= ~_ANT_FLAGS_TX_INTERRUPTED;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   00000052   0x6008             STR      R0,[R1, #+0]
    270              
    271              /* Adjust the starting byte counter since it came in during AntTxMessage */
    272              u32CurrentRxByteCount--;
   \   00000054   0x1E76             SUBS     R6,R6,#+1
   \   00000056   0xE015             B.N      ??AntRxMessage_3
    273              
    274            }
    275            /* Otherwise we need to first read the sync byte  */
    276            else
    277            {
    278              /* Do short delay then cycle SRDY to get the first byte */
    279              AntSrdyPulse();
   \                     ??AntRxMessage_2: (+1)
   \   00000058   0x.... 0x....      BL       AntSrdyPulse
    280          
    281              /* Begin the receive cycle that takes place using interrupts and callbacks and is monitored by a timeout of 
    282              about 500us - this should be plenty of time to receive even the longest ANT message but still only half the 
    283              allowed 1ms loop time for the system. */
    284              
    285              /* Read the first byte when it comes in */
    286              while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) &&
    287                     (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0740             LSLS     R0,R0,#+29
   \   00000064   0xD40E             BMI.N    ??AntRxMessage_3
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF242 0x7110      MOVW     R1,#+10000
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD207             BCS.N    ??AntRxMessage_3
    288              {
    289                Ant_u32RxTimer++;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0xE7EB             B.N      ??AntRxMessage_4
    290              }
    291            }
    292            
    293            if( Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT) 
   \                     ??AntRxMessage_3: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF242 0x7111      MOVW     R1,#+10001
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD305             BCC.N    ??AntRxMessage_5
    294            {
    295              AntAbortMessage();
   \   00000092   0x.... 0x....      BL       AntAbortMessage
    296              DebugPrintf(au8RxTimeoutMsg);
   \   00000096   0xA806             ADD      R0,SP,#+24
   \   00000098   0x.... 0x....      BL       DebugPrintf
    297              return;
   \   0000009C   0xE0D1             B.N      ??AntRxMessage_0
    298            }
    299          
    300            /* _SSP_RX_COMPLETE flag will be set and the Rx callback will have run.  
    301            The callback does NOT toggle SRDY yet.  _SSP_RX_COMPLETE should still
    302            be set from AntTxMessage if that's what got us here. */
    303            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \                     ??AntRxMessage_5: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    304             
    305            /* One way or the other, we now have a potential SYNC byte at Ant_pu8AntRxBufferCurrentChar.  
    306            Proceed to test it and receive the rest of the message */
    307            if (*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC)                     
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0x28A4             CMP      R0,#+164
   \   000000B8   0xF040 0x8087      BNE.W    ??AntRxMessage_6
    308            {
    309              /* Flag that a reception is in progress */
    310              G_u32AntFlags |= _ANT_FLAGS_RX_IN_PROGRESS;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    311              
    312              /* Delay and then cycle SRDY to get the next byte (length) */
    313              AntSrdyPulse();
   \   000000CC   0x.... 0x....      BL       AntSrdyPulse
    314              
    315              /* The SSP interrupts and Rx callback handle the rest of the reception until a full message is received. 
    316              We know it is received when SEN is deasserted. */
    317              while( IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_7: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x07C0             LSLS     R0,R0,#+31
   \   000000D8   0xD50E             BPL.N    ??AntRxMessage_8
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF242 0x7110      MOVW     R1,#+10000
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD207             BCS.N    ??AntRxMessage_8
    318              {
    319                Ant_u32RxTimer++;
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   000000F4   0x6008             STR      R0,[R1, #+0]
   \   000000F6   0xE7EB             B.N      ??AntRxMessage_7
    320              }
    321            
    322              /* One way or another, this Rx is done! */
    323              G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \                     ??AntRxMessage_8: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   00000106   0x6008             STR      R0,[R1, #+0]
    324              ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000116   0x6008             STR      R0,[R1, #+0]
    325          
    326              /* Check that the above loop ended as expected and didn't time out */
    327              if(Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD247             BCS.N    ??AntRxMessage_9
    328              {  
    329                /* Update counter to see how many bytes we should have */
    330                u32CurrentRxByteCount = Ant_u32RxByteCounter - u32CurrentRxByteCount;
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x1B86             SUBS     R6,R0,R6
    331              
    332                /* RxBufferCurrentChar is still pointing to the SYNC byte. Validate what should be a complete message now. */
    333                u8Checksum = *Ant_pu8AntRxBufferCurrentChar;
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x0004             MOVS     R4,R0
    334                AdvanceAntRxBufferCurrentChar();
   \   00000138   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    335                
    336                /* Read the length byte and add two to count the length byte and message ID but not checksum as length will be our checksum counter */
    337                u8Length = *Ant_pu8AntRxBufferCurrentChar + 2;  
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x7800             LDRB     R0,[R0, #+0]
   \   00000144   0x1C80             ADDS     R0,R0,#+2
   \   00000146   0x0005             MOVS     R5,R0
    338                
    339                /* Optional check (u8Length does not include the SYNC byte or Checksum byte so add 2) */
    340                if(u32CurrentRxByteCount != (u8Length + 2) )
   \   00000148   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014A   0x1CA8             ADDS     R0,R5,#+2
   \   0000014C   0x4286             CMP      R6,R0
   \   0000014E   0xD007             BEQ.N    ??AntRxMessage_10
    341                {
    342                  /* Could throw out the message right away - this could save some potential weird memory accesses
    343                  if there was any corruption or a wild u8Length value */
    344                  G_u32AntFlags |= _ANT_FLAGS_LENGTH_MISMATCH;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   0000015E   0x6008             STR      R0,[R1, #+0]
    345                }
    346           
    347                /* Validate the remaining bytes based on u8Length*/
    348                do
    349                {
    350                  u8Checksum ^= *Ant_pu8AntRxBufferCurrentChar;                     
   \                     ??AntRxMessage_10: (+1)
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x7800             LDRB     R0,[R0, #+0]
   \   00000168   0x4044             EORS     R4,R0,R4
    351                  AdvanceAntRxBufferCurrentChar();
   \   0000016A   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    352                } while (--u8Length);
   \   0000016E   0x1E6D             SUBS     R5,R5,#+1
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD1F4             BNE.N    ??AntRxMessage_10
    353                
    354                /* AntRxBufferCurrentChar is pointing to the last received byte that should be the checksum. */
    355                if (u8Checksum == *Ant_pu8AntRxBufferCurrentChar)      
   \   00000176   0x0020             MOVS     R0,R4
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000017C   0x6809             LDR      R1,[R1, #+0]
   \   0000017E   0x7809             LDRB     R1,[R1, #+0]
   \   00000180   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000182   0x4288             CMP      R0,R1
   \   00000184   0xD10E             BNE.N    ??AntRxMessage_11
    356                {
    357                  Ant_u8AntNewRxMessages++;
   \   00000186   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   0000018A   0x7800             LDRB     R0,[R0, #+0]
   \   0000018C   0x1C40             ADDS     R0,R0,#+1
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000192   0x7008             STRB     R0,[R1, #+0]
    358                  Ant_DebugTotalRxMessages++;
   \   00000194   0x.... 0x....      LDR.W    R0,??DataTable14_15
   \   00000198   0x6800             LDR      R0,[R0, #+0]
   \   0000019A   0x1C40             ADDS     R0,R0,#+1
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   000001A0   0x6008             STR      R0,[R1, #+0]
   \   000001A2   0xE01B             B.N      ??AntRxMessage_12
    359                }
    360                /* If the message was not good, then move Ant_pu8AntRxBufferUnreadMsg passed the garbage data */
    361                else
    362                {
    363                  Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferCurrentChar;
   \                     ??AntRxMessage_11: (+1)
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000001A8   0x6800             LDR      R0,[R0, #+0]
   \   000001AA   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000001AE   0x6008             STR      R0,[R1, #+0]
    364                  AdvanceAntRxBufferUnreadMsgPointer();
   \   000001B0   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   \   000001B4   0xE012             B.N      ??AntRxMessage_12
    365                }
    366              } 
    367              else
    368              {
    369                Ant_u32RxTimeoutCounter++;
   \                     ??AntRxMessage_9: (+1)
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable14_16
   \   000001BA   0x6800             LDR      R0,[R0, #+0]
   \   000001BC   0x1C40             ADDS     R0,R0,#+1
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \   000001C2   0x6008             STR      R0,[R1, #+0]
    370                bReceptionError = TRUE;
   \   000001C4   0x2001             MOVS     R0,#+1
   \   000001C6   0x0007             MOVS     R7,R0
   \   000001C8   0xE008             B.N      ??AntRxMessage_12
    371              }
    372            } /* end if(*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC) */
    373            else
    374            {
    375              /* Otherwise we have received an unexpected byte -- flag it, clear Ssp flags and abandon the byte */
    376              Ant_u32UnexpectedByteCounter++;
   \                     ??AntRxMessage_6: (+1)
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \   000001CE   0x6800             LDR      R0,[R0, #+0]
   \   000001D0   0x1C40             ADDS     R0,R0,#+1
   \   000001D2   0x.... 0x....      LDR.W    R1,??DataTable14_17
   \   000001D6   0x6008             STR      R0,[R1, #+0]
    377              bReceptionError = TRUE;
   \   000001D8   0x2001             MOVS     R0,#+1
   \   000001DA   0x0007             MOVS     R7,R0
    378            }
    379          
    380            /* If a reception error has occured, */
    381            if(bReceptionError)
   \                     ??AntRxMessage_12: (+1)
   \   000001DC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001DE   0x2F00             CMP      R7,#+0
   \   000001E0   0xD02D             BEQ.N    ??AntRxMessage_13
    382            {
    383              /* Toggle SRDY until CS deasserts and throw out the message */
    384              DebugPrintf(au8RxFailMsg);
   \   000001E2   0x4668             MOV      R0,SP
   \   000001E4   0x.... 0x....      BL       DebugPrintf
    385              while( IS_SEN_ASSERTED()  && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_14: (+1)
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000001EC   0x6800             LDR      R0,[R0, #+0]
   \   000001EE   0x07C0             LSLS     R0,R0,#+31
   \   000001F0   0xD510             BPL.N    ??AntRxMessage_15
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   000001F6   0x6800             LDR      R0,[R0, #+0]
   \   000001F8   0xF242 0x7110      MOVW     R1,#+10000
   \   000001FC   0x4288             CMP      R0,R1
   \   000001FE   0xD209             BCS.N    ??AntRxMessage_15
    386              {
    387                Ant_u32RxTimer++;
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0x1C40             ADDS     R0,R0,#+1
   \   00000208   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   0000020C   0x6008             STR      R0,[R1, #+0]
    388                AntSrdyPulse();
   \   0000020E   0x.... 0x....      BL       AntSrdyPulse
   \   00000212   0xE7E9             B.N      ??AntRxMessage_14
    389              }
    390             
    391              /* Since we have flow control, we can safely assume that no other messages
    392              have come in and Ant_pu8AntRxBufferNextChar is pointing to where the next 
    393              valid message WILL come in - so push all the pointers there. */
    394              Ant_pu8AntRxBufferCurrentChar = Ant_pu8AntRxBufferNextChar;
   \                     ??AntRxMessage_15: (+1)
   \   00000214   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000218   0x6800             LDR      R0,[R0, #+0]
   \   0000021A   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000021E   0x6008             STR      R0,[R1, #+0]
    395              Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferNextChar;
   \   00000220   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000224   0x6800             LDR      R0,[R0, #+0]
   \   00000226   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000022A   0x6008             STR      R0,[R1, #+0]
    396              ANT_SSP_FLAGS &= ~(_SSP_TX_COMPLETE | _SSP_RX_COMPLETE);
   \   0000022C   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000230   0x6800             LDR      R0,[R0, #+0]
   \   00000232   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000236   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   0000023A   0x6008             STR      R0,[R1, #+0]
   \   0000023C   0xE001             B.N      ??AntRxMessage_16
    397          
    398            }
    399            else
    400            {
    401              /* In all other cases, finish by advancing the current byte pointer */
    402              AdvanceAntRxBufferCurrentChar();
   \                     ??AntRxMessage_13: (+1)
   \   0000023E   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    403            }
    404            
    405          } /* end AntRxMessage() */
   \                     ??AntRxMessage_16: (+1)
   \                     ??AntRxMessage_0: (+1)
   \   00000242   0xB00B             ADD      SP,SP,#+44
   \   00000244   0xBDF0             POP      {R4-R7,PC}       ;; return
    406          
    407          
    408          /*-----------------------------------------------------------------------------
    409          Function: AntAbortMessage
    410          
    411          Description:
    412          Kills the current message in progress with ANT and resets all of the pointers.
    413          Any existing received buffer data is lost.
    414          
    415          *** Warning: all interrupts are disabled, so this could impact system tick time ***
    416          
    417          Requires:
    418            - 
    419          
    420          Promises:
    421            - Ant_pu8AntRxBufferNextChar, Ant_pu8AntRxBufferCurrentChar, Ant_pu8AntRxBufferUnreadMsg,
    422              and Ant_u8AntNewRxMessages reset.
    423          */

   \                                 In section .text, align 2, keep-with-next
    424          static void AntAbortMessage(void)
    425          {
    426            __disable_interrupt();
   \                     AntAbortMessage: (+1)
   \   00000000   0xB672             CPSID    I
    427            Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    428            Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000014   0x6008             STR      R0,[R1, #+0]
    429            Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    430            Ant_u8AntNewRxMessages = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    431            __enable_interrupt();
   \   00000028   0xB662             CPSIE    I
    432            
    433          } /* end AntAbortMessage() */
   \   0000002A   0x4770             BX       LR               ;; return
    434          
    435          
    436          /*-----------------------------------------------------------------------------
    437          Function: AdvanceAntRxBufferCurrentChar
    438          
    439          Description:
    440          Safely advances the Ant_pu8AntRxBufferCurrentChar within the circular buffer
    441          
    442          Requires:
    443            - No interrupt functions using Ant_pu8AntRxBufferCurrentChar are allowed to run
    444          
    445          Promises:
    446            - Ant_pu8AntRxBufferCurrentChar points to the next char to write in Ant_au8AntRxBuffer
    447          */

   \                                 In section .text, align 2, keep-with-next
    448          static void AdvanceAntRxBufferCurrentChar(void)
    449          {
    450            Ant_pu8AntRxBufferCurrentChar++;
   \                     AdvanceAntRxBufferCurrentChar: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    451            if(Ant_pu8AntRxBufferCurrentChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferCurrentChar_0
    452            {
    453              Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000024   0x6008             STR      R0,[R1, #+0]
    454            }
    455            
    456          } /* end AdvanceAntRxBufferCurrentChar() */
   \                     ??AdvanceAntRxBufferCurrentChar_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    457          
    458          
    459          /*-----------------------------------------------------------------------------/
    460          Function: AdvanceAntRxBufferUnreadMsgPointer
    461          
    462          Description:
    463          Increments the Rx buffer pointer and handles the wrap-around.
    464          
    465          Requires:
    466            - Ant_pu8AntRxBufferUnreadMsg cannot be moved in an ISR
    467          
    468          Promises:
    469            - Ant_pu8AntRxBufferUnreadMsg is pointing to the next char in the circular buffer
    470          */

   \                                 In section .text, align 2, keep-with-next
    471          static void AdvanceAntRxBufferUnreadMsgPointer()
    472          {
    473            Ant_pu8AntRxBufferUnreadMsg++;
   \                     AdvanceAntRxBufferUnreadMsgPointer: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    474            if (Ant_pu8AntRxBufferUnreadMsg == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferUnreadMsgPointer_0
    475            {
    476              Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000024   0x6008             STR      R0,[R1, #+0]
    477            }
    478            
    479          } /* end AdvanceAntRxBufferUnreadMsgPointer() */
   \                     ??AdvanceAntRxBufferUnreadMsgPointer_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    480          
    481            
    482          /*------------------------------------------------------------------------------
    483          Function: AntParseExtendedData
    484          
    485          Description:
    486          Reads extended data based on the flags that are set.
    487          Loads into AntExtendedDataType which currently has these fields:
    488          {
    489            u8 u8Channel;                        
    490            u16 u16DeviceID;                         
    491            u8 u8DeviceType;                         
    492            u8 u8TransType;                          
    493            u8 u8Flags;                             
    494            s8 s8RSSI;                              
    495          } AntExtendedDataType;
    496          
    497          Requires:
    498            - pu8SourceMessage_ points to an ANT message buffer that holds a complete ANT data
    499              message structure except for SYNC byte.  antmessage.h Buffer Indices an then be used.
    500            - psExtDataTarget_ points to the target AntExtendedDataType structure
    501          
    502          Promises:
    503            - If extended data is present, all values are read into local variables and then
    504              loaded into psExtDataTarget_ and the function returns TRUE.
    505            - If no extended data is present, psExtDataTarget_ is set to default values and
    506              the function returns FALSE.
    507          */

   \                                 In section .text, align 2, keep-with-next
    508          static bool AntParseExtendedData(u8* pu8SourceMessage, AntExtendedDataType* psExtDataTarget_)
    509          {
   \                     AntParseExtendedData: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    510            bool bReturnValue;
    511            u8 u8MessageSize;
    512            u8 u8Channel;                        
    513            u8 u8Flags = 0;       
   \   00000008   0x2600             MOVS     R6,#+0
    514            u8 u8BufferOffset = 0;
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    515            
    516            /* Channel ID extended data */
    517            u16 u16DeviceID = 0xFFFF;;                         
   \   0000000E   0xF64F 0x7AFF      MOVW     R10,#+65535
    518            u8 u8DeviceType = 0xFF;                        
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0xF88D 0x0002      STRB     R0,[SP, #+2]
    519            u8 u8TransType = 0xFF;                          
   \   00000018   0x27FF             MOVS     R7,#+255
    520          
    521            /* RSSI extended data */
    522            s8 s8RSSI = 0xFF;   
   \   0000001A   0xF05F 0x38FF      MOVS     R8,#-1
    523            //For now, we don't have a use for these two:
    524            //u8 u8MeasurementType = 0xFF;
    525            //u8 u8Threshold = 0xFF;
    526            
    527            /* RF Timestamp data */
    528            u16 u16RxTimestamp = 0xFFFF;
   \   0000001E   0xF64F 0x79FF      MOVW     R9,#+65535
    529              
    530            /* Get generic data */
    531            u8MessageSize = *(pu8SourceMessage + BUFFER_INDEX_MESG_SIZE);
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0xF88D 0x0000      STRB     R0,[SP, #+0]
    532            u8Channel = *(pu8SourceMessage + BUFFER_INDEX_CHANNEL_NUM);
   \   00000028   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    533          
    534            /* Check to see if the message is the regular size (MESG_MAX_DATA_SIZE) */
    535            if(u8MessageSize == MESG_MAX_DATA_SIZE)
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xD103             BNE.N    ??AntParseExtendedData_0
    536            {
    537              bReturnValue = FALSE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000003C   0xE058             B.N      ??AntParseExtendedData_1
    538            }
    539            
    540            /* Check for a message that is too big or too small */
    541            else if( (u8MessageSize > MESG_MAX_SIZE) ||
    542                     (u8MessageSize < MESG_MAX_DATA_SIZE) )
   \                     ??AntParseExtendedData_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2812             CMP      R0,#+18
   \   00000044   0xDA03             BGE.N    ??AntParseExtendedData_2
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0x2809             CMP      R0,#+9
   \   0000004C   0xDA07             BGE.N    ??AntParseExtendedData_3
    543            {
    544              DebugPrintf("\n\rUnexpected ANT message size\n\n\r");
   \                     ??AntParseExtendedData_2: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000052   0x.... 0x....      BL       DebugPrintf
    545              bReturnValue = FALSE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000005C   0xE048             B.N      ??AntParseExtendedData_1
    546            }
    547            
    548            /* Otherwise we have some extended message data */
    549            else 
    550            {
    551              /* Byte after data must be flag byte */
    552              u8Flags = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA_FLAGS);
   \                     ??AntParseExtendedData_3: (+1)
   \   0000005E   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000060   0x0006             MOVS     R6,R0
    553              bReturnValue = TRUE;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF88D 0x0001      STRB     R0,[SP, #+1]
    554              
    555              /* Channel ID information is always first if it's there */
    556              if(u8Flags & LIB_CONFIG_CHANNEL_ID_FLAG)
   \   00000068   0x0630             LSLS     R0,R6,#+24
   \   0000006A   0xD521             BPL.N    ??AntParseExtendedData_4
    557              {
    558                u16DeviceID = (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \   0000006C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000070   0xEB04 0x000B      ADD      R0,R4,R11
   \   00000074   0x7B00             LDRB     R0,[R0, #+12]
   \   00000076   0x4682             MOV      R10,R0
    559                u8BufferOffset++;
   \   00000078   0xF11B 0x0B01      ADDS     R11,R11,#+1
    560                u16DeviceID |= ( (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \   0000007C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000080   0xEB04 0x000B      ADD      R0,R4,R11
   \   00000084   0x7B00             LDRB     R0,[R0, #+12]
   \   00000086   0xEA5A 0x2A00      ORRS     R10,R10,R0, LSL #+8
    561                u8BufferOffset++;
   \   0000008A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    562                u8DeviceType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   0000008E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000092   0xEB04 0x000B      ADD      R0,R4,R11
   \   00000096   0x7B00             LDRB     R0,[R0, #+12]
   \   00000098   0xF88D 0x0002      STRB     R0,[SP, #+2]
    563                u8BufferOffset++;
   \   0000009C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    564                u8TransType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000A0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A4   0xEB04 0x000B      ADD      R0,R4,R11
   \   000000A8   0x7B00             LDRB     R0,[R0, #+12]
   \   000000AA   0x0007             MOVS     R7,R0
    565                u8BufferOffset++;
   \   000000AC   0xF11B 0x0B01      ADDS     R11,R11,#+1
    566              }
    567              
    568              /* RSSI information is always next if it's there */
    569              if(u8Flags & LIB_CONFIG_RSSI_FLAG)
   \                     ??AntParseExtendedData_4: (+1)
   \   000000B0   0x0670             LSLS     R0,R6,#+25
   \   000000B2   0xD50C             BPL.N    ??AntParseExtendedData_5
    570              {
    571                //u8MeasurementType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
    572                u8BufferOffset++;
   \   000000B4   0xF11B 0x0B01      ADDS     R11,R11,#+1
    573                s8RSSI = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000B8   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000BC   0xEB04 0x000B      ADD      R0,R4,R11
   \   000000C0   0xF990 0x000C      LDRSB    R0,[R0, #+12]
   \   000000C4   0x4680             MOV      R8,R0
    574                u8BufferOffset++;
   \   000000C6   0xF11B 0x0B01      ADDS     R11,R11,#+1
    575                //u8Threshold = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
    576                u8BufferOffset++;
   \   000000CA   0xF11B 0x0B01      ADDS     R11,R11,#+1
    577             }   
    578          
    579              /* Timestamp information is always last */
    580              if(u8Flags & LIB_CONFIG_RX_TIMESTAMP_FLAG)
   \                     ??AntParseExtendedData_5: (+1)
   \   000000CE   0x06B0             LSLS     R0,R6,#+26
   \   000000D0   0xD50E             BPL.N    ??AntParseExtendedData_1
    581              {
    582                u16RxTimestamp = (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \   000000D2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D6   0xEB04 0x000B      ADD      R0,R4,R11
   \   000000DA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000DC   0x4681             MOV      R9,R0
    583                u8BufferOffset++;
   \   000000DE   0xF11B 0x0B01      ADDS     R11,R11,#+1
    584                u16RxTimestamp |= ( (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \   000000E2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000E6   0xEB04 0x000B      ADD      R0,R4,R11
   \   000000EA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000EC   0xEA59 0x2900      ORRS     R9,R9,R0, LSL #+8
    585              }
    586            }
    587            
    588            /* Load psExtDataTarget_ and return */
    589            psExtDataTarget_->u8Flags      = u8Flags;
   \                     ??AntParseExtendedData_1: (+1)
   \   000000F0   0x706E             STRB     R6,[R5, #+1]
    590            psExtDataTarget_->u8Channel    = u8Channel;
   \   000000F2   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000F6   0x7028             STRB     R0,[R5, #+0]
    591            psExtDataTarget_->u16DeviceID  = u16DeviceID;
   \   000000F8   0xF8A5 0xA002      STRH     R10,[R5, #+2]
    592            psExtDataTarget_->u8DeviceType = u8DeviceType;
   \   000000FC   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000100   0x7128             STRB     R0,[R5, #+4]
    593            psExtDataTarget_->u8TransType  = u8TransType;
   \   00000102   0x716F             STRB     R7,[R5, #+5]
    594            psExtDataTarget_->s8RSSI       = s8RSSI;
   \   00000104   0xF885 0x8006      STRB     R8,[R5, #+6]
    595          
    596            return bReturnValue;
   \   00000108   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000010C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    597            
    598          } /* end AntParseExtendedData */
    599          
    600          
    601          /***********************************************************************************************************************
    602          @@@@@ ANT Interface-layer Functions
    603          ***********************************************************************************************************************/
    604            
    605          /*------------------------------------------------------------------------------
    606          Function: AntInitialize
    607          
    608          Description:
    609          Intialize the ANT system.  ANT device is reset and communication checked through
    610          a version request.  The main channel parameters are then set up to default values.
    611            
    612          Requires:
    613            - ANT_SPI peripheral is correctly configured
    614            - Debug system is initialized so debug messages can be sent to UART
    615          
    616          Promises:
    617            - G_stAntSetupData set to default ANT values
    618            - If all successful, G_u32SystemFlags.AntGood bit is set and ANT system is ready
    619            - Ant_pfnStateMachine = AntSM_Idle
    620          */

   \                                 In section .text, align 2, keep-with-next
    621          void AntInitialize(void)
    622          {
   \                     AntInitialize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    623            u32 u32AntPortAPins, u32AntPortBPins;
    624          
    625            if(G_u32SystemFlags & _SYSTEM_STARTUP_NO_ANT)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x01C0             LSLS     R0,R0,#+7
   \   0000000A   0xD509             BPL.N    ??AntInitialize_0
    626            {
    627              DebugPrintf(G_au8AntMessageNoAnt);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000010   0x.... 0x....      BL       DebugPrintf
    628              Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE10F             B.N      ??AntInitialize_1
    629            }
    630            else
    631            {
    632              /* Give PIO control of ANT_RESET line */
    633              AT91C_BASE_PIOB->PIO_OER = PB_21_ANT_RESET;
   \                     ??AntInitialize_0: (+1)
   \   00000020   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x400e0e10
   \   00000028   0x6008             STR      R0,[R1, #+0]
    634              
    635              /* Announce on the debug port that ANT setup is starting and intialize pointers */
    636              DebugPrintf(G_au8AntMessageInit);
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000002E   0x.... 0x....      BL       DebugPrintf
    637              G_sAntApplicationMsgList = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000038   0x6008             STR      R0,[R1, #+0]
    638              Ant_psDataOutgoingMsgList = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000040   0x6008             STR      R0,[R1, #+0]
    639            
    640            /* Initialize the G_asAntChannelConfiguration data struct */
    641            for(u8 i = 0; i < ANT_NUM_CHANNELS; i++)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??AntInitialize_2: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2808             CMP      R0,#+8
   \   00000048   0xDA7C             BGE.N    ??AntInitialize_3
    642            {
    643              G_asAntChannelConfiguration[i].AntChannel          = (AntChannelNumberType)i;
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2214             MOVS     R2,#+20
   \   00000052   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000056   0x5488             STRB     R0,[R1, R2]
    644              G_asAntChannelConfiguration[i].AntChannelType      = 0xFF;
   \   00000058   0x21FF             MOVS     R1,#+255
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2314             MOVS     R3,#+20
   \   00000062   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000066   0x441A             ADD      R2,R2,R3
   \   00000068   0x7051             STRB     R1,[R2, #+1]
    645              G_asAntChannelConfiguration[i].AntNetwork          = 0xFF;
   \   0000006A   0x21FF             MOVS     R1,#+255
   \   0000006C   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x2314             MOVS     R3,#+20
   \   00000074   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000078   0x441A             ADD      R2,R2,R3
   \   0000007A   0x7091             STRB     R1,[R2, #+2]
    646              G_asAntChannelConfiguration[i].AntDeviceIdLo       = 0xFF;
   \   0000007C   0x21FF             MOVS     R1,#+255
   \   0000007E   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x2314             MOVS     R3,#+20
   \   00000086   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000008A   0x441A             ADD      R2,R2,R3
   \   0000008C   0x72D1             STRB     R1,[R2, #+11]
    647              G_asAntChannelConfiguration[i].AntDeviceIdHi       = 0xFF;
   \   0000008E   0x21FF             MOVS     R1,#+255
   \   00000090   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x2314             MOVS     R3,#+20
   \   00000098   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000009C   0x441A             ADD      R2,R2,R3
   \   0000009E   0x7311             STRB     R1,[R2, #+12]
    648              G_asAntChannelConfiguration[i].AntDeviceType       = 0xFF;
   \   000000A0   0x21FF             MOVS     R1,#+255
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x2314             MOVS     R3,#+20
   \   000000AA   0xFB03 0xF300      MUL      R3,R3,R0
   \   000000AE   0x441A             ADD      R2,R2,R3
   \   000000B0   0x7351             STRB     R1,[R2, #+13]
    649              G_asAntChannelConfiguration[i].AntTransmissionType = 0xFF;
   \   000000B2   0x21FF             MOVS     R1,#+255
   \   000000B4   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x2314             MOVS     R3,#+20
   \   000000BC   0xFB03 0xF300      MUL      R3,R3,R0
   \   000000C0   0x441A             ADD      R2,R2,R3
   \   000000C2   0x7391             STRB     R1,[R2, #+14]
    650              G_asAntChannelConfiguration[i].AntChannelPeriodLo  = 0xFF;
   \   000000C4   0x21FF             MOVS     R1,#+255
   \   000000C6   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0x2314             MOVS     R3,#+20
   \   000000CE   0xFB03 0xF300      MUL      R3,R3,R0
   \   000000D2   0x441A             ADD      R2,R2,R3
   \   000000D4   0x73D1             STRB     R1,[R2, #+15]
    651              G_asAntChannelConfiguration[i].AntChannelPeriodHi  = 0xFF;
   \   000000D6   0x21FF             MOVS     R1,#+255
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x2314             MOVS     R3,#+20
   \   000000E0   0xFB03 0xF300      MUL      R3,R3,R0
   \   000000E4   0x441A             ADD      R2,R2,R3
   \   000000E6   0x7411             STRB     R1,[R2, #+16]
    652              G_asAntChannelConfiguration[i].AntFrequency        = 0xFF;
   \   000000E8   0x21FF             MOVS     R1,#+255
   \   000000EA   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0x2314             MOVS     R3,#+20
   \   000000F2   0xFB03 0xF300      MUL      R3,R3,R0
   \   000000F6   0x441A             ADD      R2,R2,R3
   \   000000F8   0x7451             STRB     R1,[R2, #+17]
    653              G_asAntChannelConfiguration[i].AntTxPower          = 0xFF;
   \   000000FA   0x21FF             MOVS     R1,#+255
   \   000000FC   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000100   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000102   0x2314             MOVS     R3,#+20
   \   00000104   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000108   0x441A             ADD      R2,R2,R3
   \   0000010A   0x7491             STRB     R1,[R2, #+18]
    654              G_asAntChannelConfiguration[i].AntFlags            = 0;
   \   0000010C   0x2100             MOVS     R1,#+0
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0x2314             MOVS     R3,#+20
   \   00000116   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000011A   0x441A             ADD      R2,R2,R3
   \   0000011C   0x74D1             STRB     R1,[R2, #+19]
    655              
    656              for(u8 j = 0; j < ANT_NETWORK_NUMBER_BYTES; j++)
   \   0000011E   0x2100             MOVS     R1,#+0
   \                     ??AntInitialize_4: (+1)
   \   00000120   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   0x2908             CMP      R1,#+8
   \   00000124   0xDA0C             BGE.N    ??AntInitialize_5
    657              {
    658                G_asAntChannelConfiguration[i].AntNetworkKey[j] = 0;
   \   00000126   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   0000012A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012C   0x2314             MOVS     R3,#+20
   \   0000012E   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000132   0x441A             ADD      R2,R2,R3
   \   00000134   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000136   0x440A             ADD      R2,R2,R1
   \   00000138   0x2300             MOVS     R3,#+0
   \   0000013A   0x70D3             STRB     R3,[R2, #+3]
    659              }
   \   0000013C   0x1C49             ADDS     R1,R1,#+1
   \   0000013E   0xE7EF             B.N      ??AntInitialize_4
    660            }
   \                     ??AntInitialize_5: (+1)
   \   00000140   0x1C40             ADDS     R0,R0,#+1
   \   00000142   0xE77F             B.N      ??AntInitialize_2
    661              
    662              /* Configure the SSP resource to be used for the application */
    663              Ant_sSspConfig.SspPeripheral      = ANT_SPI;
   \                     ??AntInitialize_3: (+1)
   \   00000144   0x2004             MOVS     R0,#+4
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   0000014A   0x7008             STRB     R0,[R1, #+0]
    664              Ant_sSspConfig.pCsGpioAddress     = ANT_SPI_CS_GPIO;
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x400e0e00
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000154   0x6048             STR      R0,[R1, #+4]
    665              Ant_sSspConfig.u32CsPin           = ANT_SPI_CS_PIN;
   \   00000156   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   0000015E   0x6088             STR      R0,[R1, #+8]
    666              Ant_sSspConfig.eBitOrder          = LSB_FIRST;
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000166   0x7308             STRB     R0,[R1, #+12]
    667              Ant_sSspConfig.eSspMode           = SPI_SLAVE_FLOW_CONTROL;
   \   00000168   0x2003             MOVS     R0,#+3
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   0000016E   0x7348             STRB     R0,[R1, #+13]
    668              Ant_sSspConfig.fnSlaveTxFlowCallback = AntTxFlowControlCallback;
   \   00000170   0x.... 0x....      ADR.W    R0,AntTxFlowControlCallback
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000178   0x6108             STR      R0,[R1, #+16]
    669              Ant_sSspConfig.fnSlaveRxFlowCallback = AntRxFlowControlCallback;
   \   0000017A   0x.... 0x....      ADR.W    R0,AntRxFlowControlCallback
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000182   0x6148             STR      R0,[R1, #+20]
    670              Ant_sSspConfig.pu8RxBufferAddress = Ant_au8AntRxBuffer;
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   0000018C   0x6188             STR      R0,[R1, #+24]
    671              Ant_sSspConfig.ppu8RxNextByte     = &Ant_pu8AntRxBufferNextChar;
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000192   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000196   0x61C8             STR      R0,[R1, #+28]
    672              Ant_sSspConfig.u16RxBufferSize    = ANT_RX_BUFFER_SIZE;
   \   00000198   0xF44F 0x7080      MOV      R0,#+256
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   000001A0   0x8408             STRH     R0,[R1, #+32]
    673          
    674              Ant_Ssp = SspRequest(&Ant_sSspConfig);
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   000001A6   0x.... 0x....      BL       SspRequest
   \   000001AA   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000001AE   0x6008             STR      R0,[R1, #+0]
    675              ANT_SSP_FLAGS = 0;
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   000001B6   0x6008             STR      R0,[R1, #+0]
    676              
    677              /* Reset ANT, activate SPI interface and get a test message */
    678              AntSyncSerialInitialize();
   \   000001B8   0x.... 0x....      BL       AntSyncSerialInitialize
    679              
    680              /* Report status out the debug port */
    681              if(G_u32ApplicationFlags & _APPLICATION_FLAGS_ANT)  
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   000001C0   0x7800             LDRB     R0,[R0, #+0]
   \   000001C2   0x06C0             LSLS     R0,R0,#+27
   \   000001C4   0xD51B             BPL.N    ??AntInitialize_6
    682              {
    683                DebugPrintf(G_au8AntMessageOk);
   \   000001C6   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \   000001CA   0x.... 0x....      BL       DebugPrintf
    684                DebugPrintf("ANT version: ");
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   000001D2   0x.... 0x....      BL       DebugPrintf
    685                DebugPrintf(Ant_u8AntVersion);
   \   000001D6   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   000001DA   0x.... 0x....      BL       DebugPrintf
    686                DebugLineFeed();
   \   000001DE   0x.... 0x....      BL       DebugLineFeed
    687                
    688                G_u32AntFlags &= ~_ANT_FLAGS_RESTART;
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   000001E6   0x6800             LDR      R0,[R0, #+0]
   \   000001E8   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   000001F0   0x6008             STR      R0,[R1, #+0]
    689                Ant_pfnStateMachine = AntSM_Idle;
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable20_7
   \   000001F6   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000001FA   0x6008             STR      R0,[R1, #+0]
   \   000001FC   0xE020             B.N      ??AntInitialize_1
    690              }
    691              else
    692              {
    693                /* The ANT device is not responding -- it may be dead, or it may not yet
    694                be loaded with any firmware.  Regardless, float all of the interface lines so 
    695                that any programmer or other firmware will not be impacted by the Host MCU */
    696                DebugPrintf(G_au8AntMessageInitFail);
   \                     ??AntInitialize_6: (+1)
   \   000001FE   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000202   0x.... 0x....      BL       DebugPrintf
    697          
    698                /* Make sure all ANT pins are on the PIO controller */
    699                u32AntPortAPins = ANT_PIOA_PINS;
   \   00000206   0xF05F 0x7030      MOVS     R0,#+46137344
   \   0000020A   0x0004             MOVS     R4,R0
    700                u32AntPortBPins = ANT_PIOB_PINS;
   \   0000020C   0xF05F 0x70F0      MOVS     R0,#+31457280
   \   00000210   0x0005             MOVS     R5,R0
    701                
    702                AT91C_BASE_PIOA->PIO_PDR = u32AntPortAPins;
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable21_5  ;; 0x400e0c04
   \   00000216   0x6004             STR      R4,[R0, #+0]
    703                AT91C_BASE_PIOA->PIO_PER = u32AntPortAPins;
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable21_6  ;; 0x400e0c00
   \   0000021C   0x6004             STR      R4,[R0, #+0]
    704                AT91C_BASE_PIOB->PIO_PDR = u32AntPortBPins;
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable21_7  ;; 0x400e0e04
   \   00000222   0x6005             STR      R5,[R0, #+0]
    705                AT91C_BASE_PIOB->PIO_PER = u32AntPortBPins;
   \   00000224   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0x400e0e00
   \   00000228   0x6005             STR      R5,[R0, #+0]
    706          
    707                /* Disable all outputs (set to HiZ input) */
    708                AT91C_BASE_PIOA->PIO_ODR = u32AntPortAPins;
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable21_8  ;; 0x400e0c14
   \   0000022E   0x6004             STR      R4,[R0, #+0]
    709                AT91C_BASE_PIOB->PIO_ODR = u32AntPortBPins;
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable21_9  ;; 0x400e0e14
   \   00000234   0x6005             STR      R5,[R0, #+0]
    710                
    711                Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000236   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000023E   0x6008             STR      R0,[R1, #+0]
    712              }
    713            }
    714          } /* end AntInitialize() */
   \                     ??AntInitialize_1: (+1)
   \   00000240   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    715          
    716          
    717          /*----------------------------------------------------------------------------------------------------------------------
    718          Function AntRunActiveState()
    719          
    720          Description:
    721          Selects and runs one iteration of the current state in the state machine.
    722          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    723          may take 1ms / n to execute.
    724          
    725          Requires:
    726            - State machine function pointer points at current state
    727          
    728          Promises:
    729            - Calls the function to pointed by the state machine function pointer
    730          */

   \                                 In section .text, align 2, keep-with-next
    731          void AntRunActiveState(void)
    732          {
   \                     AntRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    733            Ant_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    734          
    735          } /* end AntRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    736          
    737          
    738          /*-----------------------------------------------------------------------------
    739          Function: AntTxMessage
    740          
    741          Description:
    742          Send a message from the Host to the ANT device.  To do this, we must tell ANT that we have
    743          a message to send by asserting MRDY, wait for ANT to acknowlege with SEN, then read a byte from
    744          ANT to confirm the transmission can proceed.  If ANT happens to wants to send a message at the
    745          same time, the byte it sends will be an Rx byte so the AntTxMessage must suspend and go read the 
    746          incoming message first.  The process would restart after that.
    747          
    748          Once ANT confirms that the Host may transmit, the message to transmit is queued and data is sent byte-by-byte with SRDY used for flow
    749          control after each byte.  Due to the speed of the chip-to-chip communications, even the longest ANT message
    750          should be able to send in less than 500us so it will likely be done on the main program cycle that
    751          immediately follows this call.  
    752          
    753          Requires:
    754            - pu8AntTxMessage_ points to an Ant formatted message where the first data byte
    755              is the length byte (since ANT sends the SYNC byte) and the last byte is
    756              the checksum.
    757          
    758          Promises:
    759            - Returns TRUE if the transmit message is queued successfully; Ant_u32CurrentTxMessageToken holds the message token
    760            - Returns FALSE if the transfer couldn't start or if receive message interrupted
    761              (G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set;  AntRxBufferCurrentChar pointing to the received byte).
    762            - MRDY is deasserted
    763          */

   \                                 In section .text, align 2, keep-with-next
    764          bool AntTxMessage(u8 *pu8AntTxMessage_)
    765          {
   \                     AntTxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB099             SUB      SP,SP,#+100
   \   00000004   0x0004             MOVS     R4,R0
    766            u8 u8Byte;
    767            u32 u32Length;
    768            u32 u32TimeOut = G_u32SystemTime1s;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable21_10
   \   0000000A   0x6807             LDR      R7,[R0, #+0]
    769            u8 au8TxInProgressMsg[] = "AntTx: msg already in progress\n\r";
   \   0000000C   0xA810             ADD      R0,SP,#+64
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable21_11
   \   00000012   0x2221             MOVS     R2,#+33
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
    770            u8 au8TxTimeoutMsg[]    = "AntTx: SEN timeout\n\r";
   \   00000018   0xA80A             ADD      R0,SP,#+40
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable21_12
   \   0000001E   0x2215             MOVS     R2,#+21
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
    771            u8 au8TxNoTokenMsg[]    = "AntTx: No token\n\r";
   \   00000024   0xA805             ADD      R0,SP,#+20
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable21_13
   \   0000002A   0x2212             MOVS     R2,#+18
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy
    772            u8 au8TxNoSyncMsg[]     = "AntTx: No SYNC\n\r";
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable21_14
   \   00000036   0x2211             MOVS     R2,#+17
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
    773          
    774            /* Check G_u32AntFlags first */
    775            if(G_u32AntFlags & (_ANT_FLAGS_TX_IN_PROGRESS | _ANT_FLAGS_RX_IN_PROGRESS) )
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF010 0x6F40      TST      R0,#0xC000000
   \   00000046   0xD004             BEQ.N    ??AntTxMessage_0
    776            {
    777              DebugPrintf(au8TxInProgressMsg);
   \   00000048   0xA810             ADD      R0,SP,#+64
   \   0000004A   0x.... 0x....      BL       DebugPrintf
    778              return FALSE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE08C             B.N      ??AntTxMessage_1
    779            }
    780            
    781            /* Initialize the timeout timer and notify ANT that the Host wishes to send a message */
    782            Ant_u32RxTimer = 0;
   \                     ??AntTxMessage_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000058   0x6008             STR      R0,[R1, #+0]
    783            SYNC_MRDY_ASSERT();                          
   \   0000005A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0x400e0e34
   \   00000062   0x6008             STR      R0,[R1, #+0]
    784          
    785            /* Wait for SEN to be asserted indicating ANT is ready for a message */
    786            while ( !IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_2: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xD40E             BMI.N    ??AntTxMessage_3
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF242 0x7110      MOVW     R1,#+10000
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD207             BCS.N    ??AntTxMessage_3
    787            {
    788              Ant_u32RxTimer++;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE7EB             B.N      ??AntTxMessage_2
    789            }
    790            
    791            /* If we timed out, then clear MRDY and exit */
    792            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntTxMessage_3: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0xF242 0x7111      MOVW     R1,#+10001
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD308             BCC.N    ??AntTxMessage_4
    793            {
    794              SYNC_MRDY_DEASSERT();                          
   \   0000009A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000009E   0x....             LDR.N    R1,??DataTable14_7  ;; 0x400e0e30
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    795              DebugPrintf(au8TxTimeoutMsg);
   \   000000A2   0xA80A             ADD      R0,SP,#+40
   \   000000A4   0x.... 0x....      BL       DebugPrintf
    796              return(FALSE);
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xE05F             B.N      ??AntTxMessage_1
    797            }
    798            
    799            /* Else we have SEN flag; queue to read 1 byte after a short delay before toggling SRDY */
    800            AntSrdyPulse();
   \                     ??AntTxMessage_4: (+1)
   \   000000AC   0x.... 0x....      BL       AntSrdyPulse
    801          
    802            /* Wait for the first byte to come in via the ISR / Rx Callback*/
    803            while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_5: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable14_8
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x0740             LSLS     R0,R0,#+29
   \   000000B6   0xD40B             BMI.N    ??AntTxMessage_6
   \   000000B8   0x....             LDR.N    R0,??DataTable14_13
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF242 0x7110      MOVW     R1,#+10000
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xD205             BCS.N    ??AntTxMessage_6
    804            {
    805              Ant_u32RxTimer++;
   \   000000C4   0x....             LDR.N    R0,??DataTable14_13
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable14_13
   \   000000CC   0x6008             STR      R0,[R1, #+0]
   \   000000CE   0xE7EF             B.N      ??AntTxMessage_5
    806            }
    807          
    808            /* Ok to deassert MRDY now */
    809            SYNC_MRDY_DEASSERT();                     
   \                     ??AntTxMessage_6: (+1)
   \   000000D0   0xF45F 0x0000      MOVS     R0,#+8388608
   \   000000D4   0x....             LDR.N    R1,??DataTable14_7  ;; 0x400e0e30
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    810          
    811            /* If we timed out now, then clear MRDY and exit.  Because CS is still asserted, the task
    812            will attempt to read a message but fail and eventually abort. */
    813            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \   000000D8   0x....             LDR.N    R0,??DataTable14_13
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF242 0x7111      MOVW     R1,#+10001
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xD304             BCC.N    ??AntTxMessage_7
    814            {
    815             DebugPrintf(au8TxTimeoutMsg);
   \   000000E4   0xA80A             ADD      R0,SP,#+40
   \   000000E6   0x.... 0x....      BL       DebugPrintf
    816             return(FALSE);
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xE03E             B.N      ??AntTxMessage_1
    817            }
    818                    
    819            /* When the byte comes in, the SSP module will set the _SSP_RX_COMPLETE flag and also call the 
    820            Rx callback but does not toggle SRDY at this time.  We must look at this byte to determine if ANT 
    821            initiated this particular communication and is telling us that a message is coming in, or if we 
    822            initiated the communication and ANT is allowing us to transmit. */
    823          
    824            /* Read the byte - don't advance the pointer yet */
    825            u8Byte = *Ant_pu8AntRxBufferCurrentChar;                       
   \                     ??AntTxMessage_7: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable14_2
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x0005             MOVS     R5,R0
    826          
    827            /* If the byte is TX_SYNC, then ANT wants to send a message which must be done first */
    828            if (u8Byte == MESG_TX_SYNC)                     
   \   000000F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F8   0x2DA4             CMP      R5,#+164
   \   000000FA   0xD107             BNE.N    ??AntTxMessage_8
    829            {
    830              G_u32AntFlags |= _ANT_FLAGS_TX_INTERRUPTED;
   \   000000FC   0x....             LDR.N    R0,??DataTable14_14
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000104   0x....             LDR.N    R1,??DataTable14_14
   \   00000106   0x6008             STR      R0,[R1, #+0]
    831              return(FALSE);
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE02F             B.N      ??AntTxMessage_1
    832            }
    833          
    834            /* Since the Rx byte is in our Rx buffer, advance both pointers since it's not an incoming message */
    835            AdvanceAntRxBufferCurrentChar();
   \                     ??AntTxMessage_8: (+1)
   \   0000010C   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    836            AdvanceAntRxBufferUnreadMsgPointer();
   \   00000110   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
    837          
    838            /* Clear the status flag and process the byte */
    839            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE; /* !!!!! Odd for this to be here, but maybe it needs to be */
   \   00000114   0x....             LDR.N    R0,??DataTable14_8
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000011C   0x....             LDR.N    R1,??DataTable14_8
   \   0000011E   0x6008             STR      R0,[R1, #+0]
    840            
    841            /* If the byte is RX_SYNC, then proceed to send the message */
    842            if (u8Byte == MESG_RX_SYNC)                     
   \   00000120   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000122   0x2DA5             CMP      R5,#+165
   \   00000124   0xD11E             BNE.N    ??AntTxMessage_9
    843            {
    844              /* Flag that a transmit is in progress */
    845              G_u32AntFlags |= _ANT_FLAGS_TX_IN_PROGRESS;
   \   00000126   0x....             LDR.N    R0,??DataTable14_14
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000012E   0x....             LDR.N    R1,??DataTable14_14
   \   00000130   0x6008             STR      R0,[R1, #+0]
    846              
    847              /* Read the message length and add three for the length, message ID and checksum */
    848              u32Length = (u32)(pu8AntTxMessage_[0] + 3); 
   \   00000132   0x7820             LDRB     R0,[R4, #+0]
   \   00000134   0x1CC0             ADDS     R0,R0,#+3
   \   00000136   0x0006             MOVS     R6,R0
    849              
    850              /* Queue the message to the peripheral and capture the token */ 
    851              Ant_u32CurrentTxMessageToken = SspWriteData(Ant_Ssp, u32Length, pu8AntTxMessage_);
   \   00000138   0x0022             MOVS     R2,R4
   \   0000013A   0x0031             MOVS     R1,R6
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x.... 0x....      BL       SspWriteData
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable21_15
   \   0000014A   0x6008             STR      R0,[R1, #+0]
    852          
    853              /* Return TRUE only if we received a message token indicating the message has been queued */
    854              if(Ant_u32CurrentTxMessageToken != 0)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable21_15
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD001             BEQ.N    ??AntTxMessage_10
    855              {
    856                return(TRUE);
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0xE008             B.N      ??AntTxMessage_1
    857              }
    858              else
    859              {
    860                DebugPrintf(au8TxNoTokenMsg);
   \                     ??AntTxMessage_10: (+1)
   \   0000015A   0xA805             ADD      R0,SP,#+20
   \   0000015C   0x.... 0x....      BL       DebugPrintf
    861                return(FALSE);
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xE003             B.N      ??AntTxMessage_1
    862              }
    863            }
    864          
    865            /* If we get here, not a sync byte, so return */
    866            DebugPrintf(au8TxNoSyncMsg);
   \                     ??AntTxMessage_9: (+1)
   \   00000164   0x4668             MOV      R0,SP
   \   00000166   0x.... 0x....      BL       DebugPrintf
    867            return(FALSE);
   \   0000016A   0x2000             MOVS     R0,#+0
   \                     ??AntTxMessage_1: (+1)
   \   0000016C   0xB019             ADD      SP,SP,#+100
   \   0000016E   0xBDF0             POP      {R4-R7,PC}       ;; return
    868          
    869          } /* end AntTxMessage() */
    870          
    871          
    872          /*------------------------------------------------------------------------------
    873          Function: AntExpectResponse
    874          
    875          Description:
    876          Waits a specified amount of time for a particular message to arrive from ANT in 
    877          response to a message sent to ANT.  
    878          
    879          *** This function violates the 1ms system rule, so should only be used during initialization. ***
    880            
    881          Requires:
    882            - u8ExpectedMessageID_ is the ID of a message to which a response is expected
    883            - u32TimeoutMS_ is the maximum value in ms to wait for the response 
    884            - A message had been sent to ANT to which a response should be coming in
    885            - Ant_u8AntNewRxMessages == 0 as this function is meant to run one-to-one with
    886              transmitted messages.
    887            - SSP task should be in manual mode so it is busy sending the Tx message to which
    888              this function will wait for the ANT response.
    889          
    890          Promises:
    891            - Returns 0 if the message is received and was successful
    892            - Returns 1 if a response is never received or if the response indicates the
    893              message was not successful.
    894          */

   \                                 In section .text, align 2, keep-with-next
    895          u8 AntExpectResponse(u8 u8ExpectedMessageID_, u32 u32TimeoutMS_) 
    896          {
   \                     AntExpectResponse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    897            bool bTimeout = FALSE;
   \   00000008   0x2600             MOVS     R6,#+0
    898            u8 u8ReturnValue = 1;
   \   0000000A   0x2701             MOVS     R7,#+1
    899            u32 u32StartTime = G_u32SystemTime1s;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable21_10
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x9000             STR      R0,[SP, #+0]
    900            u8 au8AntExpectMsgFail[] = "\r\nANT expected msg fail\n\r";
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   0000001A   0x221A             MOVS     R2,#+26
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    901          
    902            /* Wait for current message to send */
    903            u32StartTime = G_u32SystemTime1ms;
   \   00000020   0x....             LDR.N    R0,??DataTable14_5
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x9000             STR      R0,[SP, #+0]
    904            while( IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable14_8
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD509             BPL.N    ??AntExpectResponse_1
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD106             BNE.N    ??AntExpectResponse_1
    905            {
    906              bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000034   0xF44F 0x717A      MOV      R1,#+1000
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x.... 0x....      BL       IsTimeUp
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0xE7F1             B.N      ??AntExpectResponse_0
    907            }
    908          
    909            if( !bTimeout )
   \                     ??AntExpectResponse_1: (+1)
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD11C             BNE.N    ??AntExpectResponse_2
    910            {
    911              /* Done with this message token, so it can be cleared */
    912              G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000048   0x....             LDR.N    R0,??DataTable14_14
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000050   0x....             LDR.N    R1,??DataTable14_14
   \   00000052   0x6008             STR      R0,[R1, #+0]
    913              AntDeQueueOutgoingMessage();
   \   00000054   0x.... 0x....      BL       AntDeQueueOutgoingMessage
    914              Ant_u32CurrentTxMessageToken = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable21_15
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    915              
    916              /* Wait for SEN */
    917              u32StartTime = G_u32SystemTime1ms;
   \   00000060   0x....             LDR.N    R0,??DataTable14_5
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x9000             STR      R0,[SP, #+0]
    918              while( !IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_3: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable14_8
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xD409             BMI.N    ??AntExpectResponse_2
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD106             BNE.N    ??AntExpectResponse_2
    919              {
    920                bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000074   0xF44F 0x717A      MOV      R1,#+1000
   \   00000078   0x4668             MOV      R0,SP
   \   0000007A   0x.... 0x....      BL       IsTimeUp
   \   0000007E   0x0006             MOVS     R6,R0
   \   00000080   0xE7F1             B.N      ??AntExpectResponse_3
    921              }
    922            }
    923            
    924            /* If no timeout then read the incoming message */
    925            if( !bTimeout )
   \                     ??AntExpectResponse_2: (+1)
   \   00000082   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000084   0x2E00             CMP      R6,#+0
   \   00000086   0xD11B             BNE.N    ??AntExpectResponse_4
    926            {
    927              AntRxMessage();
   \   00000088   0x.... 0x....      BL       AntRxMessage
    928          
    929              /* If there is a new message in the receive buffer, then check that it is a response to the expected
    930              message and that the response is no error */
    931              if(Ant_u8AntNewRxMessages)
   \   0000008C   0x....             LDR.N    R0,??DataTable14_4
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD015             BEQ.N    ??AntExpectResponse_4
    932              {
    933                /* Check if the response is an Event, the event is a reply to the expected message, and the reply is good.
    934                Since Ant_pu8AntRxBufferUnreadMsg is pointing to the SYNC byte, add 1 when using BUFFER_INDEX values. */
    935                if( (*(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == MESG_RESPONSE_EVENT_ID) &&    
    936                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_MESG_ID_OFFSET) == u8ExpectedMessageID_) &&
    937                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_CODE_OFFSET) == RESPONSE_NO_ERROR) )
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x7880             LDRB     R0,[R0, #+2]
   \   0000009C   0x2840             CMP      R0,#+64
   \   0000009E   0xD10F             BNE.N    ??AntExpectResponse_4
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x7900             LDRB     R0,[R0, #+4]
   \   000000A8   0x0021             MOVS     R1,R4
   \   000000AA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xD107             BNE.N    ??AntExpectResponse_4
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x7940             LDRB     R0,[R0, #+5]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD101             BNE.N    ??AntExpectResponse_4
    938                {
    939                  u8ReturnValue = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x0007             MOVS     R7,R0
    940                }
    941              }
    942            }
    943            
    944            /* Process any message in the RxBuffer and return the result value */
    945            AntProcessMessage();
   \                     ??AntExpectResponse_4: (+1)
   \   000000C0   0x.... 0x....      BL       AntProcessMessage
    946            
    947            if( bTimeout )
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0x2E00             CMP      R6,#+0
   \   000000C8   0xD002             BEQ.N    ??AntExpectResponse_5
    948            {
    949              DebugPrintf(au8AntExpectMsgFail);
   \   000000CA   0xA801             ADD      R0,SP,#+4
   \   000000CC   0x.... 0x....      BL       DebugPrintf
    950              /* !!!! What clean-up should be done here?  Reset ANT and restart init? */
    951            }
    952          
    953            return(u8ReturnValue);
   \                     ??AntExpectResponse_5: (+1)
   \   000000D0   0x0038             MOVS     R0,R7
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0xB009             ADD      SP,SP,#+36
   \   000000D6   0xBDF0             POP      {R4-R7,PC}       ;; return
    954          
    955          } /* end AntExpectResponse */
    956          
    957          
    958          /*-----------------------------------------------------------------------------
    959          Function: AntTxFlowControlCallback
    960          
    961          Description:
    962          Callback function to toggle flow control during transmission.  The peripheral task
    963          sending the message must invoke this function after each byte.  
    964          
    965          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    966          
    967          Requires:
    968            - 
    969          
    970          Promises:
    971            - SRDY is toggled
    972            - Ant_u32TxByteCounter incremented
    973          */
    974          

   \                                 In section .text, align 4, keep-with-next
    975          void AntTxFlowControlCallback(void)
    976          {
   \                     AntTxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    977            /* Count the byte and toggle flow control lines */
    978            Ant_u32TxByteCounter++; 
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable21_18
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    979            AntSrdyPulse();
   \   00000010   0x.... 0x....      BL       AntSrdyPulse
    980          
    981          } /* end AntTxFlowControlCallback() */
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    982          
    983          
    984          /*-----------------------------------------------------------------------------
    985          Function: AntRxFlowControlCallback
    986          
    987          Description:
    988          Callback function to toggle flow control during reception.  The peripheral task
    989          receiving the message must invoke this function after each byte.  
    990          
    991          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    992          Unfortunately, AntSrdyPulse() takes some time but the duty cycle of this interrupt
    993          is low enough that we can survive (this interrupt priority could be dropped below everything
    994          else to mitigate any issues).
    995          
    996          Requires:
    997            - ISRs are off already since this is totally not re-entrant
    998            - A received byte was just written to the Rx buffer
    999            - _SSP_CS_ASSERTED in correct state: should be set on first byte, but application should 
   1000              clear it for all subsequent bytes so flow control is handled entirely by this function
   1001          
   1002          Promises:
   1003            - Ant_pu8AntRxBufferNextChar is advanced safely so it is ready to receive the next byte
   1004            - Ant_u32RxByteCounter incremented
   1005            - SRDY is toggled if _ANT_FLAGS_RX_IN_PROGRESS is set
   1006          */

   \                                 In section .text, align 4, keep-with-next
   1007          void AntRxFlowControlCallback(void)
   1008          {
   \                     AntRxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1009            /* Count the byte and safely advance the receive buffer pointer; this is called from the
   1010            RX ISR, so it won't be interrupted and break Ant_pu8AntRxBufferNextChar */
   1011            Ant_u32RxByteCounter++;
   \   00000002   0x....             LDR.N    R0,??DataTable14_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable14_12
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1012            Ant_pu8AntRxBufferNextChar++;
   \   0000000C   0x....             LDR.N    R0,??DataTable14_1
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable14_1
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1013            if(Ant_pu8AntRxBufferNextChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   00000016   0x....             LDR.N    R0,??DataTable14_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD103             BNE.N    ??AntRxFlowControlCallback_0
   1014            {
   1015              Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000026   0x....             LDR.N    R1,??DataTable14_1
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1016            }
   1017            
   1018            /* Only toggle SRDY if a reception is flagged in progress */
   1019            if( G_u32AntFlags & _ANT_FLAGS_RX_IN_PROGRESS )
   \                     ??AntRxFlowControlCallback_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable21_19
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0140             LSLS     R0,R0,#+5
   \   00000032   0xD501             BPL.N    ??AntRxFlowControlCallback_1
   1020            {
   1021              AntSrdyPulse();
   \   00000034   0x.... 0x....      BL       AntSrdyPulse
   1022            }
   1023            
   1024          } /* end AntRxFlowControlCallback() */
   \                     ??AntRxFlowControlCallback_1: (+1)
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
   1025          
   1026          
   1027          /*------------------------------------------------------------------------------
   1028          Function: AntCalculateTxChecksum
   1029          
   1030          Description:
   1031          Calculates and returns the checksum for a Host > ANT message.
   1032          
   1033          Requires:
   1034            - pu8Message_ points to the message to transmit
   1035            - the message to transmit is a complete ANT message except the SYNC byte (starts with length byte)
   1036          
   1037          Promises:
   1038            - Finds ANT checksum for the message and returns it
   1039          */

   \                                 In section .text, align 2, keep-with-next
   1040          u8 AntCalculateTxChecksum(u8* pu8Message_)
   1041          {
   \                     AntCalculateTxChecksum: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
   1042            u8 u8Size = *pu8Message_ + 2;
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0x1C82             ADDS     R2,R0,#+2
   1043            u8 u8Checksum = MESG_RX_SYNC;
   \   00000008   0x20A5             MOVS     R0,#+165
   1044            
   1045            for(u8 i = 0; i < u8Size; i++)
   \   0000000A   0x2300             MOVS     R3,#+0
   \                     ??AntCalculateTxChecksum_0: (+1)
   \   0000000C   0x001C             MOVS     R4,R3
   \   0000000E   0x0015             MOVS     R5,R2
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x42AC             CMP      R4,R5
   \   00000016   0xD204             BCS.N    ??AntCalculateTxChecksum_1
   1046            {
   1047              u8Checksum ^= *pu8Message_;
   \   00000018   0x780C             LDRB     R4,[R1, #+0]
   \   0000001A   0x4060             EORS     R0,R4,R0
   1048              pu8Message_++;
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   1049            }
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \   00000020   0xE7F4             B.N      ??AntCalculateTxChecksum_0
   1050            
   1051            return(u8Checksum);
   \                     ??AntCalculateTxChecksum_1: (+1)
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
   1052            
   1053          } /* end AntCalculateTxChecksum() */
   1054          
   1055          
   1056          /*-----------------------------------------------------------------------------/
   1057          Function: AntQueueOutgoingMessage
   1058          
   1059          Description:
   1060          Creates a new ANT message structure and adds it into Ant_psDataOutgoingMsgList.
   1061          If the list is full, the message is not added.
   1062          The Outgoing message list are the messages sent from the Host to the ANT chip.
   1063          
   1064          Requires:
   1065            - pu8Message_ is an ANT-formatted message starting with LENGTH and ending with CHECKSUM
   1066            - Enough space is available on the heap
   1067          
   1068          Promises:
   1069            - A new list item in the outgoing message linked list is created and inserted at the end
   1070              of the list as long as there is enough room.
   1071            - Returns TRUE if the entry is added successfully.
   1072            - Returns FALSE on error.
   1073          */

   \                                 In section .text, align 2, keep-with-next
   1074          bool AntQueueOutgoingMessage(u8 *pu8Message_)
   1075          {
   \                     AntQueueOutgoingMessage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
   1076            u8 u8Length;
   1077            u8 u8MessageCount = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   1078            AntOutgoingMessageListType *psNewDataMessage;
   1079            AntOutgoingMessageListType *psListParser;
   1080            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueOutgoingMessage\n\r";
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable21_20
   \   00000010   0x2228             MOVS     R2,#+40
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy4
   1081            
   1082            /* Add to the number of queued message */
   1083            Ant_DebugQueuedDataMessages++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_21
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable21_21
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1084          
   1085            /* Allocate space for the new message - always do maximum message size */
   1086            psNewDataMessage = malloc( sizeof(AntOutgoingMessageListType) );
   \   00000024   0x201C             MOVS     R0,#+28
   \   00000026   0x.... 0x....      BL       malloc
   \   0000002A   0x0007             MOVS     R7,R0
   1087            if (psNewDataMessage == NULL)
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD104             BNE.N    ??AntQueueOutgoingMessage_0
   1088            {
   1089              DebugPrintf(au8AddMessageFailMsg);
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x.... 0x....      BL       DebugPrintf
   1090              return(FALSE);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE045             B.N      ??AntQueueOutgoingMessage_1
   1091            }
   1092            
   1093            /* Fill in all the fields of the newly allocated message structure */
   1094            u8Length = *pu8Message_ + 3;
   \                     ??AntQueueOutgoingMessage_0: (+1)
   \   0000003A   0x7820             LDRB     R0,[R4, #+0]
   \   0000003C   0x1CC0             ADDS     R0,R0,#+3
   \   0000003E   0x0005             MOVS     R5,R0
   1095            for(u8 i = 0; i < u8Length; i++)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??AntQueueOutgoingMessage_2: (+1)
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0x002A             MOVS     R2,R5
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x4291             CMP      R1,R2
   \   0000004C   0xD207             BCS.N    ??AntQueueOutgoingMessage_3
   1096            {
   1097              psNewDataMessage->au8MessageData[i] = *(pu8Message_ + i);
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x5C21             LDRB     R1,[R4, R0]
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xEB07 0x0200      ADD      R2,R7,R0
   \   00000058   0x7111             STRB     R1,[R2, #+4]
   1098            }
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0xE7F1             B.N      ??AntQueueOutgoingMessage_2
   1099            
   1100            psNewDataMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueOutgoingMessage_3: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable14_5
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x6038             STR      R0,[R7, #+0]
   1101            psNewDataMessage->psNextMessage = NULL;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x61B8             STR      R0,[R7, #+24]
   1102          
   1103            /* Insert into an empty list */
   1104            if(Ant_psDataOutgoingMsgList == NULL)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD10A             BNE.N    ??AntQueueOutgoingMessage_4
   1105            {
   1106              Ant_psDataOutgoingMsgList = psNewDataMessage;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000076   0x6007             STR      R7,[R0, #+0]
   1107              Ant_u32OutgoingMessageCount++;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable21_22
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable21_22
   \   00000084   0x6008             STR      R0,[R1, #+0]
   \   00000086   0xE01D             B.N      ??AntQueueOutgoingMessage_5
   1108            }
   1109          
   1110            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1111            else
   1112            {
   1113              psListParser = Ant_psDataOutgoingMsgList;
   \                     ??AntQueueOutgoingMessage_4: (+1)
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x4680             MOV      R8,R0
   1114              while(psListParser->psNextMessage != NULL)  
   \                     ??AntQueueOutgoingMessage_6: (+1)
   \   00000090   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD003             BEQ.N    ??AntQueueOutgoingMessage_7
   1115              {
   1116                psListParser = psListParser->psNextMessage;
   \   00000098   0xF8D8 0x8018      LDR      R8,[R8, #+24]
   1117                u8MessageCount++;
   \   0000009C   0x1C76             ADDS     R6,R6,#+1
   \   0000009E   0xE7F7             B.N      ??AntQueueOutgoingMessage_6
   1118              }
   1119              
   1120              /* Check for a full list */
   1121              if(u8MessageCount < ANT_OUTGOING_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueOutgoingMessage_7: (+1)
   \   000000A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A2   0x2E20             CMP      R6,#+32
   \   000000A4   0xD209             BCS.N    ??AntQueueOutgoingMessage_8
   1122              {
   1123                /* Insert the new message at the end of the list */
   1124                psListParser->psNextMessage = psNewDataMessage;
   \   000000A6   0xF8C8 0x7018      STR      R7,[R8, #+24]
   1125                Ant_u32OutgoingMessageCount++;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable21_22
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable21_22
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   \   000000B8   0xE004             B.N      ??AntQueueOutgoingMessage_5
   1126              }
   1127              else
   1128              {
   1129                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueOutgoingMessage_8: (+1)
   \   000000BA   0x4668             MOV      R0,SP
   \   000000BC   0x.... 0x....      BL       DebugPrintf
   1130                return(FALSE);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE000             B.N      ??AntQueueOutgoingMessage_1
   1131              }
   1132            }
   1133              
   1134            return(TRUE);
   \                     ??AntQueueOutgoingMessage_5: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \                     ??AntQueueOutgoingMessage_1: (+1)
   \   000000C6   0xB00A             ADD      SP,SP,#+40
   \   000000C8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1135            
   1136          } /* end AntQueueOutgoingMessage() */
   1137          
   1138          
   1139          /*-----------------------------------------------------------------------------/
   1140          Function: AntDeQueueApplicationMessage
   1141          
   1142          Description:
   1143          Releases the first message in G_sAntApplicationMsgList 
   1144          
   1145          Requires:
   1146            - G_sAntApplicationMsgList points to the start of the list which is the entry to remove
   1147          
   1148          Promises:
   1149            - G_sAntApplicationMsgList = G_sAntApplicationMsgList.
   1150          */

   \                                 In section .text, align 2, keep-with-next
   1151          void AntDeQueueApplicationMessage(void)
   1152          {
   \                     AntDeQueueApplicationMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1153            AntApplicationMsgListType *psMessageToKill;
   1154            
   1155            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??AntDeQueueApplicationMessage_0
   1156            {
   1157              psMessageToKill = G_sAntApplicationMsgList;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0004             MOVS     R4,R0
   1158              G_sAntApplicationMsgList = G_sAntApplicationMsgList->psNextMessage;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6980             LDR      R0,[R0, #+24]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1159          
   1160              /* The doomed message is properly disconnected, so kill it */
   1161              free(psMessageToKill);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       free
   1162              Ant_u32ApplicationMessageCount--;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21_23
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable21_23
   \   00000034   0x6008             STR      R0,[R1, #+0]
   1163            }
   1164            
   1165          } /* end AntDeQueueApplicationMessage() */
   \                     ??AntDeQueueApplicationMessage_0: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1166          
   1167          
   1168          /* ANT private Interface-layer Functions */
   1169          
   1170                                              
   1171          /*------------------------------------------------------------------------------
   1172          Function: AntProcessMessage
   1173          
   1174          Description:
   1175          Reads the lastest received Ant message and updates system information accordingly. 
   1176            
   1177          Requires:
   1178            - Ant_u8AntNewRxMessages holds the number of unprocessed messages in the message queue
   1179            - GGpu8AntRxBufferUnreadMsg points to the first byte of an unread verified ANT message
   1180          
   1181          Promises:
   1182            - Returns 1 if Ant_u8AntNewRxMessages == 0 or the message exceeds the maximum allowed length
   1183            - Otherwise, returns 0 and:
   1184              - Ant_u8AntNewRxMessages--
   1185              - GGpu8AntRxBufferUnreadMsg points to the first byte of the next unread verified ANT message
   1186              - System flags are updated
   1187          */

   \                                 In section .text, align 2, keep-with-next
   1188          static u8 AntProcessMessage(void)
   1189          {
   \                     AntProcessMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1190            u8 u8MessageLength;
   1191            u8 u8Channel;
   1192            u8 au8MessageCopy[MESG_MAX_SIZE];
   1193            AntExtendedDataType sExtendedData;
   1194            
   1195             /* Exit immediately if there are no messages in the RxBuffer */
   1196          	if (!Ant_u8AntNewRxMessages)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable21_24
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??AntProcessMessage_0
   1197              return(1);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE1F0             B.N      ??AntProcessMessage_1
   1198            
   1199            Ant_DebugProcessRxMessages++;
   \                     ??AntProcessMessage_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21_25
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable21_25
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1200            
   1201            /* Otherwise decrement counter, and get a copy of the message (necessary since the rx buffer is circular)
   1202            and we want to index the various bytes using the ANT byte definitions. */  
   1203            Ant_u8AntNewRxMessages--;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable21_24
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable21_24
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1204            AdvanceAntRxBufferUnreadMsgPointer();
   \   0000002E   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1205            u8MessageLength = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x0004             MOVS     R4,R0
   1206            
   1207            /* Check to ensure the message size is legit.  !!!!! Clean up pointers if not */
   1208            if(u8MessageLength > MESG_MAX_SIZE)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C12             CMP      R4,#+18
   \   00000040   0xDB01             BLT.N    ??AntProcessMessage_2
   1209            {
   1210              return(1);
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE1D6             B.N      ??AntProcessMessage_1
   1211            }
   1212            
   1213            /* Copy the message so it can be indexed easily */ 
   1214            for(u8 i = 0; i < (u8MessageLength + MESG_FRAME_SIZE - MESG_SYNC_SIZE); i++)
   \                     ??AntProcessMessage_2: (+1)
   \   00000046   0x2600             MOVS     R6,#+0
   \                     ??AntProcessMessage_3: (+1)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x1CE0             ADDS     R0,R4,#+3
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xDA0A             BGE.N    ??AntProcessMessage_4
   1215            {
   1216              au8MessageCopy[i] = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x4669             MOV      R1,SP
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x5588             STRB     R0,[R1, R6]
   1217              AdvanceAntRxBufferUnreadMsgPointer();
   \   00000060   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1218            }
   \   00000064   0x1C76             ADDS     R6,R6,#+1
   \   00000066   0xE7EF             B.N      ??AntProcessMessage_3
   1219            /* Note: Ant_pu8AntRxBufferUnreadMsg is now pointing at the next unread message */
   1220            
   1221            /* Get the channel number since it is needed for many things below (this value
   1222            will NOT be the channel for messages that do not include the channel number,
   1223            but that should be fine as long as the value is used in the correct context. */
   1224            u8Channel = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM];
   \                     ??AntProcessMessage_4: (+1)
   \   00000068   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000006C   0x0005             MOVS     R5,R0
   1225            
   1226            /* Decide what to do based on the Message ID */
   1227            switch( au8MessageCopy[BUFFER_INDEX_MESG_ID] )
   \   0000006E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000072   0x283E             CMP      R0,#+62
   \   00000074   0xF000 0x819C      BEQ.W    ??AntProcessMessage_5
   \   00000078   0x2840             CMP      R0,#+64
   \   0000007A   0xD00C             BEQ.N    ??AntProcessMessage_6
   \   0000007C   0x284E             CMP      R0,#+78
   \   0000007E   0xF000 0x817F      BEQ.W    ??AntProcessMessage_7
   \   00000082   0x284F             CMP      R0,#+79
   \   00000084   0xF000 0x817C      BEQ.W    ??AntProcessMessage_7
   \   00000088   0x2852             CMP      R0,#+82
   \   0000008A   0xF000 0x8190      BEQ.W    ??AntProcessMessage_8
   \   0000008E   0x286F             CMP      R0,#+111
   \   00000090   0xF000 0x81A2      BEQ.W    ??AntProcessMessage_9
   \   00000094   0xE1A7             B.N      ??AntProcessMessage_10
   1228            {
   1229              case MESG_RESPONSE_EVENT_ID:
   1230              { 
   1231                /* Channel Message received: it is a Channel Response or Channel Event */
   1232                if( au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] != MESG_EVENT_ID )
   \                     ??AntProcessMessage_6: (+1)
   \   00000096   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000009A   0x2801             CMP      R0,#+1
   \   0000009C   0xF000 0x80E3      BEQ.W    ??AntProcessMessage_11
   1233                {
   1234                  /* We have a Channel Response: parse it out based on the message ID to which the 
   1235                  response applies and post the result */
   1236                  G_stMessageResponse.u8Channel = u8Channel;
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable21_26
   \   000000A4   0x7005             STRB     R5,[R0, #+0]
   1237                  G_stMessageResponse.u8MessageNumber = au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID];
   \   000000A6   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable21_26
   \   000000AE   0x7048             STRB     R0,[R1, #+1]
   1238                  G_stMessageResponse.u8ResponseCode  = au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE];      
   \   000000B0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable21_26
   \   000000B8   0x7088             STRB     R0,[R1, #+2]
   1239                  
   1240                  switch(au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID])
   \   000000BA   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000BE   0x2841             CMP      R0,#+65
   \   000000C0   0xD06A             BEQ.N    ??AntProcessMessage_12
   \   000000C2   0x2842             CMP      R0,#+66
   \   000000C4   0xD05D             BEQ.N    ??AntProcessMessage_13
   \   000000C6   0x284B             CMP      R0,#+75
   \   000000C8   0xD008             BEQ.N    ??AntProcessMessage_14
   \   000000CA   0x284C             CMP      R0,#+76
   \   000000CC   0xD038             BEQ.N    ??AntProcessMessage_15
   \   000000CE   0x285B             CMP      R0,#+91
   \   000000D0   0xF040 0x8083      BNE.W    ??AntProcessMessage_16
   1241                  {
   1242                    case MESG_OPEN_SCAN_CHANNEL_ID:
   1243                      DebugPrintf("Scanning ");
   \                     ??AntProcessMessage_17: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable21_27
   \   000000D8   0x.... 0x....      BL       DebugPrintf
   1244                      /* Fall through */
   1245                      
   1246                    case MESG_OPEN_CHANNEL_ID:
   1247                      G_au8AntMessageOpen[12] = u8Channel + 0x30;
   \                     ??AntProcessMessage_14: (+1)
   \   000000DC   0xF115 0x0030      ADDS     R0,R5,#+48
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable21_28
   \   000000E4   0x7308             STRB     R0,[R1, #+12]
   1248                      DebugPrintf(G_au8AntMessageOpen);
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable21_28
   \   000000EA   0x.... 0x....      BL       DebugPrintf
   1249                      
   1250                      /* Only change the flags if the command was successful */
   1251                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   000000EE   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD123             BNE.N    ??AntProcessMessage_18
   1252                      {
   1253                        G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN;
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   000000FA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FC   0x2114             MOVS     R1,#+20
   \   000000FE   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000102   0x4408             ADD      R0,R0,R1
   \   00000104   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000106   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000010E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000110   0x2214             MOVS     R2,#+20
   \   00000112   0xFB02 0xF205      MUL      R2,R2,R5
   \   00000116   0x4411             ADD      R1,R1,R2
   \   00000118   0x74C8             STRB     R0,[R1, #+19]
   1254                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000011E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000120   0x2114             MOVS     R1,#+20
   \   00000122   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000126   0x4408             ADD      R0,R0,R1
   \   00000128   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000012A   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000132   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000134   0x2214             MOVS     R2,#+20
   \   00000136   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000013A   0x4411             ADD      R1,R1,R2
   \   0000013C   0x74C8             STRB     R0,[R1, #+19]
   1255                      }
   1256                      break;
   \                     ??AntProcessMessage_18: (+1)
   \   0000013E   0xE07C             B.N      ??AntProcessMessage_19
   1257          
   1258                    case MESG_CLOSE_CHANNEL_ID:
   1259                      G_au8AntMessageClose[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_15: (+1)
   \   00000140   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000144   0x3030             ADDS     R0,R0,#+48
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable21_29
   \   0000014A   0x7308             STRB     R0,[R1, #+12]
   1260                      DebugPrintf(G_au8AntMessageClose);
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable21_29
   \   00000150   0x.... 0x....      BL       DebugPrintf
   1261          
   1262                      /* Only change the flags if the command was successful */
   1263                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   00000154   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD111             BNE.N    ??AntProcessMessage_20
   1264                      {
   1265                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000160   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000162   0x2114             MOVS     R1,#+20
   \   00000164   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000168   0x4408             ADD      R0,R0,R1
   \   0000016A   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000016C   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000174   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000176   0x2214             MOVS     R2,#+20
   \   00000178   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000017C   0x4411             ADD      R1,R1,R2
   \   0000017E   0x74C8             STRB     R0,[R1, #+19]
   1266                      }
   1267                      break;
   \                     ??AntProcessMessage_20: (+1)
   \   00000180   0xE05B             B.N      ??AntProcessMessage_19
   1268          
   1269                    case MESG_ASSIGN_CHANNEL_ID:
   1270                      G_au8AntMessageAssign[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_13: (+1)
   \   00000182   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000186   0x3030             ADDS     R0,R0,#+48
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable21_30
   \   0000018C   0x7308             STRB     R0,[R1, #+12]
   1271                      DebugPrintf(G_au8AntMessageAssign);
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable21_30
   \   00000192   0x.... 0x....      BL       DebugPrintf
   1272                      break;
   \   00000196   0xE050             B.N      ??AntProcessMessage_19
   1273          
   1274                    case MESG_UNASSIGN_CHANNEL_ID:
   1275                      G_au8AntMessageUnassign[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_12: (+1)
   \   00000198   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000019C   0x3030             ADDS     R0,R0,#+48
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable21_31
   \   000001A2   0x7308             STRB     R0,[R1, #+12]
   1276                      DebugPrintf(G_au8AntMessageUnassign);
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable21_31
   \   000001A8   0x.... 0x....      BL       DebugPrintf
   1277          
   1278                      /* Only change the flags if the command was successful */
   1279                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   000001AC   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD111             BNE.N    ??AntProcessMessage_21
   1280                      {
   1281                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_OPEN_PENDING | _ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN); /* !!!! 2016-06-14 */
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   000001B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001BA   0x2114             MOVS     R1,#+20
   \   000001BC   0xFB01 0xF105      MUL      R1,R1,R5
   \   000001C0   0x4408             ADD      R0,R0,R1
   \   000001C2   0x7CC0             LDRB     R0,[R0, #+19]
   \   000001C4   0xF010 0x00F1      ANDS     R0,R0,#0xF1
   \   000001C8   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000001CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CE   0x2214             MOVS     R2,#+20
   \   000001D0   0xFB02 0xF205      MUL      R2,R2,R5
   \   000001D4   0x4411             ADD      R1,R1,R2
   \   000001D6   0x74C8             STRB     R0,[R1, #+19]
   1282                      }
   1283                      break;
   \                     ??AntProcessMessage_21: (+1)
   \   000001D8   0xE02F             B.N      ??AntProcessMessage_19
   1284           
   1285                    default:
   1286                      G_au8AntMessageUnhandled[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_16: (+1)
   \   000001DA   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000001DE   0x3030             ADDS     R0,R0,#+48
   \   000001E0   0x.... 0x....      LDR.W    R1,??DataTable21_32
   \   000001E4   0x7308             STRB     R0,[R1, #+12]
   1287                      G_au8AntMessageUnhandled[24] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] >> 4) & 0x0F );
   \   000001E6   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000001EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001EC   0x0900             LSRS     R0,R0,#+4
   \   000001EE   0x.... 0x....      BL       HexToASCIICharLower
   \   000001F2   0x.... 0x....      LDR.W    R1,??DataTable21_32
   \   000001F6   0x7608             STRB     R0,[R1, #+24]
   1288                      G_au8AntMessageUnhandled[25] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] & 0x0F) );
   \   000001F8   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000001FC   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000200   0x.... 0x....      BL       HexToASCIICharLower
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable21_32
   \   00000208   0x7648             STRB     R0,[R1, #+25]
   1289                      G_au8AntMessageUnhandled[36] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] >> 4) & 0x0F );
   \   0000020A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000020E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000210   0x0900             LSRS     R0,R0,#+4
   \   00000212   0x.... 0x....      BL       HexToASCIICharLower
   \   00000216   0x.... 0x....      LDR.W    R1,??DataTable21_32
   \   0000021A   0xF881 0x0024      STRB     R0,[R1, #+36]
   1290                      G_au8AntMessageUnhandled[37] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] & 0x0F) );
   \   0000021E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000222   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000226   0x.... 0x....      BL       HexToASCIICharLower
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable21_32
   \   0000022E   0xF881 0x0025      STRB     R0,[R1, #+37]
   1291                      DebugPrintf(G_au8AntMessageUnhandled);
   \   00000232   0x.... 0x....      LDR.W    R0,??DataTable21_32
   \   00000236   0x.... 0x....      BL       DebugPrintf
   1292                      break;
   1293                  } /* end switch */
   1294                  
   1295                  /* All messages print an "ok" or "fail" */
   1296                  if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR ) 
   \                     ??AntProcessMessage_19: (+1)
   \   0000023A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000023E   0x2800             CMP      R0,#+0
   \   00000240   0xD104             BNE.N    ??AntProcessMessage_22
   1297                  {
   1298                    DebugPrintf(G_au8AntMessageOk);
   \   00000242   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \   00000246   0x.... 0x....      BL       DebugPrintf
   \   0000024A   0xE098             B.N      ??AntProcessMessage_23
   1299                  }
   1300                  else
   1301                  {
   1302                    DebugPrintf(G_au8AntMessageFail);
   \                     ??AntProcessMessage_22: (+1)
   \   0000024C   0x.... 0x....      LDR.W    R0,??DataTable21_33
   \   00000250   0x.... 0x....      BL       DebugPrintf
   1303                    G_u32AntFlags |= _ANT_FLAGS_CMD_ERROR;
   \   00000254   0x.... 0x....      LDR.W    R0,??DataTable21_19
   \   00000258   0x6800             LDR      R0,[R0, #+0]
   \   0000025A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000025E   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \   00000262   0x6008             STR      R0,[R1, #+0]
   \   00000264   0xE08B             B.N      ??AntProcessMessage_23
   1304                  }
   1305          
   1306                }
   1307                else /* The message is a Channel Event, so the Event Code must be parsed out */
   1308                { 
   1309                  switch ( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] )
   \                     ??AntProcessMessage_11: (+1)
   \   00000266   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000026A   0x2800             CMP      R0,#+0
   \   0000026C   0xD00E             BEQ.N    ??AntProcessMessage_24
   \   0000026E   0x2801             CMP      R0,#+1
   \   00000270   0xD05C             BEQ.N    ??AntProcessMessage_25
   \   00000272   0x2802             CMP      R0,#+2
   \   00000274   0xD00E             BEQ.N    ??AntProcessMessage_26
   \   00000276   0x2803             CMP      R0,#+3
   \   00000278   0xD033             BEQ.N    ??AntProcessMessage_27
   \   0000027A   0x2805             CMP      R0,#+5
   \   0000027C   0xD03E             BEQ.N    ??AntProcessMessage_28
   \   0000027E   0x2806             CMP      R0,#+6
   \   00000280   0xD050             BEQ.N    ??AntProcessMessage_29
   \   00000282   0x2807             CMP      R0,#+7
   \   00000284   0xD056             BEQ.N    ??AntProcessMessage_30
   \   00000286   0x2808             CMP      R0,#+8
   \   00000288   0xD027             BEQ.N    ??AntProcessMessage_31
   \   0000028A   0xE068             B.N      ??AntProcessMessage_32
   1310                  {
   1311                    case RESPONSE_NO_ERROR: 
   1312                    {
   1313                      AntTickExtended(RESPONSE_NO_ERROR);
   \                     ??AntProcessMessage_24: (+1)
   \   0000028C   0x2000             MOVS     R0,#+0
   \   0000028E   0x.... 0x....      BL       AntTickExtended
   1314                      break;
   \   00000292   0xE074             B.N      ??AntProcessMessage_23
   1315                    }
   1316          
   1317                    case EVENT_RX_FAIL: /* slave did not receive a message when expected */
   1318                    {
   1319                      /* The slave missed a message it was expecting: communicate this to the
   1320                      application in case it matters. Could also queue a debug message here. */
   1321                      if(++Ant_u8SlaveMissedMessageLow == 0)
   \                     ??AntProcessMessage_26: (+1)
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable21_34
   \   00000298   0x7800             LDRB     R0,[R0, #+0]
   \   0000029A   0x1C40             ADDS     R0,R0,#+1
   \   0000029C   0x.... 0x....      LDR.W    R1,??DataTable21_34
   \   000002A0   0x7008             STRB     R0,[R1, #+0]
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable21_34
   \   000002A6   0x7800             LDRB     R0,[R0, #+0]
   \   000002A8   0x2800             CMP      R0,#+0
   \   000002AA   0xD112             BNE.N    ??AntProcessMessage_33
   1322                      {
   1323                        if(++Ant_u8SlaveMissedMessageMid == 0)
   \   000002AC   0x.... 0x....      LDR.W    R0,??DataTable21_35
   \   000002B0   0x7800             LDRB     R0,[R0, #+0]
   \   000002B2   0x1C40             ADDS     R0,R0,#+1
   \   000002B4   0x.... 0x....      LDR.W    R1,??DataTable21_35
   \   000002B8   0x7008             STRB     R0,[R1, #+0]
   \   000002BA   0x.... 0x....      LDR.W    R0,??DataTable21_35
   \   000002BE   0x7800             LDRB     R0,[R0, #+0]
   \   000002C0   0x2800             CMP      R0,#+0
   \   000002C2   0xD106             BNE.N    ??AntProcessMessage_33
   1324                        {
   1325                          ++Ant_u8SlaveMissedMessageHigh;
   \   000002C4   0x.... 0x....      LDR.W    R0,??DataTable21_36
   \   000002C8   0x7800             LDRB     R0,[R0, #+0]
   \   000002CA   0x1C40             ADDS     R0,R0,#+1
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable21_36
   \   000002D0   0x7008             STRB     R0,[R1, #+0]
   1326                        }
   1327                      }
   1328                      
   1329                      /* Queue an ANT_TICK message to the application message list. */
   1330                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_33: (+1)
   \   000002D2   0x4668             MOV      R0,SP
   \   000002D4   0x.... 0x....      BL       AntTickExtended
   1331                      break;
   \   000002D8   0xE051             B.N      ??AntProcessMessage_23
   1332                    }
   1333          
   1334                    case EVENT_RX_FAIL_GO_TO_SEARCH: /* slave has lost sync with Master (channel still open) */
   1335                    {
   1336                      /* The slave missed enough consecutive messages so it goes back to search: communicate this to the
   1337                      application in case it matters. Could also queue a debug message here. */
   1338                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_31: (+1)
   \   000002DA   0x4668             MOV      R0,SP
   \   000002DC   0x.... 0x....      BL       AntTickExtended
   1339                      break;
   \   000002E0   0xE04D             B.N      ??AntProcessMessage_23
   1340                    }
   1341          
   1342                    case EVENT_TX: /* ANT has sent a data message */
   1343                    {
   1344                      /* If this is a master device, then EVENT_TX means it's time to queue the 
   1345                      next message */
   1346                      if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_MASTER)
   \                     ??AntProcessMessage_27: (+1)
   \   000002E2   0x....             LDR.N    R0,??DataTable20_3
   \   000002E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002E6   0x2114             MOVS     R1,#+20
   \   000002E8   0xFB01 0xF105      MUL      R1,R1,R5
   \   000002EC   0x4408             ADD      R0,R0,R1
   \   000002EE   0x7840             LDRB     R0,[R0, #+1]
   \   000002F0   0x2810             CMP      R0,#+16
   \   000002F2   0xD102             BNE.N    ??AntProcessMessage_34
   1347                      {
   1348                        AntTickExtended(au8MessageCopy);
   \   000002F4   0x4668             MOV      R0,SP
   \   000002F6   0x.... 0x....      BL       AntTickExtended
   1349                      }
   1350                      break;
   \                     ??AntProcessMessage_34: (+1)
   \   000002FA   0xE040             B.N      ??AntProcessMessage_23
   1351                    } 
   1352          
   1353                    case EVENT_TRANSFER_TX_COMPLETED: /* ACK received from an acknowledged data message */
   1354                    { 
   1355                      G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_GOT_ACK;
   \                     ??AntProcessMessage_28: (+1)
   \   000002FC   0x....             LDR.N    R0,??DataTable20_3
   \   000002FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000300   0x2114             MOVS     R1,#+20
   \   00000302   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000306   0x4408             ADD      R0,R0,R1
   \   00000308   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000030A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000030E   0x....             LDR.N    R1,??DataTable20_3
   \   00000310   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000312   0x2214             MOVS     R2,#+20
   \   00000314   0xFB02 0xF205      MUL      R2,R2,R5
   \   00000318   0x4411             ADD      R1,R1,R2
   \   0000031A   0x74C8             STRB     R0,[R1, #+19]
   1356          
   1357                      AntTickExtended(au8MessageCopy);
   \   0000031C   0x4668             MOV      R0,SP
   \   0000031E   0x.... 0x....      BL       AntTickExtended
   1358                      break;
   \   00000322   0xE02C             B.N      ??AntProcessMessage_23
   1359                    } 
   1360          
   1361                    case EVENT_TRANSFER_TX_FAILED: /* ACK was not received from an acknowledged data message */
   1362                    { 
   1363                      /* Regardless of complete or fail, it is time to send the next message */
   1364                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_29: (+1)
   \   00000324   0x4668             MOV      R0,SP
   \   00000326   0x.... 0x....      BL       AntTickExtended
   1365                      break;
   \   0000032A   0xE028             B.N      ??AntProcessMessage_23
   1366                    } 
   1367          
   1368                    case EVENT_RX_SEARCH_TIMEOUT: /* The ANT channel is going to close due to search timeout */
   1369                    {
   1370                      /* Forward this to application */
   1371                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_25: (+1)
   \   0000032C   0x4668             MOV      R0,SP
   \   0000032E   0x.... 0x....      BL       AntTickExtended
   1372                      break;
   \   00000332   0xE024             B.N      ??AntProcessMessage_23
   1373                    }
   1374           
   1375                    case EVENT_CHANNEL_CLOSED: /* The ANT channel is now closed */
   1376                    {
   1377                      DebugPrintf("Channel closed\n\r");
   \                     ??AntProcessMessage_30: (+1)
   \   00000334   0x.... 0x....      LDR.W    R0,??DataTable21_37
   \   00000338   0x.... 0x....      BL       DebugPrintf
   1378                      G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \   0000033C   0x....             LDR.N    R0,??DataTable20_3
   \   0000033E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000340   0x2114             MOVS     R1,#+20
   \   00000342   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000346   0x4408             ADD      R0,R0,R1
   \   00000348   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000034A   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   0000034E   0x....             LDR.N    R1,??DataTable20_3
   \   00000350   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000352   0x2214             MOVS     R2,#+20
   \   00000354   0xFB02 0xF205      MUL      R2,R2,R5
   \   00000358   0x4411             ADD      R1,R1,R2
   \   0000035A   0x74C8             STRB     R0,[R1, #+19]
   1379                      break;
   \   0000035C   0xE00F             B.N      ??AntProcessMessage_23
   1380                    }
   1381                    
   1382                    /* All other messages are unexpected for now */
   1383                    default:
   1384                      DebugPrintNumber(au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE]);
   \                     ??AntProcessMessage_32: (+1)
   \   0000035E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000362   0x.... 0x....      BL       DebugPrintNumber
   1385                      DebugPrintf(": unexpected channel event\n\r");
   \   00000366   0x.... 0x....      LDR.W    R0,??DataTable21_38
   \   0000036A   0x.... 0x....      BL       DebugPrintf
   1386          
   1387                      G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_EVENT;
   \   0000036E   0x.... 0x....      LDR.W    R0,??DataTable21_19
   \   00000372   0x6800             LDR      R0,[R0, #+0]
   \   00000374   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000378   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \   0000037C   0x6008             STR      R0,[R1, #+0]
   1388                      break;
   1389                  } /* end Ant_pu8AntRxBufferUnreadMsg[EVENT_CODE_INDEX] */
   1390                } /* end else RF event */
   1391                
   1392                break; 
   \                     ??AntProcessMessage_23: (+1)
   \   0000037E   0xE038             B.N      ??AntProcessMessage_35
   1393              } /* end case MESG_RESPONSE_EVENT_ID */
   1394          
   1395              case MESG_ACKNOWLEDGED_DATA_ID: /* An acknowledged data message was received */
   1396              /* Fall through */
   1397                
   1398              case MESG_BROADCAST_DATA_ID: /* A broadcast data message was received */
   1399              { 
   1400                /* Parse the extended data and put the message to the application buffer */
   1401                AntParseExtendedData(au8MessageCopy, &sExtendedData);
   \                     ??AntProcessMessage_7: (+1)
   \   00000380   0xA905             ADD      R1,SP,#+20
   \   00000382   0x4668             MOV      R0,SP
   \   00000384   0x.... 0x....      BL       AntParseExtendedData
   1402                AntQueueExtendedApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA], &sExtendedData);
   \   00000388   0xAA05             ADD      R2,SP,#+20
   \   0000038A   0xF10D 0x0103      ADD      R1,SP,#+3
   \   0000038E   0x2001             MOVS     R0,#+1
   \   00000390   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1403                
   1404                /* If this is a slave device, then a data message received means it's time to send */
   1405                if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_SLAVE)
   \   00000394   0x....             LDR.N    R0,??DataTable20_3
   \   00000396   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000398   0x2114             MOVS     R1,#+20
   \   0000039A   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000039E   0x4408             ADD      R0,R0,R1
   \   000003A0   0x7840             LDRB     R0,[R0, #+1]
   \   000003A2   0x2800             CMP      R0,#+0
   \   000003A4   0xD102             BNE.N    ??AntProcessMessage_36
   1406                {
   1407                  AntTickExtended(RESPONSE_NO_ERROR);
   \   000003A6   0x2000             MOVS     R0,#+0
   \   000003A8   0x.... 0x....      BL       AntTickExtended
   1408                }
   1409                
   1410                break;
   \                     ??AntProcessMessage_36: (+1)
   \   000003AC   0xE021             B.N      ??AntProcessMessage_35
   1411              } /* end case MESG_BROADCAST_DATA_ID */
   1412              
   1413              case MESG_CHANNEL_STATUS_ID: /* Message sent in response to a channel status request */
   1414              { 
   1415                break;
   \                     ??AntProcessMessage_8: (+1)
   \   000003AE   0xE020             B.N      ??AntProcessMessage_35
   1416              } /* end case ChannelStatus_CMD */
   1417              
   1418              case MESG_VERSION_ID:
   1419              {
   1420                for(u8 i = 0; i < MESG_VERSION_SIZE; i++)
   \                     ??AntProcessMessage_5: (+1)
   \   000003B0   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_37: (+1)
   \   000003B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003B4   0x280A             CMP      R0,#+10
   \   000003B6   0xDA08             BGE.N    ??AntProcessMessage_38
   1421                {
   1422                  Ant_u8AntVersion[i] = au8MessageCopy[BUFFER_INDEX_VERSION_BYTE0 + i];
   \   000003B8   0x4669             MOV      R1,SP
   \   000003BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003BC   0x4401             ADD      R1,R1,R0
   \   000003BE   0x7889             LDRB     R1,[R1, #+2]
   \   000003C0   0x....             LDR.N    R2,??DataTable21_4
   \   000003C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003C4   0x5411             STRB     R1,[R2, R0]
   1423                }
   \   000003C6   0x1C40             ADDS     R0,R0,#+1
   \   000003C8   0xE7F3             B.N      ??AntProcessMessage_37
   1424                
   1425                /* If we get a version message, we know that ANT comms is good */
   1426                G_u32ApplicationFlags |= _APPLICATION_FLAGS_ANT;
   \                     ??AntProcessMessage_38: (+1)
   \   000003CA   0x....             LDR.N    R0,??DataTable21_2
   \   000003CC   0x6800             LDR      R0,[R0, #+0]
   \   000003CE   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000003D2   0x....             LDR.N    R1,??DataTable21_2
   \   000003D4   0x6008             STR      R0,[R1, #+0]
   1427                
   1428                break;
   \   000003D6   0xE00C             B.N      ??AntProcessMessage_35
   1429              } /* end case MESG_VERSION_ID */
   1430          
   1431              case MESG_RESTART_ID:
   1432              {
   1433                G_u32AntFlags |= _ANT_FLAGS_RESTART;  
   \                     ??AntProcessMessage_9: (+1)
   \   000003D8   0x....             LDR.N    R0,??DataTable21_19
   \   000003DA   0x6800             LDR      R0,[R0, #+0]
   \   000003DC   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000003E0   0x....             LDR.N    R1,??DataTable21_19
   \   000003E2   0x6008             STR      R0,[R1, #+0]
   1434                break;
   \   000003E4   0xE005             B.N      ??AntProcessMessage_35
   1435              } /* end case MESG_RESTART_ID */
   1436              
   1437              default:
   1438                G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_MSG;
   \                     ??AntProcessMessage_10: (+1)
   \   000003E6   0x....             LDR.N    R0,??DataTable21_19
   \   000003E8   0x6800             LDR      R0,[R0, #+0]
   \   000003EA   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000003EE   0x....             LDR.N    R1,??DataTable21_19
   \   000003F0   0x6008             STR      R0,[R1, #+0]
   1439                break;
   1440            } /* end switch( Ant_pu8AntRxBufferUnreadMsg[MESG_ID_OFFSET] ) */
   1441                     
   1442            return(0);
   \                     ??AntProcessMessage_35: (+1)
   \   000003F2   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_1: (+1)
   \   000003F4   0xB008             ADD      SP,SP,#+32
   \   000003F6   0xBD70             POP      {R4-R6,PC}       ;; return
   1443            
   1444          } /* end AntProcessMessage() */
   1445          
   1446          
   1447          /*-----------------------------------------------------------------------------/
   1448          Function: AntTickExtended
   1449          
   1450          Description:
   1451          Queues an ANT_TICK message to the application message queue.
   1452          
   1453          Requires:
   1454            - u8Code_ is payload byte indicating system info that may be relavent to the application
   1455          
   1456          Promises:
   1457            - A MESSAGE_ANT_TICK is queued to G_sAntApplicationMsgList
   1458          */

   \                                 In section .text, align 2, keep-with-next
   1459          static void AntTickExtended(u8* pu8AntMessage_)
   1460          {
   \                     AntTickExtended: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1461            u8 au8Message[ANT_APPLICATION_MESSAGE_BYTES];
   1462            AntExtendedDataType sExtData;
   1463          
   1464            /* Update data to communicate the ANT_TICK to the application */
   1465            au8Message[ANT_TICK_MSG_ID_INDEX]               = MESSAGE_ANT_TICK;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1466            au8Message[ANT_TICK_MSG_CHANNEL_INDEX]          = *(pu8AntMessage_ + BUFFER_INDEX_CHANNEL_NUM);
   \   0000000A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1467            au8Message[ANT_TICK_MSG_RESPONSE_TYPE_INDEX]    = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_MESG_ID);
   \   00000010   0x78E0             LDRB     R0,[R4, #+3]
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1468            au8Message[ANT_TICK_MSG_EVENT_CODE_INDEX]       = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_CODE);
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1469            au8Message[ANT_TICK_MSG_SENTINEL3_INDEX]        = MESSAGE_ANT_TICK;
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1470            au8Message[ANT_TICK_MSG_MISSED_HIGH_BYTE_INDEX] = Ant_u8SlaveMissedMessageHigh;
   \   00000022   0x....             LDR.N    R0,??DataTable21_36
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1471            au8Message[ANT_TICK_MSG_MISSED_MID_BYTE_INDEX]  = Ant_u8SlaveMissedMessageMid;
   \   0000002A   0x....             LDR.N    R0,??DataTable21_35
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1472            au8Message[ANT_TICK_MSG_MISSED_LOW_BYTE_INDEX]  = Ant_u8SlaveMissedMessageLow;
   \   00000032   0x....             LDR.N    R0,??DataTable21_34
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1473          
   1474            /* Extended data is not valid for an ANT_TICK message */
   1475            sExtData.u8Channel    = au8Message[ANT_TICK_MSG_CHANNEL_INDEX];
   \   0000003A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1476            sExtData.u16DeviceID  = 0xFF;
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1477            sExtData.u8DeviceType = 0xFF;
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1478            sExtData.u8TransType  = 0xFF;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xF88D 0x000D      STRB     R0,[SP, #+13]
   1479            sExtData.s8RSSI       = 0xFF;
   \   00000054   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000058   0xF88D 0x000E      STRB     R0,[SP, #+14]
   1480            sExtData.u8Flags      = 0xFF;
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1481            
   1482            /* Data is ready so queue it in to the application buffer */
   1483            AntQueueExtendedApplicationMessage(ANT_TICK, 
   1484                                               &au8Message[ANT_TICK_MSG_ID_INDEX],
   1485                                               &sExtData);
   \   00000062   0xAA02             ADD      R2,SP,#+8
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1486          
   1487          } /* end AntTickExtended() */
   \   0000006C   0xBD1F             POP      {R0-R4,PC}       ;; return
   1488          
   1489          
   1490          /*-----------------------------------------------------------------------------/
   1491          Function: AntQueueExtendedApplicationMessage
   1492          
   1493          Description:
   1494          Creates a new ANT data message structure and adds it to G_sAntApplicationMsgList.
   1495          The Application list used to communicate message information between the ANT driver and
   1496          the ANT_API simplified interface task.
   1497          
   1498          Requires:
   1499            - eMessageType_ specifies the type of message
   1500            - pu8DataSource_ is a pointer to the first element of an array of 8 data bytes
   1501            - psTargetList_ is a pointer to the list pointer that is being updated
   1502            - Enough space is available on the heap
   1503          
   1504          Promises:
   1505            - A new list item in the target linked list is created and inserted at the end
   1506              of the list.
   1507            - Returns TRUE if the entry is added successfully.
   1508            - Returns FALSE if the malloc fails or the list is full.
   1509          */

   \                                 In section .text, align 2, keep-with-next
   1510          static bool AntQueueExtendedApplicationMessage(AntApplicationMessageType eMessageType_, 
   1511                                                         u8* pu8DataSource_, 
   1512                                                         AntExtendedDataType* psExtData_)
   1513          {
   \                     AntQueueExtendedApplicationMessage: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1514            AntApplicationMsgListType *psNewMessage;
   1515            AntApplicationMsgListType *psListParser;
   1516            u8 u8MessageCount = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   1517            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueApplicationMessage\n\r";
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x....             LDR.N    R1,??DataTable21_39
   \   00000014   0x222B             MOVS     R2,#+43
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
   1518            
   1519            /* Allocate space for the new message - always do maximum message size */
   1520            psNewMessage = malloc( sizeof(AntApplicationMsgListType) );
   \   0000001A   0x201C             MOVS     R0,#+28
   \   0000001C   0x.... 0x....      BL       malloc
   \   00000020   0x0007             MOVS     R7,R0
   1521            if (psNewMessage == NULL)
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD104             BNE.N    ??AntQueueExtendedApplicationMessage_0
   1522            {
   1523              DebugPrintf(au8AddMessageFailMsg);
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x.... 0x....      BL       DebugPrintf
   1524              return(FALSE);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE048             B.N      ??AntQueueExtendedApplicationMessage_1
   1525            }
   1526            
   1527            /* Fill in all the fields of the newly allocated message structure */
   1528            for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \                     ??AntQueueExtendedApplicationMessage_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??AntQueueExtendedApplicationMessage_2: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xDA07             BGE.N    ??AntQueueExtendedApplicationMessage_3
   1529            {
   1530              psNewMessage->au8MessageData[i] = *(pu8DataSource_ + i);
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x5C29             LDRB     R1,[R5, R0]
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xEB07 0x0200      ADD      R2,R7,R0
   \   00000042   0x7191             STRB     R1,[R2, #+6]
   1531            }
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0xE7F4             B.N      ??AntQueueExtendedApplicationMessage_2
   1532            
   1533            /* Copy basic items */
   1534            psNewMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueExtendedApplicationMessage_3: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable21_40
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x6038             STR      R0,[R7, #+0]
   1535            psNewMessage->eMessageType  = eMessageType_;
   \   0000004E   0x713C             STRB     R4,[R7, #+4]
   1536            
   1537            /* Copy all extended data fields */
   1538            psNewMessage->sExtendedData.u8Channel    = psExtData_->u8Channel;
   \   00000050   0x7830             LDRB     R0,[R6, #+0]
   \   00000052   0x73B8             STRB     R0,[R7, #+14]
   1539            psNewMessage->sExtendedData.u16DeviceID  = psExtData_->u16DeviceID;
   \   00000054   0x8870             LDRH     R0,[R6, #+2]
   \   00000056   0x8238             STRH     R0,[R7, #+16]
   1540            psNewMessage->sExtendedData.u8DeviceType = psExtData_->u8DeviceType;
   \   00000058   0x7930             LDRB     R0,[R6, #+4]
   \   0000005A   0x74B8             STRB     R0,[R7, #+18]
   1541            psNewMessage->sExtendedData.u8TransType  = psExtData_->u8TransType;
   \   0000005C   0x7970             LDRB     R0,[R6, #+5]
   \   0000005E   0x74F8             STRB     R0,[R7, #+19]
   1542            psNewMessage->sExtendedData.u8Flags      = psExtData_->u8Flags;
   \   00000060   0x7870             LDRB     R0,[R6, #+1]
   \   00000062   0x73F8             STRB     R0,[R7, #+15]
   1543            psNewMessage->sExtendedData.s8RSSI       = psExtData_->s8RSSI;
   \   00000064   0x79B0             LDRB     R0,[R6, #+6]
   \   00000066   0x7538             STRB     R0,[R7, #+20]
   1544              
   1545            psNewMessage->psNextMessage = NULL;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x61B8             STR      R0,[R7, #+24]
   1546          
   1547            /* Insert into an empty list */
   1548            if(G_sAntApplicationMsgList == NULL)
   \   0000006C   0x....             LDR.N    R0,??DataTable20_2
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD107             BNE.N    ??AntQueueExtendedApplicationMessage_4
   1549            {
   1550              G_sAntApplicationMsgList = psNewMessage;
   \   00000074   0x....             LDR.N    R0,??DataTable20_2
   \   00000076   0x6007             STR      R7,[R0, #+0]
   1551              Ant_u32ApplicationMessageCount++;
   \   00000078   0x....             LDR.N    R0,??DataTable21_23
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0x....             LDR.N    R1,??DataTable21_23
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0xE01D             B.N      ??AntQueueExtendedApplicationMessage_5
   1552            }
   1553          
   1554            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1555            else
   1556            {
   1557              psListParser = G_sAntApplicationMsgList;
   \                     ??AntQueueExtendedApplicationMessage_4: (+1)
   \   00000084   0x....             LDR.N    R0,??DataTable20_2
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x4680             MOV      R8,R0
   1558              while(psListParser->psNextMessage != NULL) 
   \                     ??AntQueueExtendedApplicationMessage_6: (+1)
   \   0000008A   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD004             BEQ.N    ??AntQueueExtendedApplicationMessage_7
   1559              {
   1560                psListParser = psListParser->psNextMessage;
   \   00000092   0xF8D8 0x8018      LDR      R8,[R8, #+24]
   1561                u8MessageCount++;
   \   00000096   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000009A   0xE7F6             B.N      ??AntQueueExtendedApplicationMessage_6
   1562              }
   1563              
   1564              /* Check for full list */
   1565              if(u8MessageCount < ANT_APPLICATION_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueExtendedApplicationMessage_7: (+1)
   \   0000009C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A0   0xF1B9 0x0F20      CMP      R9,#+32
   \   000000A4   0xD207             BCS.N    ??AntQueueExtendedApplicationMessage_8
   1566              {
   1567                /* Insert the new message at the end of the list */
   1568                psListParser->psNextMessage = psNewMessage;
   \   000000A6   0xF8C8 0x7018      STR      R7,[R8, #+24]
   1569                Ant_u32ApplicationMessageCount++;
   \   000000AA   0x....             LDR.N    R0,??DataTable21_23
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0x....             LDR.N    R1,??DataTable21_23
   \   000000B2   0x6008             STR      R0,[R1, #+0]
   \   000000B4   0xE004             B.N      ??AntQueueExtendedApplicationMessage_5
   1570              }
   1571              /* Handle a full list */
   1572              else
   1573              {
   1574                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueExtendedApplicationMessage_8: (+1)
   \   000000B6   0x4668             MOV      R0,SP
   \   000000B8   0x.... 0x....      BL       DebugPrintf
   1575                return(FALSE);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE000             B.N      ??AntQueueExtendedApplicationMessage_1
   1576              }
   1577            }
   1578              
   1579            return(TRUE);
   \                     ??AntQueueExtendedApplicationMessage_5: (+1)
   \   000000C0   0x2001             MOVS     R0,#+1
   \                     ??AntQueueExtendedApplicationMessage_1: (+1)
   \   000000C2   0xB00B             ADD      SP,SP,#+44
   \   000000C4   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1580              
   1581          } /* end AntQueueExtendedApplicationMessage() */
   1582          
   1583          
   1584          /*-----------------------------------------------------------------------------/
   1585          Function: AntDeQueueOutgoingMessage
   1586          
   1587          Description:
   1588          Removes the first entry of Ant_psDataOutgoingMsgList.
   1589          
   1590          Requires:
   1591            - 
   1592          
   1593          Promises:
   1594            - Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage 
   1595            and the memory is freed
   1596          */

   \                                 In section .text, align 2, keep-with-next
   1597          static void AntDeQueueOutgoingMessage(void)
   1598          {
   \                     AntDeQueueOutgoingMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1599            AntOutgoingMessageListType *psMessageToKill;
   1600            
   1601            if(Ant_psDataOutgoingMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable21
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??AntDeQueueOutgoingMessage_0
   1602            {
   1603              psMessageToKill = Ant_psDataOutgoingMsgList;
   \   0000000A   0x....             LDR.N    R0,??DataTable21
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
   1604              Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage;
   \   00000010   0x....             LDR.N    R0,??DataTable21
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x....             LDR.N    R1,??DataTable21
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1605            
   1606              /* The doomed message is properly disconnected, so kill it */
   1607              free(psMessageToKill);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       free
   1608            }
   1609            
   1610          } /* end AntDeQueueOutgoingMessage() */
   \                     ??AntDeQueueOutgoingMessage_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   1611          
   1612          
   1613          /***********************************************************************************************************************
   1614          ##### ANT State Machine Definition                                             
   1615          ***********************************************************************************************************************/
   1616          
   1617          /*------------------------------------------------------------------------------
   1618          Idle state that will process new messages if any are present, monitors ANT
   1619          for incoming messages, and sends broadcast messages that are waiting to be sent.
   1620          Incoming messages from ANT always get priority.  
   1621          */

   \                                 In section .text, align 2, keep-with-next
   1622          void AntSM_Idle(void)
   1623          {
   \                     AntSM_Idle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1624            u32 u32MsgBitMask = 0x01;
   \   00000002   0x2401             MOVS     R4,#+1
   1625            u8 u8MsgIndex = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1626            static u8 au8AntFlagAlert[] = "ANT flags:\n\r"; 
   1627            
   1628            /* Error messages: must match order of G_u32AntFlags Error / event flags */
   1629            static u8 au8AntFlagMessages[][20] = 
   1630            {/* "012345678901234567\n\r" */
   1631                "Length mismatch\n\r",
   1632                "Command error\n\r",
   1633                "Unexpected event\n\r",
   1634                "Unexpected message\n\r"
   1635            };
   1636            
   1637            /* Check flags */
   1638            if(G_u32AntFlags & ANT_ERROR_FLAGS_MASK)
   \   00000006   0x....             LDR.N    R0,??DataTable21_19
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0400             LSLS     R0,R0,#+16
   \   0000000C   0xD01C             BEQ.N    ??AntSM_Idle_0
   1639            {
   1640              /* At least one flag is set, so print header and parse out */
   1641              DebugPrintf(au8AntFlagAlert);
   \   0000000E   0x....             LDR.N    R0,??DataTable21_41
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1642              for(u8 i = 0; i < ANT_ERROR_FLAGS_COUNT; i++)
   \   00000014   0x2600             MOVS     R6,#+0
   \                     ??AntSM_Idle_1: (+1)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E04             CMP      R6,#+4
   \   0000001A   0xDA0F             BGE.N    ??AntSM_Idle_2
   1643              {
   1644                /* Check if current flag is set */
   1645                if(G_u32AntFlags & u32MsgBitMask)
   \   0000001C   0x....             LDR.N    R0,??DataTable21_19
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4220             TST      R0,R4
   \   00000022   0xD007             BEQ.N    ??AntSM_Idle_3
   1646                {
   1647                  /* Print the error message */
   1648                  DebugPrintf(au8AntFlagMessages[u8MsgIndex]);
   \   00000024   0x....             LDR.N    R0,??DataTable21_42
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2114             MOVS     R1,#+20
   \   0000002A   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000002E   0x4408             ADD      R0,R0,R1
   \   00000030   0x.... 0x....      BL       DebugPrintf
   1649                }
   1650                u32MsgBitMask <<= 1;
   \                     ??AntSM_Idle_3: (+1)
   \   00000034   0x0064             LSLS     R4,R4,#+1
   1651                u8MsgIndex++;
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   1652              }
   \   00000038   0x1C76             ADDS     R6,R6,#+1
   \   0000003A   0xE7EC             B.N      ??AntSM_Idle_1
   1653              
   1654              /* Clear all the error flags now that they have been reported */
   1655              G_u32AntFlags &= ~ANT_ERROR_FLAGS_MASK;
   \                     ??AntSM_Idle_2: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable21_19
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0C00             LSRS     R0,R0,#+16
   \   00000042   0x0400             LSLS     R0,R0,#+16
   \   00000044   0x....             LDR.N    R1,??DataTable21_19
   \   00000046   0x6008             STR      R0,[R1, #+0]
   1656            }
   1657            
   1658            /* Process messages received from ANT */
   1659            AntProcessMessage();
   \                     ??AntSM_Idle_0: (+1)
   \   00000048   0x.... 0x....      BL       AntProcessMessage
   1660          
   1661            /* Handle messages coming in from ANT */
   1662            if( IS_SEN_ASSERTED() )
   \   0000004C   0x....             LDR.N    R0,??DataTable21_43
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x07C0             LSLS     R0,R0,#+31
   \   00000052   0xD504             BPL.N    ??AntSM_Idle_4
   1663            {
   1664              Ant_pfnStateMachine = AntSM_ReceiveMessage;
   \   00000054   0x.... 0x....      ADR.W    R0,AntSM_ReceiveMessage
   \   00000058   0x....             LDR.N    R1,??DataTable20_1
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   \   0000005C   0xE016             B.N      ??AntSM_Idle_5
   1665            }
   1666            
   1667            /* Send a message if the system is ready and there is one to send */ 
   1668            else if( (Ant_u32CurrentTxMessageToken == 0 ) && 
   1669                     (Ant_psDataOutgoingMsgList != NULL) )
   \                     ??AntSM_Idle_4: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable21_15
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD112             BNE.N    ??AntSM_Idle_5
   \   00000066   0x....             LDR.N    R0,??DataTable21
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD00E             BEQ.N    ??AntSM_Idle_5
   1670            {
   1671              /* Give the message to AntTx which will set Ant_u32CurrentTxMessageToken */
   1672              if(AntTxMessage(Ant_psDataOutgoingMsgList->au8MessageData))
   \   0000006E   0x....             LDR.N    R0,??DataTable21
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x1D00             ADDS     R0,R0,#+4
   \   00000074   0x.... 0x....      BL       AntTxMessage
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD007             BEQ.N    ??AntSM_Idle_5
   1673              {
   1674                Ant_u32TxTimer = G_u32SystemTime1ms;
   \   0000007C   0x....             LDR.N    R0,??DataTable21_40
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x....             LDR.N    R1,??DataTable21_44
   \   00000082   0x6008             STR      R0,[R1, #+0]
   1675                Ant_pfnStateMachine = AntSM_TransmitMessage;
   \   00000084   0x.... 0x....      ADR.W    R0,AntSM_TransmitMessage
   \   00000088   0x....             LDR.N    R1,??DataTable20_1
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   1676              }
   1677              else
   1678              {
   1679                /* Transmit attempt failed.  !!!! Do something? */
   1680              }
   1681            }
   1682            
   1683          } /* end AntSM_Idle() */
   \                     ??AntSM_Idle_5: (+1)
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     `AntSM_Idle::au8AntFlagAlert`:
   \   00000000   0x41 0x4E          DC8 "ANT flags:\012\015"
   \              0x54 0x20    
   \              0x66 0x6C    
   \              0x61 0x67    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     `AntSM_Idle::au8AntFlagMessages`:
   \   00000000   0x4C 0x65          DC8 "Length mismatch\012\015"
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x20 0x6D    
   \              0x69 0x73    
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x43 0x6F          DC8 "Command error\012\015"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x0A    
   \              0x0D 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000028   0x55 0x6E          DC8 "Unexpected event\012\015"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000003B   0x00               DC8 0
   \   0000003C   0x55 0x6E          DC8 55H, 6EH, 65H, 78H, 70H, 65H, 63H, 74H
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \   00000044   0x65 0x64          DC8 65H, 64H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \   0000004C   0x67 0x65          DC8 67H, 65H, 0AH, 0DH
   \              0x0A 0x0D    
   1684          
   1685          
   1686          /*------------------------------------------------------------------------------
   1687          Completely receive an ANT message.  Reception is very fast and should complete
   1688          in less than 600us for a 15-byte message.  AntRxMessage could just be called from Idle,
   1689          but giving it its own state minimizes the total time and allows for easier future
   1690          updates should they be required.
   1691          */

   \                                 In section .text, align 4, keep-with-next
   1692          void AntSM_ReceiveMessage(void)
   1693          {
   \                     AntSM_ReceiveMessage: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1694            Ant_DebugRxMessageCounter++;
   \   00000002   0x....             LDR.N    R0,??DataTable21_45
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable21_45
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1695            AntRxMessage();
   \   0000000C   0x.... 0x....      BL       AntRxMessage
   1696            
   1697            Ant_pfnStateMachine = AntSM_Idle;
   \   00000010   0x....             LDR.N    R0,??DataTable20_7
   \   00000012   0x....             LDR.N    R1,??DataTable20_1
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1698          
   1699          } /* end AntSM_ReceiveMessage() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1700          
   1701          
   1702          /*------------------------------------------------------------------------------
   1703          Wait for an ANT message to be transmitted.  This state only occurs once the 
   1704          handshaking transaction has been completed and transmit to ANT is verified 
   1705          and underway.
   1706          */

   \                                 In section .text, align 4, keep-with-next
   1707          void AntSM_TransmitMessage(void)
   1708          {
   \                     AntSM_TransmitMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1709            static u8 au8TxTimeoutMsg[] = "\n\rTransmit message timeout\n\r";
   1710            MessageStateType eCurrentMsgStatus;
   1711            
   1712            eCurrentMsgStatus = QueryMessageStatus(Ant_u32CurrentTxMessageToken);
   \   00000002   0x....             LDR.N    R0,??DataTable21_15
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       QueryMessageStatus
   \   0000000A   0x0004             MOVS     R4,R0
   1713            switch(eCurrentMsgStatus)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x1F00             SUBS     R0,R0,#+4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD82E             BHI.N    ??AntSM_TransmitMessage_0
   1714            {
   1715              case TIMEOUT:
   1716                /* Fall through */
   1717                
   1718              case COMPLETE:
   1719                /* Kill the message and update flags */
   1720                AntDeQueueOutgoingMessage();
   \                     ??AntSM_TransmitMessage_1: (+1)
   \   00000016   0x.... 0x....      BL       AntDeQueueOutgoingMessage
   1721                Ant_u32CurrentTxMessageToken = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable21_15
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1722                G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000020   0x....             LDR.N    R0,??DataTable21_19
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000028   0x....             LDR.N    R1,??DataTable21_19
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1723          
   1724                /* Wait for SEN to deassert so we know ANT is totally ready for the next
   1725                transaction.  This takes about 170us, so block in this state until that's over */
   1726                while ( IS_SEN_ASSERTED() && (Ant_u32TxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntSM_TransmitMessage_2: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable21_43
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x07C0             LSLS     R0,R0,#+31
   \   00000032   0xD50B             BPL.N    ??AntSM_TransmitMessage_3
   \   00000034   0x....             LDR.N    R0,??DataTable21_44
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF242 0x7110      MOVW     R1,#+10000
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD205             BCS.N    ??AntSM_TransmitMessage_3
   1727                {
   1728                  Ant_u32TxTimer++;
   \   00000040   0x....             LDR.N    R0,??DataTable21_44
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x....             LDR.N    R1,??DataTable21_44
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE7EF             B.N      ??AntSM_TransmitMessage_2
   1729                }
   1730          
   1731                /* If we timed out, then ANT is stuck so print error and unstick ANT */
   1732                if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntSM_TransmitMessage_3: (+1)
   \   0000004C   0x....             LDR.N    R0,??DataTable21_46
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF242 0x7111      MOVW     R1,#+10001
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD309             BCC.N    ??AntSM_TransmitMessage_4
   1733                {
   1734                  DebugPrintf(au8TxTimeoutMsg);
   \   00000058   0x....             LDR.N    R0,??DataTable21_47
   \   0000005A   0x.... 0x....      BL       DebugPrintf
   1735                  while( IS_SEN_ASSERTED() )
   \                     ??AntSM_TransmitMessage_5: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable21_43
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD502             BPL.N    ??AntSM_TransmitMessage_4
   1736                  {
   1737                    AntSrdyPulse();
   \   00000066   0x.... 0x....      BL       AntSrdyPulse
   \   0000006A   0xE7F8             B.N      ??AntSM_TransmitMessage_5
   1738                  }
   1739                }
   1740                
   1741                Ant_pfnStateMachine = AntSM_Idle;
   \                     ??AntSM_TransmitMessage_4: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable21_48
   \   0000006E   0x....             LDR.N    R1,??DataTable21_49
   \   00000070   0x6008             STR      R0,[R1, #+0]
   1742                break;
   \   00000072   0xE7FF             B.N      ??AntSM_TransmitMessage_6
   1743                
   1744              default:
   1745                /* Do nothing for now */
   1746                break;
   1747                
   1748            } /* end switch */
   1749            
   1750          } /* end AntSM_TransmitMessage() */
   \                     ??AntSM_TransmitMessage_0: (+1)
   \                     ??AntSM_TransmitMessage_6: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .data, align 4
   \                     `AntSM_TransmitMessage::au8TxTimeoutMsg`:
   \   00000000   0x0A 0x0D          DC8 "\012\015Transmit message timeout\012\015"
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1751          
   1752          
   1753          /*------------------------------------------------------------------------------
   1754          Do-nothing state if ANT is dead (requires restart to retry initialization)
   1755          */

   \                                 In section .text, align 2, keep-with-next
   1756          void AntSM_NoResponse(void)
   1757          {
   1758            
   1759          } /* end AntSM_NoResponse() */
   \                     AntSM_NoResponse: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferCurrentChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x400E0E34         DC32     0x400e0e34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x400E0E30         DC32     0x400e0e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     G_au8ANTGetVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     Ant_u32RxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x........         DC32     Ant_DebugTotalRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x........         DC32     Ant_u32RxTimeoutCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x........         DC32     Ant_u32UnexpectedByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer+0x100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     G_au8AntMessageNoAnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x400E0E10         DC32     0x400e0e10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     AntSM_NoResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     G_au8AntMessageInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     G_asAntChannelConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     Ant_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x400E0E00         DC32     0x400e0e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     G_au8AntMessageInitFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     Ant_psDataOutgoingMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     Ant_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x........         DC32     Ant_u8AntVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x400E0C04         DC32     0x400e0c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x400E0C00         DC32     0x400e0c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x400E0E04         DC32     0x400e0e04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x400E0C14         DC32     0x400e0c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x400E0E14         DC32     0x400e0e14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x........         DC32     G_u32SystemTime1s

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \   00000000   0x........         DC32     Ant_u32CurrentTxMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_16:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_17:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_18:
   \   00000000   0x........         DC32     Ant_u32TxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_19:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_20:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_21:
   \   00000000   0x........         DC32     Ant_DebugQueuedDataMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_22:
   \   00000000   0x........         DC32     Ant_u32OutgoingMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_23:
   \   00000000   0x........         DC32     Ant_u32ApplicationMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_24:
   \   00000000   0x........         DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_25:
   \   00000000   0x........         DC32     Ant_DebugProcessRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_26:
   \   00000000   0x........         DC32     G_stMessageResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_27:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_28:
   \   00000000   0x........         DC32     G_au8AntMessageOpen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_29:
   \   00000000   0x........         DC32     G_au8AntMessageClose

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_30:
   \   00000000   0x........         DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_31:
   \   00000000   0x........         DC32     G_au8AntMessageUnassign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_32:
   \   00000000   0x........         DC32     G_au8AntMessageUnhandled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_33:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_34:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageLow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_35:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageMid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_36:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageHigh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_37:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_38:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_39:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_40:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_41:
   \   00000000   0x........         DC32     `AntSM_Idle::au8AntFlagAlert`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_42:
   \   00000000   0x........         DC32     `AntSM_Idle::au8AntFlagMessages`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_43:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_44:
   \   00000000   0x........         DC32     Ant_u32TxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_45:
   \   00000000   0x........         DC32     Ant_DebugRxMessageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_46:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_47:
   \   00000000   0x........         DC32     `AntSM_TransmitMessage::au8TxTimeoutMsg`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_48:
   \   00000000   0x........         DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_49:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x6E          DC8 "AntRx: timeout\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x6E          DC8 "AntRx: message failed\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x0A 0x0D          DC8 "\012\015Unexpected ANT message size\012\012\015"
   \              0x55 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x41 0x4E          DC8 "ANT version: "
   \              0x54 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x41 0x6E          DC8 "AntTx: msg already in progress\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x6F 0x67    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x41 0x6E          DC8 "AntTx: SEN timeout\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x53    
   \              0x45 0x4E    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x6E          DC8 "AntTx: No token\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x74 0x6F    
   \              0x6B 0x65    
   \              0x6E 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x41 0x6E          DC8 "AntTx: No SYNC\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x0D 0x0A          DC8 "\015\012ANT expected msg fail\012\015"
   \              0x41 0x4E    
   \              0x54 0x20    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueOutgoingMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x4F 0x75    
   \              0x74 0x67    
   \              0x6F 0x69    
   \              0x6E 0x67    
   \              0x4D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x53 0x63          DC8 "Scanning "
   \              0x61 0x6E    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x43 0x68          DC8 "Channel closed\012\015"
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x3A 0x20          DC8 ": unexpected channel event\012\015"
   \              0x75 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueApplicationMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x41 0x70    
   \              0x70 0x6C    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x4D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AdvanceAntRxBufferCurrentChar
       0   AdvanceAntRxBufferUnreadMsgPointer
       0   AntAbortMessage
       8   AntCalculateTxChecksum
       8   AntDeQueueApplicationMessage
         8   -> free
       8   AntDeQueueOutgoingMessage
         8   -> free
      56   AntExpectResponse
        56   -> AntDeQueueOutgoingMessage
        56   -> AntProcessMessage
        56   -> AntRxMessage
        56   -> DebugPrintf
        56   -> IsTimeUp
        56   -> __aeabi_memcpy
      16   AntInitialize
        16   -> AntSyncSerialInitialize
        16   -> DebugLineFeed
        16   -> DebugPrintf
        16   -> SspRequest
      40   AntParseExtendedData
        40   -> DebugPrintf
      48   AntProcessMessage
        48   -> AdvanceAntRxBufferUnreadMsgPointer
        48   -> AntParseExtendedData
        48   -> AntQueueExtendedApplicationMessage
        48   -> AntTickExtended
        48   -> DebugPrintNumber
        48   -> DebugPrintf
        48   -> HexToASCIICharLower
      72   AntQueueExtendedApplicationMessage
        72   -> DebugPrintf
        72   -> __aeabi_memcpy
        72   -> malloc
      64   AntQueueOutgoingMessage
        64   -> DebugPrintf
        64   -> __aeabi_memcpy4
        64   -> malloc
       8   AntRunActiveState
         8   -- Indirect call
       8   AntRxFlowControlCallback
         8   -> AntSrdyPulse
      64   AntRxMessage
        64   -> AdvanceAntRxBufferCurrentChar
        64   -> AdvanceAntRxBufferUnreadMsgPointer
        64   -> AntAbortMessage
        64   -> AntSrdyPulse
        64   -> DebugPrintf
        64   -> __aeabi_memcpy
        64   -> __aeabi_memcpy4
      16   AntSM_Idle
        16   -> AntProcessMessage
        16   -> AntTxMessage
        16   -> DebugPrintf
       0   AntSM_NoResponse
       8   AntSM_ReceiveMessage
         8   -> AntRxMessage
       8   AntSM_TransmitMessage
         8   -> AntDeQueueOutgoingMessage
         8   -> AntSrdyPulse
         8   -> DebugPrintf
         8   -> QueryMessageStatus
       0   AntSrdyPulse
      16   AntSyncSerialInitialize
        16   -> AntCalculateTxChecksum
        16   -> AntExpectResponse
        16   -> AntProcessMessage
        16   -> AntRxMessage
        16   -> AntTxMessage
        16   -> IsTimeUp
      24   AntTickExtended
        24   -> AntQueueExtendedApplicationMessage
       8   AntTxFlowControlCallback
         8   -> AntSrdyPulse
     120   AntTxMessage
       120   -> AdvanceAntRxBufferCurrentChar
       120   -> AdvanceAntRxBufferUnreadMsgPointer
       120   -> AntSrdyPulse
       120   -> DebugPrintf
       120   -> SspWriteData
       120   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_27
       4  ??DataTable21_28
       4  ??DataTable21_29
       4  ??DataTable21_3
       4  ??DataTable21_30
       4  ??DataTable21_31
       4  ??DataTable21_32
       4  ??DataTable21_33
       4  ??DataTable21_34
       4  ??DataTable21_35
       4  ??DataTable21_36
       4  ??DataTable21_37
       4  ??DataTable21_38
       4  ??DataTable21_39
       4  ??DataTable21_4
       4  ??DataTable21_40
       4  ??DataTable21_41
       4  ??DataTable21_42
       4  ??DataTable21_43
       4  ??DataTable21_44
       4  ??DataTable21_45
       4  ??DataTable21_46
       4  ??DataTable21_47
       4  ??DataTable21_48
       4  ??DataTable21_49
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      20  ?_0
      24  ?_1
      12  ?_10
      20  ?_11
      32  ?_12
      44  ?_13
      36  ?_2
      16  ?_3
      36  ?_4
      24  ?_5
      20  ?_6
      20  ?_7
      28  ?_8
      40  ?_9
      40  AdvanceAntRxBufferCurrentChar
      40  AdvanceAntRxBufferUnreadMsgPointer
      44  AntAbortMessage
      40  AntCalculateTxChecksum
      56  AntDeQueueApplicationMessage
      34  AntDeQueueOutgoingMessage
     216  AntExpectResponse
     578  AntInitialize
     272  AntParseExtendedData
    1016  AntProcessMessage
     200  AntQueueExtendedApplicationMessage
     204  AntQueueOutgoingMessage
      12  AntRunActiveState
      58  AntRxFlowControlCallback
     582  AntRxMessage
     142  AntSM_Idle
       2  AntSM_NoResponse
      24  AntSM_ReceiveMessage
     118  AntSM_TransmitMessage
      42  AntSrdyPulse
     212  AntSyncSerialInitialize
     110  AntTickExtended
      22  AntTxFlowControlCallback
     368  AntTxMessage
       4  Ant_DebugProcessRxMessages
       4  Ant_DebugQueuedDataMessages
       4  Ant_DebugRxMessageCounter
       4  Ant_DebugTotalRxMessages
       4  Ant_Ssp
     256  Ant_au8AntRxBuffer
       4  Ant_pfnStateMachine
       4  Ant_psDataOutgoingMsgList
       4  Ant_pu8AntRxBufferCurrentChar
       4  Ant_pu8AntRxBufferNextChar
       4  Ant_pu8AntRxBufferUnreadMsg
      36  Ant_sSspConfig
       4  Ant_u32ApplicationMessageCount
       4  Ant_u32CurrentTxMessageToken
       4  Ant_u32OutgoingMessageCount
       4  Ant_u32RxByteCounter
       4  Ant_u32RxTimeoutCounter
       4  Ant_u32RxTimer
       4  Ant_u32TxByteCounter
       4  Ant_u32TxTimer
       4  Ant_u32UnexpectedByteCounter
       1  Ant_u8AntNewRxMessages
      12  Ant_u8AntVersion
       1  Ant_u8SlaveMissedMessageHigh
       1  Ant_u8SlaveMissedMessageLow
       1  Ant_u8SlaveMissedMessageMid
     160  G_asAntChannelConfiguration
       8  G_au8ANTGetVersion
      12  G_au8AntAckDataMessage
       8  G_au8AntAssignChannel
      12  G_au8AntBroadcastDataMessage
       8  G_au8AntLibConfig
      24  G_au8AntMessageAssign
      24  G_au8AntMessageClose
       8  G_au8AntMessageFail
      24  G_au8AntMessageInit
      32  G_au8AntMessageInitFail
      64  G_au8AntMessageNoAnt
       8  G_au8AntMessageOk
      20  G_au8AntMessageOpen
      24  G_au8AntMessageSetup
      24  G_au8AntMessageUnassign
      40  G_au8AntMessageUnhandled
       8  G_au8AntSetChannelID
       8  G_au8AntSetChannelPeriod
       8  G_au8AntSetChannelPower
       8  G_au8AntSetChannelRFFreq
      12  G_au8AntSetNetworkKey
       4  G_sAntApplicationMsgList
       4  G_stMessageResponse
       4  G_u32AntFlags
      16  au8AntFlagAlert
      80  au8AntFlagMessages
      32  au8TxTimeoutMsg

 
   556 bytes in section .bss
   512 bytes in section .data
   372 bytes in section .rodata
 4 768 bytes in section .text
 
 4 768 bytes of CODE  memory
   372 bytes of CONST memory
 1 068 bytes of DATA  memory

Errors: none
Warnings: none
