###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       22/Mar/2018  01:39:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GUI.c
#    Command line =  
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GUI.c" -D MPGL2
#        -D MPG2 --preprocess=cl "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -lC "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List"
#        -o "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\" -I
#        "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\bsp\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\"
#        -I "C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\tetris\"
#        -On --use_c++_inline --require_prototypes -I "E:\Software\IAR
#        Systems\Embedded Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_Canada.1252
#    List file    =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\List\GUI.lst
#    Object file  =  
#        C:\Users\Anthony\Google
#        Drive\Hobbies\IAR\Razor_Atmel\firmware_dotmatrix\iar_7_20_1\Debug\Obj\GUI.o
#
###############################################################################

C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GUI.c
      1          #include "GameLogic.h"

  #define DEBUG_MODE 0
          ^
"C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\Defs.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "DEBUG_MODE" (declared at line 27)
      2          #include "GUI.h"
      3          #include "lcd_NHD-C12864Lz.h"
      4          #include "stdio.h"
      5          
      6          extern u8 G_aau8LcdRamImage[LCD_IMAGE_ROWS][LCD_IMAGE_COLUMNS];    /* A complete copy of the LCD image in RAM */
      7          
      8          #define PIXEL_SIZE 5
      9          
     10          #define LEFTSCREEN_ROW_START 4
     11          #define LEFTSCREEN_ROW_END   LEFTSCREEN_ROW_START + (MAX_ROW/2 * PIXEL_SIZE)
     12          #define LEFTSCREEN_COL_START 1
     13          #define LEFTSCREEN_COL_END   LEFTSCREEN_COL_START + (MAX_COL * PIXEL_SIZE)
     14          
     15          #define RIGHTSCREEN_ROW_START  0
     16          #define RIGHTSCREEN_ROW_END    RIGHTSCREEN_ROW_START + (MAX_ROW/2 * PIXEL_SIZE)
     17          #define RIGHTSCREEN_COL_START  52
     18          #define RIGHTSCREEN_COL_END    RIGHTSCREEN_COL_START + (MAX_COL * PIXEL_SIZE)
     19          
     20          /**
     21          *  Prints borders on the edges of each game segment
     22          */

   \                                 In section .text, align 2, keep-with-next
     23          void GUIPrintBorders()
     24          {
   \                     GUIPrintBorders: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     25              //Top Border
     26              for(uint8_t y = 0; y < LEFTSCREEN_ROW_START; y++)
   \   00000004   0x2400             MOVS     R4,#+0
   \                     ??GUIPrintBorders_0: (+1)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C04             CMP      R4,#+4
   \   0000000A   0xDA0E             BGE.N    ??GUIPrintBorders_1
     27              {
     28                  for(uint8_t x = 0; x < LEFTSCREEN_COL_END ; x++)
   \   0000000C   0x2500             MOVS     R5,#+0
   \                     ??GUIPrintBorders_2: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D33             CMP      R5,#+51
   \   00000012   0xDA08             BGE.N    ??GUIPrintBorders_3
     29                  {
     30                      GUISetPixelValue(x, y, 1);
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       GUISetPixelValue
     31                  }
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \   00000024   0xE7F3             B.N      ??GUIPrintBorders_2
     32              }
   \                     ??GUIPrintBorders_3: (+1)
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0xE7ED             B.N      ??GUIPrintBorders_0
     33          
     34              //Bottom Border
     35              for(uint8_t y = RIGHTSCREEN_ROW_END; y < 128; y++)
   \                     ??GUIPrintBorders_1: (+1)
   \   0000002A   0x243C             MOVS     R4,#+60
   \                     ??GUIPrintBorders_4: (+1)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C80             CMP      R4,#+128
   \   00000030   0xDA0E             BGE.N    ??GUIPrintBorders_5
     36              {
     37                  for(uint8_t x = RIGHTSCREEN_COL_START; x < RIGHTSCREEN_COL_END; x++)
   \   00000032   0x2534             MOVS     R5,#+52
   \                     ??GUIPrintBorders_6: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D66             CMP      R5,#+102
   \   00000038   0xDA08             BGE.N    ??GUIPrintBorders_7
     38                  {
     39                      GUISetPixelValue(x, y, 1);
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x0021             MOVS     R1,R4
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       GUISetPixelValue
     40                  }
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
   \   0000004A   0xE7F3             B.N      ??GUIPrintBorders_6
     41              }
   \                     ??GUIPrintBorders_7: (+1)
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \   0000004E   0xE7ED             B.N      ??GUIPrintBorders_4
     42              //Left Border
     43              for(uint8_t y = 0; y < 64; y++)
   \                     ??GUIPrintBorders_5: (+1)
   \   00000050   0x2400             MOVS     R4,#+0
   \                     ??GUIPrintBorders_8: (+1)
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C40             CMP      R4,#+64
   \   00000056   0xDA0E             BGE.N    ??GUIPrintBorders_9
     44              {
     45                  for(uint8_t x = 0; x < LEFTSCREEN_COL_START; x++)
   \   00000058   0x2500             MOVS     R5,#+0
   \                     ??GUIPrintBorders_10: (+1)
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD108             BNE.N    ??GUIPrintBorders_11
     46                  {
     47                      GUISetPixelValue(x, y, 1);
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x.... 0x....      BL       GUISetPixelValue
     48                  }
   \   0000006E   0x1C6D             ADDS     R5,R5,#+1
   \   00000070   0xE7F3             B.N      ??GUIPrintBorders_10
     49              }
   \                     ??GUIPrintBorders_11: (+1)
   \   00000072   0x1C64             ADDS     R4,R4,#+1
   \   00000074   0xE7ED             B.N      ??GUIPrintBorders_8
     50          
     51              //Middle Border
     52              for(uint8_t y = 0; y < 64; y++)
   \                     ??GUIPrintBorders_9: (+1)
   \   00000076   0x2400             MOVS     R4,#+0
   \                     ??GUIPrintBorders_12: (+1)
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C40             CMP      R4,#+64
   \   0000007C   0xDA0E             BGE.N    ??GUIPrintBorders_13
     53              {
     54                  for(uint8_t x = LEFTSCREEN_COL_END; x < RIGHTSCREEN_COL_START; x++)
   \   0000007E   0x2533             MOVS     R5,#+51
   \                     ??GUIPrintBorders_14: (+1)
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x2D34             CMP      R5,#+52
   \   00000084   0xDA08             BGE.N    ??GUIPrintBorders_15
     55                  {
     56                      GUISetPixelValue(x, y, 1);
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0x0021             MOVS     R1,R4
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x0028             MOVS     R0,R5
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x.... 0x....      BL       GUISetPixelValue
     57                  }
   \   00000094   0x1C6D             ADDS     R5,R5,#+1
   \   00000096   0xE7F3             B.N      ??GUIPrintBorders_14
     58              }
   \                     ??GUIPrintBorders_15: (+1)
   \   00000098   0x1C64             ADDS     R4,R4,#+1
   \   0000009A   0xE7ED             B.N      ??GUIPrintBorders_12
     59          
     60              //Right Border
     61              for(uint8_t y = 0; y < 64; y++)
   \                     ??GUIPrintBorders_13: (+1)
   \   0000009C   0x2400             MOVS     R4,#+0
   \                     ??GUIPrintBorders_16: (+1)
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0x2C40             CMP      R4,#+64
   \   000000A2   0xDA0E             BGE.N    ??GUIPrintBorders_17
     62              {
     63                  for(uint8_t x = RIGHTSCREEN_COL_END; x < RIGHTSCREEN_COL_END+1; x++)
   \   000000A4   0x2566             MOVS     R5,#+102
   \                     ??GUIPrintBorders_18: (+1)
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D67             CMP      R5,#+103
   \   000000AA   0xDA08             BGE.N    ??GUIPrintBorders_19
     64                  {
     65                      GUISetPixelValue(x, y, 1);
   \   000000AC   0x2201             MOVS     R2,#+1
   \   000000AE   0x0021             MOVS     R1,R4
   \   000000B0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B2   0x0028             MOVS     R0,R5
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x.... 0x....      BL       GUISetPixelValue
     66                  }
   \   000000BA   0x1C6D             ADDS     R5,R5,#+1
   \   000000BC   0xE7F3             B.N      ??GUIPrintBorders_18
     67              }
   \                     ??GUIPrintBorders_19: (+1)
   \   000000BE   0x1C64             ADDS     R4,R4,#+1
   \   000000C0   0xE7ED             B.N      ??GUIPrintBorders_16
     68          
     69              PixelBlockType gridMap;
     70              gridMap.u16ColumnSize = 128;
   \                     ??GUIPrintBorders_17: (+1)
   \   000000C2   0x2080             MOVS     R0,#+128
   \   000000C4   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     71              gridMap.u16RowSize = 64;
   \   000000C8   0x2040             MOVS     R0,#+64
   \   000000CA   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     72              gridMap.u16ColumnStart = 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF8AD 0x0002      STRH     R0,[SP, #+2]
     73              gridMap.u16RowStart = 0;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     74              LcdUpdateScreenRefreshArea(&gridMap);
   \   000000DA   0x4668             MOV      R0,SP
   \   000000DC   0x.... 0x....      BL       LcdUpdateScreenRefreshArea
     75          }
   \   000000E0   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void GUIPrintTetromino(GameInstance* game)
     78          {
   \                     GUIPrintTetromino: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
     79              if( game != NULL )
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD046             BEQ.N    ??GUIPrintTetromino_0
     80              {
     81                  Location block_wrt_grid;
     82                  Grid* grid = game->gridPtr;
   \   0000000C   0x6825             LDR      R5,[R4, #+0]
     83                  Tetromino* tetromino = game->blockPtr;
   \   0000000E   0x6866             LDR      R6,[R4, #+4]
     84                  
     85                  for(uint8_t y = 0; y < TETROMINO_ROWS; y++)
   \   00000010   0x2700             MOVS     R7,#+0
   \                     ??GUIPrintTetromino_1: (+1)
   \   00000012   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000014   0x2F05             CMP      R7,#+5
   \   00000016   0xDA40             BGE.N    ??GUIPrintTetromino_0
     86                  {
     87                      for(uint8_t x = 0; x < TETROMINO_COLS; x++)
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??GUIPrintTetromino_2: (+1)
   \   0000001C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000020   0xF1B8 0x0F05      CMP      R8,#+5
   \   00000024   0xDA37             BGE.N    ??GUIPrintTetromino_3
     88                      {
     89                          block_wrt_grid = blockcords_to_gridcords(tetromino, y, x);
   \   00000026   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002A   0x4642             MOV      R2,R8
   \   0000002C   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000002E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000030   0x0039             MOVS     R1,R7
   \   00000032   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       blockcords_to_gridcords
   \   0000003A   0x9000             STR      R0,[SP, #+0]
     90                          if(tetromino->_tetromino[y][x] == 1 || grid->_grid[block_wrt_grid.y][block_wrt_grid.x] == 1)
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000044   0x4430             ADD      R0,R6,R0
   \   00000046   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000004A   0xF810 0x0008      LDRB     R0,[R0, R8]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD009             BEQ.N    ??GUIPrintTetromino_4
   \   00000052   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000056   0x210A             MOVS     R1,#+10
   \   00000058   0x4348             MULS     R0,R1,R0
   \   0000005A   0x4428             ADD      R0,R5,R0
   \   0000005C   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000060   0x5C40             LDRB     R0,[R0, R1]
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD10A             BNE.N    ??GUIPrintTetromino_5
     91                          {
     92                              GUIPrintBlock(block_wrt_grid.x, block_wrt_grid.y, 1);
   \                     ??GUIPrintTetromino_4: (+1)
   \   00000066   0x2201             MOVS     R2,#+1
   \   00000068   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x.... 0x....      BL       GUIPrintBlock
   \   0000007A   0xE009             B.N      ??GUIPrintTetromino_6
     93                          }
     94                          else
     95                          {
     96                              GUIPrintBlock(block_wrt_grid.x, block_wrt_grid.y, 0);
   \                     ??GUIPrintTetromino_5: (+1)
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000082   0x0001             MOVS     R1,R0
   \   00000084   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000086   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x.... 0x....      BL       GUIPrintBlock
     97                          }
     98                      }
   \                     ??GUIPrintTetromino_6: (+1)
   \   00000090   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000094   0xE7C2             B.N      ??GUIPrintTetromino_2
     99                  }
   \                     ??GUIPrintTetromino_3: (+1)
   \   00000096   0x1C7F             ADDS     R7,R7,#+1
   \   00000098   0xE7BB             B.N      ??GUIPrintTetromino_1
    100              }
    101          }
   \                     ??GUIPrintTetromino_0: (+1)
   \   0000009A   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    102          

   \                                 In section .text, align 2, keep-with-next
    103          void GUIPrintGrid(GameInstance* game)
    104          {
   \                     GUIPrintGrid: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    105              if( game !=  NULL )
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD02A             BEQ.N    ??GUIPrintGrid_0
    106              {
    107                  Grid* grid = game->gridPtr;
   \   00000008   0x6825             LDR      R5,[R4, #+0]
    108          
    109                  for(uint8_t y = 0; y < grid->numRows; y++)
   \   0000000A   0x2600             MOVS     R6,#+0
   \                     ??GUIPrintGrid_1: (+1)
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0xF895 0x10F0      LDRB     R1,[R5, #+240]
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD222             BCS.N    ??GUIPrintGrid_0
    110                  {
    111                      for(uint8_t x = 0; x < grid->numCols; x++)
   \   00000018   0x2700             MOVS     R7,#+0
   \                     ??GUIPrintGrid_2: (+1)
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0xF895 0x10F1      LDRB     R1,[R5, #+241]
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD219             BCS.N    ??GUIPrintGrid_3
    112                      {
    113                          if( grid->_grid[y][x] == 1)
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x200A             MOVS     R0,#+10
   \   0000002A   0xFB00 0xF006      MUL      R0,R0,R6
   \   0000002E   0x4428             ADD      R0,R5,R0
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x5DC0             LDRB     R0,[R0, R7]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD107             BNE.N    ??GUIPrintGrid_4
    114                              GUIPrintBlock(x, y, 1);
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x0031             MOVS     R1,R6
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x.... 0x....      BL       GUIPrintBlock
   \   00000046   0xE006             B.N      ??GUIPrintGrid_5
    115                          else
    116                              GUIPrintBlock(x, y, 0);
   \                     ??GUIPrintGrid_4: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x.... 0x....      BL       GUIPrintBlock
    117                      }
   \                     ??GUIPrintGrid_5: (+1)
   \   00000056   0x1C7F             ADDS     R7,R7,#+1
   \   00000058   0xE7DF             B.N      ??GUIPrintGrid_2
    118                  }
   \                     ??GUIPrintGrid_3: (+1)
   \   0000005A   0x1C76             ADDS     R6,R6,#+1
   \   0000005C   0xE7D6             B.N      ??GUIPrintGrid_1
    119              }
    120          }
   \                     ??GUIPrintGrid_0: (+1)
   \   0000005E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    121          

   \                                 In section .text, align 2, keep-with-next
    122          void GUIPrintBlock(uint8_t x, uint8_t y, uint8_t val)
    123          {
   \                     GUIPrintBlock: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    124              uint8_t startingY, startingX;
    125          
    126              //Range check to make sure we aren''t trying to print outside of the grid
    127              if( x < 0 || x >= MAX_COL || y < 0 || y >= MAX_ROW)
                           ^
Warning[Pe186]: pointless comparison of unsigned integer with zero

      if( x < 0 || x >= MAX_COL || y < 0 || y >= MAX_ROW)
                                     ^
"C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GUI.c",127  Warning[Pe186]: 
          pointless comparison of unsigned integer with zero
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C0A             CMP      R4,#+10
   \   00000010   0xDA02             BGE.N    ??GUIPrintBlock_0
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D18             CMP      R5,#+24
   \   00000016   0xDB00             BLT.N    ??GUIPrintBlock_1
    128              {
    129                  return;
   \                     ??GUIPrintBlock_0: (+1)
   \   00000018   0xE067             B.N      ??GUIPrintBlock_2
    130              }
    131          
    132              //Determine which screen the block is on
    133              if( y < MAX_ROW/2 )
   \                     ??GUIPrintBlock_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D0C             CMP      R5,#+12
   \   0000001E   0xDA0C             BGE.N    ??GUIPrintBlock_3
    134              {
    135                  // Get starting point of pixel to print
    136                  startingY = (y*PIXEL_SIZE) + LEFTSCREEN_ROW_START;
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0xFB00 0xF005      MUL      R0,R0,R5
   \   00000028   0x1D00             ADDS     R0,R0,#+4
   \   0000002A   0x0007             MOVS     R7,R0
    137                  startingX = (x*PIXEL_SIZE) + LEFTSCREEN_COL_START;
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2005             MOVS     R0,#+5
   \   00000030   0xFB00 0xF004      MUL      R0,R0,R4
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x4680             MOV      R8,R0
   \   00000038   0xE011             B.N      ??GUIPrintBlock_4
    138              }
    139              else if ( y >= MAX_ROW/2 && y < MAX_ROW )
   \                     ??GUIPrintBlock_3: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D0C             CMP      R5,#+12
   \   0000003E   0xDB0E             BLT.N    ??GUIPrintBlock_4
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D18             CMP      R5,#+24
   \   00000044   0xDA0B             BGE.N    ??GUIPrintBlock_4
    140              {
    141                  startingY = (y*PIXEL_SIZE - MAX_ROW/2*PIXEL_SIZE) + RIGHTSCREEN_ROW_START;
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2005             MOVS     R0,#+5
   \   0000004A   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000004E   0x383C             SUBS     R0,R0,#+60
   \   00000050   0x0007             MOVS     R7,R0
    142                  startingX = (x*PIXEL_SIZE) + RIGHTSCREEN_COL_START;
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2005             MOVS     R0,#+5
   \   00000056   0xFB00 0xF004      MUL      R0,R0,R4
   \   0000005A   0x3034             ADDS     R0,R0,#+52
   \   0000005C   0x4680             MOV      R8,R0
    143              }
    144          
    145              //Left and right
    146              for(uint8_t j = startingY; j < startingY + PIXEL_SIZE; j++)
   \                     ??GUIPrintBlock_4: (+1)
   \   0000005E   0x46B9             MOV      R9,R7
   \                     ??GUIPrintBlock_5: (+1)
   \   00000060   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x1D78             ADDS     R0,R7,#+5
   \   00000068   0x4581             CMP      R9,R0
   \   0000006A   0xDA13             BGE.N    ??GUIPrintBlock_6
    147              {
    148                  GUISetPixelValue(startingX, j, val);
   \   0000006C   0x0032             MOVS     R2,R6
   \   0000006E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x.... 0x....      BL       GUISetPixelValue
    149                  GUISetPixelValue(startingX + PIXEL_SIZE-1, j, val);
   \   0000007C   0x0032             MOVS     R2,R6
   \   0000007E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000080   0x4649             MOV      R1,R9
   \   00000082   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000084   0xF118 0x0004      ADDS     R0,R8,#+4
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x.... 0x....      BL       GUISetPixelValue
    150              }
   \   0000008E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000092   0xE7E5             B.N      ??GUIPrintBlock_5
    151          
    152              //Top and bottom
    153              for(uint8_t i = startingX; i < startingX + PIXEL_SIZE; i++)
   \                     ??GUIPrintBlock_6: (+1)
   \   00000094   0x46C1             MOV      R9,R8
   \                     ??GUIPrintBlock_7: (+1)
   \   00000096   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000009A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009E   0xF118 0x0005      ADDS     R0,R8,#+5
   \   000000A2   0x4581             CMP      R9,R0
   \   000000A4   0xDA12             BGE.N    ??GUIPrintBlock_8
    154              {
    155                  GUISetPixelValue(i, startingY, val);
   \   000000A6   0x0032             MOVS     R2,R6
   \   000000A8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AA   0x0039             MOVS     R1,R7
   \   000000AC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AE   0x4648             MOV      R0,R9
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x.... 0x....      BL       GUISetPixelValue
    156                  GUISetPixelValue(i, startingY + PIXEL_SIZE-1, val);
   \   000000B6   0x0032             MOVS     R2,R6
   \   000000B8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000BA   0x1D39             ADDS     R1,R7,#+4
   \   000000BC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BE   0x4648             MOV      R0,R9
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0x.... 0x....      BL       GUISetPixelValue
    157              }
   \   000000C6   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000CA   0xE7E4             B.N      ??GUIPrintBlock_7
    158          
    159              PixelBlockType gridMap;
    160              gridMap.u16ColumnSize = 128;
   \                     ??GUIPrintBlock_8: (+1)
   \   000000CC   0x2080             MOVS     R0,#+128
   \   000000CE   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    161              gridMap.u16RowSize = 64;
   \   000000D2   0x2040             MOVS     R0,#+64
   \   000000D4   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    162              gridMap.u16ColumnStart = 0;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    163              gridMap.u16RowStart = 0;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    164              LcdUpdateScreenRefreshArea(&gridMap);
   \   000000E4   0x4668             MOV      R0,SP
   \   000000E6   0x.... 0x....      BL       LcdUpdateScreenRefreshArea
    165          }
   \                     ??GUIPrintBlock_2: (+1)
   \   000000EA   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    166          

   \                                 In section .text, align 2, keep-with-next
    167          void GUISetPixelValue(uint8_t col, uint8_t row, uint8_t val)
    168          {
   \                     GUISetPixelValue: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    169              PixelAddressType targetPixel;
    170              targetPixel.u16PixelColumnAddress = col;
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0xF8AD 0x4002      STRH     R4,[SP, #+2]
    171              targetPixel.u16PixelRowAddress = row;
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0xF8AD 0x5000      STRH     R5,[SP, #+0]
    172          
    173              if(val > 0 )
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD003             BEQ.N    ??GUISetPixelValue_0
    174              {
    175                  LcdSetPixel(&targetPixel);
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       LcdSetPixel
   \   00000022   0xE005             B.N      ??GUISetPixelValue_1
    176              }
    177              else if ( val == 0 )
   \                     ??GUISetPixelValue_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD102             BNE.N    ??GUISetPixelValue_1
    178              {
    179                  LcdClearPixel(&targetPixel);
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x.... 0x....      BL       LcdClearPixel
    180              }
    181          }
   \                     ??GUISetPixelValue_1: (+1)
   \   00000030   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    182          

   \                                 In section .text, align 2, keep-with-next
    183          void print_bottom_half(GameInstance *game)
    184          {
   \                     print_bottom_half: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
    185              if(game != NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD07D             BEQ.N    ??print_bottom_half_0
    186              {    
    187                  Grid* grid = game->gridPtr;
   \   0000000C   0x6825             LDR      R5,[R4, #+0]
    188                  Tetromino* tetromino = game->blockPtr;
   \   0000000E   0x6866             LDR      R6,[R4, #+4]
    189                  u8* ramPtr;
    190          
    191                  uint8_t BYTE_MASK;
    192                  uint32_t j = 2;
   \   00000010   0xF05F 0x0802      MOVS     R8,#+2
    193                  
    194                  for(uint8_t y = grid->numRows/2; y < grid->numRows ; y++)
   \   00000014   0xF895 0x00F0      LDRB     R0,[R5, #+240]
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \                     ??print_bottom_half_1: (+1)
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0xF895 0x20F0      LDRB     R2,[R5, #+240]
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xD25F             BCS.N    ??print_bottom_half_2
    195                  {
    196                      for(uint8_t c = 0 ; c < PIXEL_SIZE; c++)
   \   0000002A   0x2100             MOVS     R1,#+0
   \                     ??print_bottom_half_3: (+1)
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x2905             CMP      R1,#+5
   \   00000030   0xDA59             BGE.N    ??print_bottom_half_4
    197                      {
    198                          //Shift the pointer to the correct byte
    199                          ramPtr = &(G_aau8LcdRamImage[RIGHTSCREEN_ROW_START+y*PIXEL_SIZE-(grid->numRows/2*PIXEL_SIZE)+c][6]);
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2205             MOVS     R2,#+5
   \   00000036   0xFB02 0xF200      MUL      R2,R2,R0
   \   0000003A   0xF895 0x30F0      LDRB     R3,[R5, #+240]
   \   0000003E   0xF05F 0x0C02      MOVS     R12,#+2
   \   00000042   0xFB93 0xF3FC      SDIV     R3,R3,R12
   \   00000046   0xF05F 0x0C05      MOVS     R12,#+5
   \   0000004A   0xFB0C 0x2213      MLS      R2,R12,R3,R2
   \   0000004E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   0x188A             ADDS     R2,R1,R2
   \   00000052   0x0112             LSLS     R2,R2,#+4
   \   00000054   0x....             LDR.N    R3,??DataTable2_1
   \   00000056   0x441A             ADD      R2,R3,R2
   \   00000058   0x1D92             ADDS     R2,R2,#+6
   \   0000005A   0x4691             MOV      R9,R2
    200                          j = 2;
   \   0000005C   0x2202             MOVS     R2,#+2
   \   0000005E   0x4690             MOV      R8,R2
    201          
    202                          //Shift the pointer to the correct bit
    203                          BYTE_MASK = 0x04;
   \   00000060   0x2204             MOVS     R2,#+4
   \   00000062   0x0017             MOVS     R7,R2
    204                          int s;
                                     ^
Warning[Pe177]: variable "s" was declared but never referenced

          Tetromino* tetromino = game->blockPtr;
                     ^
"C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GUI.c",188  Warning[Pe177]: 
          variable "tetromino" was declared but never referenced
    205                          for(uint8_t x = 0; x < grid->numCols; x++)
   \   00000064   0x2200             MOVS     R2,#+0
   \                     ??print_bottom_half_5: (+1)
   \   00000066   0x0013             MOVS     R3,R2
   \   00000068   0xF895 0xC0F1      LDRB     R12,[R5, #+241]
   \   0000006C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000006E   0x4563             CMP      R3,R12
   \   00000070   0xD237             BCS.N    ??print_bottom_half_6
    206                          {
    207                              for(uint8_t i = 0; i < PIXEL_SIZE; i++)
   \   00000072   0x2300             MOVS     R3,#+0
   \                     ??print_bottom_half_7: (+1)
   \   00000074   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000076   0x2B05             CMP      R3,#+5
   \   00000078   0xDA31             BGE.N    ??print_bottom_half_8
    208                              {
    209          
    210                                  if(grid->_grid[y][x] == 1 && (i == 0 || i == PIXEL_SIZE-1 || c == 0 || c == PIXEL_SIZE -1 ))
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000080   0xFB0C 0xFC00      MUL      R12,R12,R0
   \   00000084   0x44AC             ADD      R12,R5,R12
   \   00000086   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000088   0xF81C 0xC002      LDRB     R12,[R12, R2]
   \   0000008C   0xF1BC 0x0F01      CMP      R12,#+1
   \   00000090   0xD112             BNE.N    ??print_bottom_half_9
   \   00000092   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000094   0x2B00             CMP      R3,#+0
   \   00000096   0xD008             BEQ.N    ??print_bottom_half_10
   \   00000098   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000009A   0x2B04             CMP      R3,#+4
   \   0000009C   0xD005             BEQ.N    ??print_bottom_half_10
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD002             BEQ.N    ??print_bottom_half_10
   \   000000A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   0x2904             CMP      R1,#+4
   \   000000A8   0xD106             BNE.N    ??print_bottom_half_9
    211                                      *ramPtr = *ramPtr | BYTE_MASK;
   \                     ??print_bottom_half_10: (+1)
   \   000000AA   0xF899 0xC000      LDRB     R12,[R9, #+0]
   \   000000AE   0xEA57 0x0C0C      ORRS     R12,R7,R12
   \   000000B2   0xF889 0xC000      STRB     R12,[R9, #+0]
   \   000000B6   0xE005             B.N      ??print_bottom_half_11
    212                                  else
    213                                      *ramPtr = *ramPtr & ~BYTE_MASK;
   \                     ??print_bottom_half_9: (+1)
   \   000000B8   0xF899 0xC000      LDRB     R12,[R9, #+0]
   \   000000BC   0xEA3C 0x0C07      BICS     R12,R12,R7
   \   000000C0   0xF889 0xC000      STRB     R12,[R9, #+0]
    214          
    215                                  BYTE_MASK = BYTE_MASK << 1;
   \                     ??print_bottom_half_11: (+1)
   \   000000C4   0x007F             LSLS     R7,R7,#+1
    216                                  j++;
   \   000000C6   0xF118 0x0801      ADDS     R8,R8,#+1
    217          
    218                                  if( j % 8 == 0 )
   \   000000CA   0xF018 0x0F07      TST      R8,#0x7
   \   000000CE   0xD104             BNE.N    ??print_bottom_half_12
    219                                  {
    220                                      ramPtr++;
   \   000000D0   0xF119 0x0901      ADDS     R9,R9,#+1
    221                                      BYTE_MASK = 0x01;
   \   000000D4   0xF05F 0x0C01      MOVS     R12,#+1
   \   000000D8   0x4667             MOV      R7,R12
    222                                  }
    223                              }
   \                     ??print_bottom_half_12: (+1)
   \   000000DA   0x1C5B             ADDS     R3,R3,#+1
   \   000000DC   0xE7CA             B.N      ??print_bottom_half_7
    224                          }
   \                     ??print_bottom_half_8: (+1)
   \   000000DE   0x1C52             ADDS     R2,R2,#+1
   \   000000E0   0xE7C1             B.N      ??print_bottom_half_5
    225                      }
   \                     ??print_bottom_half_6: (+1)
   \   000000E2   0x1C49             ADDS     R1,R1,#+1
   \   000000E4   0xE7A2             B.N      ??print_bottom_half_3
    226                  }
   \                     ??print_bottom_half_4: (+1)
   \   000000E6   0x1C40             ADDS     R0,R0,#+1
   \   000000E8   0xE799             B.N      ??print_bottom_half_1
    227                  PixelBlockType gridMap;
    228                  gridMap.u16ColumnSize = 128;
   \                     ??print_bottom_half_2: (+1)
   \   000000EA   0x2080             MOVS     R0,#+128
   \   000000EC   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    229                  gridMap.u16RowSize = 64;
   \   000000F0   0x2040             MOVS     R0,#+64
   \   000000F2   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    230                  gridMap.u16ColumnStart = 0;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    231                  gridMap.u16RowStart = 0;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    232                  LcdUpdateScreenRefreshArea(&gridMap);
   \   00000102   0x4668             MOV      R0,SP
   \   00000104   0x.... 0x....      BL       LcdUpdateScreenRefreshArea
    233              }
    234          }
   \                     ??print_bottom_half_0: (+1)
   \   00000108   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    235          

   \                                 In section .text, align 2, keep-with-next
    236          void print_top_half(GameInstance* game)
    237          {
   \                     print_top_half: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
    238              if(game != NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD070             BEQ.N    ??print_top_half_0
    239              {    
    240                  Grid* grid = game->gridPtr;
   \   0000000C   0x6825             LDR      R5,[R4, #+0]
    241                  Tetromino* tetromino = game->blockPtr;
   \   0000000E   0x6866             LDR      R6,[R4, #+4]
    242                  u8* ramPtr;
    243          
    244                  uint8_t BYTE_MASK;
    245                  uint32_t j = 0;
   \   00000010   0xF05F 0x0800      MOVS     R8,#+0
    246                  
    247                  for(uint8_t y = 0; y < grid->numRows/2 ; y++)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??print_top_half_1: (+1)
   \   00000016   0xF895 0x10F0      LDRB     R1,[R5, #+240]
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xDA54             BGE.N    ??print_top_half_2
    248                  {
    249                      for(uint8_t c = 0 ; c < PIXEL_SIZE; c++)
   \   00000026   0x2100             MOVS     R1,#+0
   \                     ??print_top_half_3: (+1)
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x2905             CMP      R1,#+5
   \   0000002C   0xDA4E             BGE.N    ??print_top_half_4
    250                      {
    251                          //Shift the pointer to the correct byte
    252                          ramPtr = &(G_aau8LcdRamImage[LEFTSCREEN_ROW_START+y*PIXEL_SIZE+c][0]);
   \   0000002E   0x....             LDR.N    R2,??DataTable2_1
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2305             MOVS     R3,#+5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0xFB03 0x1300      MLA      R3,R3,R0,R1
   \   0000003A   0x011B             LSLS     R3,R3,#+4
   \   0000003C   0x441A             ADD      R2,R2,R3
   \   0000003E   0x3240             ADDS     R2,R2,#+64
   \   00000040   0x4691             MOV      R9,R2
    253                          j = 0;
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x4690             MOV      R8,R2
    254          
    255                          //Shift the pointer to the correct bit
    256                          BYTE_MASK = 0x01;
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x0017             MOVS     R7,R2
    257                          int s;
                                     ^
Warning[Pe177]: variable "s" was declared but never referenced

          Tetromino* tetromino = game->blockPtr;
                     ^
"C:\Users\Anthony\Google Drive\Hobbies\IAR\Razor_Atmel\firmware_common\tetris\GUI.c",241  Warning[Pe177]: 
          variable "tetromino" was declared but never referenced
    258                          for(uint8_t x = 0; x < grid->numCols; x++)
   \   0000004A   0x2200             MOVS     R2,#+0
   \                     ??print_top_half_5: (+1)
   \   0000004C   0x0013             MOVS     R3,R2
   \   0000004E   0xF895 0xC0F1      LDRB     R12,[R5, #+241]
   \   00000052   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000054   0x4563             CMP      R3,R12
   \   00000056   0xD237             BCS.N    ??print_top_half_6
    259                          {
    260                              for(uint8_t i = 0; i < PIXEL_SIZE; i++)
   \   00000058   0x2300             MOVS     R3,#+0
   \                     ??print_top_half_7: (+1)
   \   0000005A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000005C   0x2B05             CMP      R3,#+5
   \   0000005E   0xDA31             BGE.N    ??print_top_half_8
    261                              {
    262                                  if(grid->_grid[y][x] == 1 && (i == 0 || i == PIXEL_SIZE-1 || c == 0 || c == PIXEL_SIZE -1 ))
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000066   0xFB0C 0xFC00      MUL      R12,R12,R0
   \   0000006A   0x44AC             ADD      R12,R5,R12
   \   0000006C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006E   0xF81C 0xC002      LDRB     R12,[R12, R2]
   \   00000072   0xF1BC 0x0F01      CMP      R12,#+1
   \   00000076   0xD112             BNE.N    ??print_top_half_9
   \   00000078   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000007A   0x2B00             CMP      R3,#+0
   \   0000007C   0xD008             BEQ.N    ??print_top_half_10
   \   0000007E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000080   0x2B04             CMP      R3,#+4
   \   00000082   0xD005             BEQ.N    ??print_top_half_10
   \   00000084   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xD002             BEQ.N    ??print_top_half_10
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x2904             CMP      R1,#+4
   \   0000008E   0xD106             BNE.N    ??print_top_half_9
    263                                      *ramPtr = *ramPtr | BYTE_MASK;
   \                     ??print_top_half_10: (+1)
   \   00000090   0xF899 0xC000      LDRB     R12,[R9, #+0]
   \   00000094   0xEA57 0x0C0C      ORRS     R12,R7,R12
   \   00000098   0xF889 0xC000      STRB     R12,[R9, #+0]
   \   0000009C   0xE005             B.N      ??print_top_half_11
    264                                  else
    265                                      *ramPtr = *ramPtr & ~BYTE_MASK;
   \                     ??print_top_half_9: (+1)
   \   0000009E   0xF899 0xC000      LDRB     R12,[R9, #+0]
   \   000000A2   0xEA3C 0x0C07      BICS     R12,R12,R7
   \   000000A6   0xF889 0xC000      STRB     R12,[R9, #+0]
    266           
    267                                  BYTE_MASK = BYTE_MASK << 1;
   \                     ??print_top_half_11: (+1)
   \   000000AA   0x007F             LSLS     R7,R7,#+1
    268                                  j++;
   \   000000AC   0xF118 0x0801      ADDS     R8,R8,#+1
    269          
    270                                  if( j % 8 == 0 )
   \   000000B0   0xF018 0x0F07      TST      R8,#0x7
   \   000000B4   0xD104             BNE.N    ??print_top_half_12
    271                                  {
    272                                      ramPtr++;
   \   000000B6   0xF119 0x0901      ADDS     R9,R9,#+1
    273                                      BYTE_MASK = 0x01;
   \   000000BA   0xF05F 0x0C01      MOVS     R12,#+1
   \   000000BE   0x4667             MOV      R7,R12
    274                                  }
    275                              }
   \                     ??print_top_half_12: (+1)
   \   000000C0   0x1C5B             ADDS     R3,R3,#+1
   \   000000C2   0xE7CA             B.N      ??print_top_half_7
    276                          }
   \                     ??print_top_half_8: (+1)
   \   000000C4   0x1C52             ADDS     R2,R2,#+1
   \   000000C6   0xE7C1             B.N      ??print_top_half_5
    277                      }
   \                     ??print_top_half_6: (+1)
   \   000000C8   0x1C49             ADDS     R1,R1,#+1
   \   000000CA   0xE7AD             B.N      ??print_top_half_3
    278                  }
   \                     ??print_top_half_4: (+1)
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0xE7A2             B.N      ??print_top_half_1
    279                  PixelBlockType gridMap;
    280                  gridMap.u16ColumnSize = 128;
   \                     ??print_top_half_2: (+1)
   \   000000D0   0x2080             MOVS     R0,#+128
   \   000000D2   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    281                  gridMap.u16RowSize = 64;
   \   000000D6   0x2040             MOVS     R0,#+64
   \   000000D8   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    282                  gridMap.u16ColumnStart = 0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    283                  gridMap.u16RowStart = 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    284                  LcdUpdateScreenRefreshArea(&gridMap);
   \   000000E8   0x4668             MOV      R0,SP
   \   000000EA   0x.... 0x....      BL       LcdUpdateScreenRefreshArea
    285              }
    286          }
   \                     ??print_top_half_0: (+1)
   \   000000EE   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    287          

   \                                 In section .text, align 2, keep-with-next
    288          void GUIPrintScore(uint16_t lines)
    289          {
   \                     GUIPrintScore: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    290              PixelAddressType starting;
    291              starting.u16PixelColumnAddress = RIGHTSCREEN_COL_END+2;
   \   00000004   0x2068             MOVS     R0,#+104
   \   00000006   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    292              starting.u16PixelRowAddress = LEFTSCREEN_ROW_START+2;
   \   0000000A   0x2006             MOVS     R0,#+6
   \   0000000C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    293              LcdLoadString("scor", LCD_FONT_SMALL, &starting); 
   \   00000010   0x466A             MOV      R2,SP
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x....             LDR.N    R0,??DataTable2_2
   \   00000016   0x.... 0x....      BL       LcdLoadString
    294              starting.u16PixelRowAddress = LEFTSCREEN_ROW_START+15;
   \   0000001A   0x2013             MOVS     R0,#+19
   \   0000001C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    295              char score[10];
    296              sprintf(score, "%d", lines);
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000022   0x0022             MOVS     R2,R4
   \   00000024   0x....             ADR.N    R1,??DataTable2  ;; 0x25, 0x64, 0x00, 0x00
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       sprintf
    297              
    298              LcdLoadString(score, LCD_FONT_SMALL, &starting); 
                                   ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   0000002C   0x466A             MOV      R2,SP
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       LcdLoadString
    299          }
   \   00000036   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     G_aau8LcdRamImage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x73 0x63          DC8 "scor"
   \              0x6F 0x72    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x64          DC8 "%d"
   \              0x00         
   \   00000003   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   GUIPrintBlock
        40   -> GUISetPixelValue
        40   -> LcdUpdateScreenRefreshArea
      24   GUIPrintBorders
        24   -> GUISetPixelValue
        24   -> LcdUpdateScreenRefreshArea
      24   GUIPrintGrid
        24   -> GUIPrintBlock
      24   GUIPrintScore
        24   -> LcdLoadString
        24   -> sprintf
      32   GUIPrintTetromino
        32   -> GUIPrintBlock
        32   -> blockcords_to_gridcords
      24   GUISetPixelValue
        24   -> LcdClearPixel
        24   -> LcdSetPixel
      40   print_bottom_half
        40   -> LcdUpdateScreenRefreshArea
      40   print_top_half
        40   -> LcdUpdateScreenRefreshArea


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       8  ?_0
       4  ?_1
     238  GUIPrintBlock
     226  GUIPrintBorders
      96  GUIPrintGrid
      56  GUIPrintScore
     158  GUIPrintTetromino
      50  GUISetPixelValue
     268  print_bottom_half
     242  print_top_half

 
    12 bytes in section .rodata
 1 346 bytes in section .text
 
 1 346 bytes of CODE  memory
    12 bytes of CONST memory

Errors: none
Warnings: 8
